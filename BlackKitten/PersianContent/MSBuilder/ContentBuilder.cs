/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : ContentBuilder.cs
 * File Description : 
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 8/5/2013
 * Comment          : 
 */

using Microsoft.Build.Construction;
using Microsoft.Build.Evaluation;
using Microsoft.Build.Execution;
using Microsoft.Build.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime;
using System.Runtime.CompilerServices;

namespace MSBuilder
{
    public class ContentBuilder : IDisposable
    {
        #region Fields & Properties
        
        const string frameMark = "Frame ";
        const string textureMark = "TextureFilename {\r\n      ";
        const string extensionType = ".xnb";
        const string xnaVersion = ", Version=4.0.0.0, PublicKeyToken=842cf8be1de50553";
        static string[] pipelineAssemblies =
        {
            "Microsoft.Xna.Framework.Content.Pipeline.FBXImporter" + xnaVersion,
            "Microsoft.Xna.Framework.Content.Pipeline.XImporter" + xnaVersion,
            "Microsoft.Xna.Framework.Content.Pipeline.TextureImporter" + xnaVersion,
            "Microsoft.Xna.Framework.Content.Pipeline.EffectImporter" + xnaVersion,
        };
        string TempFilePath;
        string EngineContentDir;
        string CurrentDir;
        Project buildProject;
        ProjectRootElement projectRootElement;
        BuildParameters buildParameters;
        List<ProjectItem> projectItems;
        ErrorLogger errorLogger;
        string buildDirectory;
        Dictionary<string, List<string>> diffuseMaps;
        bool isDisposed;

        string _OutPutBuildPath;
        public string OutPutBuildPath
        {
            get
            {
                return this._OutPutBuildPath;
            }
            set
            {
                _OutPutBuildPath = value;
                buildProject.SetProperty("OutputPath", _OutPutBuildPath);
            }
        }

        #endregion

        #region Initialization

        public ContentBuilder(string EngineContentDir, string CurrentDir)
        {
            this.EngineContentDir = EngineContentDir;
            this.CurrentDir = CurrentDir;
            this.diffuseMaps = new Dictionary<string, List<string>>();
            this.projectItems = new List<ProjectItem>();
            CreateBuildProject(EngineContentDir, CurrentDir);
        }
        
        ~ContentBuilder()
        {
            Dispose(false);
        }

        #endregion

        #region MSBuild

        /// <summary>
        /// Creates a temporary MSBuild content project in memory.
        /// </summary>
        private void CreateBuildProject(string EngineContentDir, string CurrentDir)
        {
            buildDirectory = Path.Combine(EngineContentDir, @"..\..\..\..");
            string projectPath = Path.Combine(buildDirectory, "content.contentproj");
            this._OutPutBuildPath = Path.Combine(EngineContentDir, @"..\");

            // Create the build project.
            projectRootElement = ProjectRootElement.Create(projectPath);

            // Include the standard targets file that defines how to build XNA Framework content.
            projectRootElement.AddImport(@"$(MSBuildExtensionsPath)\Microsoft\XNA Game Studio\v4.0\Microsoft.Xna.GameStudio.ContentPipeline.targets");

            #region Create Build Project and set it's properties

            buildProject = new Project(projectRootElement);

            buildProject.SetProperty("OutputType", "Library");
            buildProject.SetProperty("XnaPlatform", "Windows");
            buildProject.SetProperty("XnaProfile", "HiDef");
            buildProject.SetProperty("TargetFrameworkVersion", "v4.0");
            buildProject.SetProperty("XnaFrameworkVersion", "v4.0");
            buildProject.SetProperty("Configuration", "Debug");
            buildProject.SetProperty("Platform", "x86");
            buildProject.SetProperty("OutputPath", _OutPutBuildPath);

            #endregion

            #region Add References

            buildProject.AddItem("Reference",
                "Microsoft.Xna.Framework.Content.Pipeline, Version=4.0.0.0, Culture=neutral, PublicKeyToken=842cf8be1de50553, processorArchitecture=x86");
            buildProject.AddItem("Reference",
                "Microsoft.Xna.Framework.Content.Pipeline.AudioImporters, Version=4.0.0.0, Culture=neutral, PublicKeyToken=842cf8be1de50553, processorArchitecture=x86");
            buildProject.AddItem("Reference",
                "Microsoft.Xna.Framework.Content.Pipeline.EffectImporter, Version=4.0.0.0, Culture=neutral, PublicKeyToken=842cf8be1de50553, processorArchitecture=MSIL");
            buildProject.AddItem("Reference",
                "Microsoft.Xna.Framework.Content.Pipeline.FBXImporter, Version=4.0.0.0, Culture=neutral, PublicKeyToken=842cf8be1de50553, processorArchitecture=x86");
            buildProject.AddItem("Reference",
                "Microsoft.Xna.Framework.Content.Pipeline.TextureImporter, Version=4.0.0.0, Culture=neutral, PublicKeyToken=842cf8be1de50553, processorArchitecture=x86");
            buildProject.AddItem("Reference",
                "Microsoft.Xna.Framework.Content.Pipeline.VideoImporters, Version=4.0.0.0, Culture=neutral, PublicKeyToken=842cf8be1de50553, processorArchitecture=x86");
            buildProject.AddItem("Reference",
                "Microsoft.Xna.Framework.Content.Pipeline.XImporter, Version=4.0.0.0, Culture=neutral, PublicKeyToken=842cf8be1de50553, processorArchitecture=x86");

            buildProject.AddItem("Reference", CurrentDir + @"\PersianPipelines.dll");

            #endregion

            // Hook up our custom error logger.
            errorLogger = new ErrorLogger();

            buildParameters = new BuildParameters(ProjectCollection.GlobalProjectCollection);
            buildParameters.Loggers = new ILogger[] { errorLogger };
        }

        /// <summary>
        /// Adds a new content file to the MSBuild project. The importer and
        /// processor are optional: if you leave the importer null, it will
        /// be autodetected based on the file extension, and if you leave the
        /// processor null, data will be passed through without any processing.
        /// </summary>
        public void Add(string filePath, string name, string importer, string processor, 
            Dictionary<string, string> DebuggingOptions)
        {
            var item = buildProject.AddItem("Compile", filePath)[0];
            item.SetMetadataValue("Link", Path.GetFileName(filePath));
            item.SetMetadataValue("Name", name);

            if (!string.IsNullOrEmpty(importer))
            {
                item.SetMetadataValue("Importer", importer);
            }
            if (!string.IsNullOrEmpty(processor))
            {
                item.SetMetadataValue("Processor", processor);
                if (DebuggingOptions != null)
                {
                    foreach (string optionKey in DebuggingOptions.Keys)
                    {
                        item.SetMetadataValue(optionKey, DebuggingOptions[optionKey]);
                    }
                }
            }
            projectItems.Add(item);
        }


        /// <summary>
        /// Removes all content files from the MSBuild project.
        /// </summary>
        public void Clear()
        {
            buildProject.RemoveItems(projectItems);
            projectItems.Clear();
        }


        /// <summary>
        /// Builds all the content files which have been added to the project,
        /// dynamically creating .xnb files in the OutputDirectory.
        /// Returns an error message if the build fails.
        /// </summary>
        public string Build()
        {
            // Clear any previous errors.
            errorLogger.Errors.Clear();
            
            BuildManager.DefaultBuildManager.ResetCaches();

            // Create and submit a new asynchronous build request.
            BuildManager.DefaultBuildManager.BeginBuild(buildParameters);

            var request = new BuildRequestData(buildProject.CreateProjectInstance(), new string[0]);
            var submission = BuildManager.DefaultBuildManager.PendBuildRequest(request);

            submission.ExecuteAsync(null, null);

            // Wait for the build to finish.
            submission.WaitHandle.WaitOne();

            BuildManager.DefaultBuildManager.EndBuild();

            // If the build failed, return an error string.
            if (submission.BuildResult.OverallResult == BuildResultCode.Failure)
            {
                return string.Join("\n", errorLogger.Errors.ToArray());
            }

            return null;
        }


        #endregion

        #region Importer's Methods

        private bool ArrangeTextures(string filePath)
        {
            this.diffuseMaps.Clear();

            //Read all text file
            var dxFile = File.ReadAllText(filePath);

            int i, Index = 0, gIndex = 0, lIndex = 0;
            string read;
            char c = '\0';
            string meshName;
            var textureNames = new List<string>();
            var textureName = string.Empty;

            while (true)
            {
                //Get first mesh name
                meshName = string.Empty;
                meshName = FindMeshName(dxFile, ref Index);
                if (Index == -1) break;

                var nextIndex = Index;

                //Get the next mesh name
                var nextmeshName = FindMeshName(dxFile, ref nextIndex);
                if (nextIndex == -1)
                {
                    //This means there is no next mesh block
                    nextIndex = int.MaxValue;
                }

                textureNames = new List<string>();
                if (textureName != string.Empty)
                {
                    textureNames.Add(textureName);
                }
                while (true)
                {
                    gIndex = dxFile.IndexOf("TextureFilename", gIndex + 1);
                    if (gIndex == -1) break;

                    read = "";
                    c = '\0';
                    i = 0;
                    while (c != '}')
                    {
                        c = dxFile[gIndex + i];
                        read += c;
                        i++;
                    }
                    i = read.IndexOf(".jpg");
                    if (i == -1)
                    {
                        i = read.IndexOf(".png");
                        if (i == -1)
                        {
                            i = read.IndexOf(".dds");
                        }
                    }
                    if (i != -1)
                    {
                        lIndex = i;
                        c = '\0';
                        i = 0;
                        //Find first "
                        while (c != '"')
                        {
                            i++;
                            c = read[lIndex - i];
                        }
                        //first is start index
                        var startIndex = lIndex - i + 1;

                        c = '\0';
                        i = 0;
                        while (c != '"')
                        {
                            i++;
                            c = read[lIndex + i];
                        }
                        //second is stop index
                        var stopIndex = lIndex + i;

                        textureName = read.Substring(startIndex, stopIndex - startIndex);

                        if (Index <= gIndex && gIndex <= nextIndex)
                        {
                            textureNames.Add(textureName);
                        }
                        else
                        {
                            //Remove additional space from mesh name
                            meshName = meshName.Replace(" ", "");
                            this.diffuseMaps.Add(meshName, textureNames);
                            break;
                        }
                    }
                }
                if (nextIndex == int.MaxValue)
                {
                    meshName = meshName.Replace(" ", "");
                    this.diffuseMaps.Add(meshName, textureNames);
                    break;
                }
            }
            
            var destinationPath = EngineContentDir + @"\Textures\Utilities\DiffuseMaps\";
            var sourceTexturePath = Path.GetDirectoryName(filePath);

            var removed = new List<string>();
            //Copy textures to folder of textures and remove them from source file
            foreach (var key in this.diffuseMaps.Keys)
            {
                var listofNames = this.diffuseMaps[key];
                for (int k = 0; k < listofNames.Count; ++k)
                {
                    CutTo(sourceTexturePath + @"\" + listofNames[k], destinationPath + listofNames[k]);
                    if (!removed.Contains(listofNames[k]))
                    {
                        removed.Add(listofNames[k]);
                        dxFile = dxFile.Replace(listofNames[k], string.Empty);
                    }
                }
            }
            
            //Create unique name
            this.TempFilePath = this.CurrentDir + @"\Content\" +
                string.Format("TempM_{0}{1}{2}{3}{4}{5}.x",
                DateTime.Now.Month,
                DateTime.Now.Day,
                DateTime.Now.Year,
                DateTime.Now.Hour,
                DateTime.Now.Minute,
                DateTime.Now.Second);

            //Now save it again into temp
            using (var sw = new StreamWriter(this.TempFilePath))
            {
                sw.Write(dxFile);
                sw.Flush();
                sw.Close();
            };

            //Release all
            dxFile = string.Empty;
            
            return true;
        }

        private string FindMeshName(string dxFile, ref int Index)
        {
            string meshName = string.Empty;
            int i, startIndex;
            char c;

            while (true)
            {
                Index = dxFile.IndexOf("Mesh ", Index + 1);
                if (Index == -1) break;

                c = '\0';
                i = 0;
                while (c != '{')
                {
                    i++;
                    c = dxFile[Index + i];
                }

                startIndex = Index + 4;// 4 for "Mesh "
                meshName = dxFile.Substring(startIndex, Index + i - startIndex);
                if (!string.IsNullOrWhiteSpace(meshName))
                {
                    break;
                }
            }
            return meshName;
        }

        private string ReadMeshName(string str)
        {
            var i = str.IndexOf("{");
            return str.Substring(0, i - 1) + "_obj";
        }

        private bool ReadAndRemoveTextures(string meshName, ref string str)
        {
            int count = 0;
            int startIndex = 0;

            int startWithSpace = -1;
            var splits = str.Split(new string[] { textureMark }, StringSplitOptions.None);
            str = string.Empty;

            for (int i = 0; i < splits.Length; ++i)
            {
                if (splits[i].StartsWith("\""))
                {
                    startWithSpace = 2;
                }
                else if (splits[i].StartsWith(" \""))
                {
                    startWithSpace = 3;
                }
                else if (splits[i].StartsWith("  \""))
                {
                    startWithSpace = 4;
                }

                if (startWithSpace != -1)
                {
                    //Search for jpg
                    var jindex = splits[i].IndexOf(".jpg");
                    if (jindex == -1)
                    {
                        jindex = splits[i].IndexOf(".JPG");
                        if (jindex == -1)
                        {
                            //Search for png
                            jindex = splits[i].IndexOf(".png");
                            if (jindex == -1)
                            {
                                jindex = splits[i].IndexOf(".PNG");
                                if (jindex == -1)
                                {
                                    return false;
                                }
                            }
                        }
                    }

                    startIndex = startWithSpace - 1;
                    count = jindex + 4 - startIndex;//4 is for .jpg or .png

                    var diffuseName = splits[i].Substring(startIndex, count);
                    if (!this.diffuseMaps.ContainsKey(meshName))
                    {
                        this.diffuseMaps.Add(meshName, new List<string>() { diffuseName });
                    }
                    else
                    {
                        this.diffuseMaps[meshName].Add(diffuseName);
                    }
                    splits[i] = textureMark + splits[i].Remove(startIndex, count); // jindex - 1 + sizeof(.jpg | .png)
                }
                str += splits[i];
            }
            return true;
        }

        public Dictionary<string, List<string>> ImportModel(string filePath, string Name, bool MergeTextures,
            string Processor, ContentManager Content, ref Model model, ref string HResult)
        {
            HResult = null;
            Dictionary<string, List<string>> resultDic;


            //var oldMode = GCSettings.LatencyMode;
            //RuntimeHelpers.PrepareConstrainedRegions();
            //try
            //{
            //    GCSettings.LatencyMode = GCLatencyMode.LowLatency;

            #region Build

            this.TempFilePath = string.Empty;

            if (MergeTextures && !ArrangeTextures(filePath))
            {
                HResult = "Error on arranging textures, error from content builder";
                return null;
            }

            var BuildOptions = new Dictionary<string, string>()
                {
                    {"ProcessorParameters_Defines", string.Empty},
                    {"ProcessorParameters_DebugMode", "Optimize"},
                };
            //if (Defines.Contains("DUAL_LAYER"))
            //{
            //    BuildOptions.Add("ProcessorParameters_TextureFormat", "Color");
            //}
            Clear();
            Add(MergeTextures ? this.TempFilePath : filePath, Name, null, Processor, BuildOptions);

            //Start Process of Build
            HResult = Build();
            if (HResult != null)
            {
                return null;
            }
            model = Content.Load<Model>(Name);

            //Clean Up temp
            try
            {
                File.Delete(this.TempFilePath);
            }
            catch
            {
                HResult = "Model loaded successfully, but temp still remained";
            }

            resultDic = new Dictionary<string, List<string>>();
            foreach (var key in this.diffuseMaps.Keys)
            {
                var list = new List<string>();
                foreach (var item in this.diffuseMaps[key])
                {
                    list.Add(item);
                }
                resultDic.Add(key, list);
            }

            #endregion
            //}
            //finally
            //{

            //    GCSettings.LatencyMode = oldMode;
            //}

            return resultDic;
        }
        
        public Texture ImportTexture2DFromStream(GraphicsDevice GDevice, string SourceFilePath,
            string DetinationFilePath, ContentManager Content, ref string HResult)
        {
            HResult = null;
            var Name = System.IO.Path.GetFileNameWithoutExtension(SourceFilePath);
            var extention = System.IO.Path.GetExtension(SourceFilePath);

            bool errorCatched = false;
            Texture texture = null;
            using (StreamReader stream = new StreamReader(SourceFilePath))
            {
                texture = Texture2D.FromStream(GDevice, stream.BaseStream);
                if (texture != null)
                {
                    HResult = CutTo(SourceFilePath,
                        string.Format(@"{0}\{1}{2}{3}", Content.RootDirectory, DetinationFilePath, Name, extention));
                    if (HResult != null)
                    {
                        errorCatched = true;
                    }
                }
            };

            return errorCatched ? null : texture;
        }

        public Texture ImportTexture(string SourceFilePath, string DetinationFilePath, ContentManager Content, ref string HResult)
        {
            HResult = null;
            string Name = System.IO.Path.GetFileNameWithoutExtension(SourceFilePath);

            Clear();
            Add(SourceFilePath, Name, null, "TextureProcessor", null);
            HResult = Build();
            if (HResult != null)
            {
                return null;
            }

            HResult = CutTo(string.Format(@"{0}\{1}{2}", Content.RootDirectory, Name, extensionType),
                string.Format(@"{0}\{1}{2}{3}", Content.RootDirectory, DetinationFilePath, Name, extensionType));
            if (HResult != null) return null;

            return Content.Load<Texture>(string.Format(@"{0}\{1}{2}", Content.RootDirectory, DetinationFilePath, Name));
        }

        public void ImportEffect(string SourceFilePath, string DetinationFilePath, 
            string RootContent, string Defines, bool Optimize, ref string HResult)
        {
            HResult = null;
            string Name = System.IO.Path.GetFileNameWithoutExtension(SourceFilePath);

            var BuildParams = new Dictionary<string, string>()
            {
                {"ProcessorParameters_Defines", Defines},
                {"ProcessorParameters_DebugMode", Optimize ? "Optimize" : "Auto"},
            };
            Clear();
            Add(SourceFilePath, Name, null, "EffectProcessor", BuildParams);
            HResult = Build();
            if (HResult != null) return;
        
            HResult = CutTo(string.Format(@"{0}\{1}{2}", RootContent, Name, extensionType),
                string.Format(@"{0}\{1}{2}", RootContent, DetinationFilePath, extensionType));
        }
        
        private string CutTo(string SourceFilePath, string DetinationFilePath)
        {
            string HResult = null;
            try
            {
                string path = DetinationFilePath.Replace(Path.GetExtension(DetinationFilePath), string.Empty);
                path = path.Replace(Path.GetFileNameWithoutExtension(DetinationFilePath), string.Empty);
                HResult = IOHelper.CreateDirectory(path, false);
                if (HResult != null)
                {
                    return HResult;
                }

                if (!string.IsNullOrWhiteSpace(DetinationFilePath))
                {
                    IOHelper.CopyFile(SourceFilePath, DetinationFilePath, false);
                }
            }
            catch (Exception ex)
            {
                HResult = ex.InnerException.ToString();
            }
            return HResult;
        }

        #endregion

        #region Dispose

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!isDisposed)
            {
                isDisposed = true;
                this.errorLogger.Shutdown();
            }
        }


        #endregion
    }
}
