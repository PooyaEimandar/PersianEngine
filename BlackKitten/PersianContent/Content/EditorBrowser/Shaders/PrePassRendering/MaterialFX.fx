/*
* Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
*
* File Name        : MaterialFX.fx
* File Description : Material shader
* Generated by     : Pooya Eimandar
* Last modified by : Pooya Eimandar on 12/28/2013
* Comment          :
*/

#include "Includes\Base.fxh"

struct VSI
{
    float4 Position : POSITION0;
    float2 TexCoord : TEXCOORD0;
    float3 Normal	: NORMAL0;
	float3 Binormal : BINORMAL0;
	float3 Tangent  : TANGENT;
#ifdef SKINNED
    float4 BoneIndices : BLENDINDICES0;
    float4 BoneWeights : BLENDWEIGHT0;
#endif
#ifdef DUAL_LAYER
    float4 Color   : COLOR0;		
#endif
};

struct VSO
{
    float4 Position			: POSITION0;
    float3 TexCoord			: TEXCOORD0;
    float Depth				: TEXCOORD1;
	
    float3 Normal	: TEXCOORD2;
    float3 Tangent	: TEXCOORD3;
    float3 Binormal : TEXCOORD4; 	
	
	//we need this to detect back bacing triangles
#ifdef ALPHA_MASK	
	float Face : VFACE;
#endif
};

VS_OUT VS(VSI IN)
{
	VS_OUT OUT = (VS_OUT) 0;

	matrix WorldView,WorldViewProjection;
	GetMatrices(WorldView, WorldViewProjection);
	
#ifdef SKINNED
	// Blend between the weighted bone matrices.
    float4x4 skinTransform = 0;
    
    skinTransform += Bones[IN.BoneIndices.x] * IN.BoneWeights.x;
    skinTransform += Bones[IN.BoneIndices.y] * IN.BoneWeights.y;
    skinTransform += Bones[IN.BoneIndices.z] * IN.BoneWeights.z;
    skinTransform += Bones[IN.BoneIndices.w] * IN.BoneWeights.w;
	
	float4 skinPos = mul(IN.Position, skinTransform);
	float3 skinNormal = mul(IN.Normal, skinTransform);
	float3 skinTangent = mul(IN.Tangent, skinTransform);
	float3 skinBinormal = mul(IN.Binormal, skinTransform);
	
	float3 viewSpacePos = mul(skinPos, WorldView);
	OUT.Position = mul(skinPos, WorldViewProjection);
	
	OUT.TexCoord.xy = IN.TexCoord.xy;//pass the texture coordinates further
	
	//we output our normals/tangents/binormals in viewspace
	OUT.Normal = mul(skinNormal, WorldView);
	OUT.Tangent = mul(skinTangent, WorldView);
	OUT.Binormal = mul(skinBinormal, WorldView);

#else

	float3 viewSpacePos = mul(IN.Position, WorldView);
	OUT.Position = mul(IN.Position, WorldViewProjection);
	OUT.TexCoord.xy = IN.TexCoord.xy;

	//we output our normals/tangents/binormals in viewspace
	OUT.Normal = normalize(mul(IN.Normal, WorldView));
	OUT.Tangent = normalize(mul(IN.Tangent, WorldView));
	OUT.Binormal = normalize(mul(IN.Binormal, WorldView));
#endif

#ifdef DUAL_LAYER
	OUT.TexCoord.z = IN.Color.r;
#endif
		
	OUT.Depth = viewSpacePos.z; //pass depth
	return OUT;
}

PSO PS(VSO IN)
{
	PSO OUT = (PSO) 0;

	//if we are using alpha mask, we need to read the diffuse map	
#ifdef ALPHA_MASK
	//half4 diffuseMap = tex2D(DiffuseSampler, IN.TexCoord);
	half4 diffuseMap = tex2Dlod(DiffuseSampler, float4(IN.TexCoord, LOD));
	clip(diffuseMap.a - AlphaReference);	
#elif defined(DUAL_LAYER)
	float transition = tex2D(DiffuseSampler, IN.TexCoord).a;
	transition = (1.3f * IN.TexCoord.z - 0.15f) - transition;
	transition = saturate(transition*5);
#endif

	//read from our normal map
	half4 normalMap = tex2D(NormalSampler, IN.TexCoord);
		
#ifdef DUAL_LAYER
	normalMap = normalMap*transition + tex2D(secondNormalMapSampler, IN.TexCoord) * (1 - transition);
#endif

	half3 normalViewSpace = NormalMapToSpaceNormal(normalMap.xyz, IN.Normal, IN.Binormal, IN.Tangent);
    
	//if we are using alpha mask, we need to invert the normal if its a back face
#ifdef ALPHA_MASK	
	normalViewSpace = normalViewSpace * sign(IN.Face);
#endif

	OUT.Normal.rg =  CreateNormal (normalize(normalViewSpace));	//our encoder OUT in RG channels
	OUT.Normal.b = normalMap.a;			//our specular power goes into B channel
	OUT.Normal.a = 1;					//not used
	OUT.Depth.x = -IN.Depth / FarClip;		//Output Depth in linear space, [0..1]

	if (UseGlow)
	{
		float4 pic = tex2D(GlowMapSampler, IN.TexCoord);
		float4 glow = tex2D(GlowMapSampler, IN.TexCoord);
		float offset;
		for (int i = 0; i < 4; i++)
		{
			offset = i * 0.001;
			glow += tex2D(GlowMapSampler, float2(IN.TexCoord.x + offset, IN.TexCoord.y));
			glow += tex2D(GlowMapSampler, float2(IN.TexCoord.x - offset, IN.TexCoord.y));
			glow += tex2D(GlowMapSampler, float2(IN.TexCoord.x, IN.TexCoord.y + offset));
			glow += tex2D(GlowMapSampler, float2(IN.TexCoord.x, IN.TexCoord.y - offset));
		}
		glow = glow / 4;
		glow *= float4(GlowColor, 0);
		OUT.Glow = pic + glow * GlowIntensity;
	}

	return OUT;
}

struct REVSI
{
    float4 Position  : POSITION0;
    float2 TexCoord  : TEXCOORD0;
#ifdef AMBIENT_CUBEMAP
	float3 Normal	 : NORMAL0;
#endif
#ifdef SKINNED
    float4 BoneIndices : BLENDINDICES0;
    float4 BoneWeights : BLENDWEIGHT0;
#endif
#ifdef DUAL_LAYER
    float4 Color   : COLOR0;		
#endif
};

struct REVSO
{
    float4 Position				: POSITION0;
    float3 TexCoord				: TEXCOORD0;
	float4 TexCoordScreenSpace	: TEXCOORD1;
#ifdef AMBIENT_CUBEMAP
	float3 Normal				: TEXCOORD2;
#endif
	float3 L					: TEXCOORD3; // Used for normalized light directional of toon
#ifdef ENVIRONMENT_MAP
	float3 EnvTexCoord			: TEXCOORD4; // used for environment mapping
#endif
};

REVSO REVS(REVSI IN)
{
	REVSO OUT = (REVSO) 0;

	matrix WorldView,WorldViewProjection;
	GetMatrices(WorldView, WorldViewProjection);
	
	float4 pos;
#ifdef SKINNED
	// Blend between the weighted bone matrices.
    float4x4 skinTransform = 0;
    
    skinTransform += Bones[IN.BoneIndices.x] * IN.BoneWeights.x;
    skinTransform += Bones[IN.BoneIndices.y] * IN.BoneWeights.y;
    skinTransform += Bones[IN.BoneIndices.z] * IN.BoneWeights.z;
    skinTransform += Bones[IN.BoneIndices.w] * IN.BoneWeights.w;

	float4 skinPos = mul(IN.Position, skinTransform);
	pos = mul(skinPos, WorldViewProjection);

	#ifdef AMBIENT_CUBEMAP
	float3 skinNormal = mul(IN.Normal, skinTransform);
	OUT.Normal = normalize(mul(skinNormal, WorldView)); //World
	#endif

#else

    pos = mul(IN.Position, WorldViewProjection);

	#ifdef AMBIENT_CUBEMAP
	OUT.Normal = normalize(mul(IN.Normal, WorldView)); //World
	#endif
#endif

	OUT.TexCoord.xy = IN.TexCoord.xy;
	OUT.TexCoordScreenSpace = pos;
	
	OUT.Position = pos;
#ifdef DUAL_LAYER
    OUT.TexCoord.z = IN.Color.r;	
#endif

	OUT.L = normalize(LightDirection);

#ifdef ENVIRONMENT_MAP
	float3 viewSpacePos = mul(IN.Position, WorldView);
	//Reverse of eye vector
	float3 EyeR = -normalize(viewSpacePos);
	float3 Ref = 2 * dot(EyeR, OUT.Normal) * OUT.Normal - EyeR;
	OUT.EnvTexCoord = Ref;
#endif

    return OUT;
}

//Because we want to change it from editor, so let's load it from external file
#include "ReconstructPS.fxh"

struct ShadowVSI
{
    float4 Position : POSITION0;	
	//if we have alpha mask, we need to use the texcoord
#ifdef ALPHA_MASK	
    float2 TexCoord  : TEXCOORD0;
#endif
#ifdef SKINNED
    float4 BoneIndices : BLENDINDICES0;
    float4 BoneWeights : BLENDWEIGHT0;
#endif

};

struct ShadowVSO
{
    float4 Position  : POSITION0;
	float2 Depth     : TEXCOORD0;
#ifdef ALPHA_MASK	
    float2 TexCoord  : TEXCOORD1;
#endif
};

ShadowVSO ShadowVS(ShadowVSI IN)
{
	ShadowVSO output = (ShadowVSO) 0;
	
	matrix WorldView,WorldViewProjection;
	GetMatrices(WorldView, WorldViewProjection);
	
#ifdef SKINNED
	// Blend between the weighted bone matrices.
    float4x4 skinTransform = 0;
    
    skinTransform += Bones[IN.BoneIndices.x] * IN.BoneWeights.x;
    skinTransform += Bones[IN.BoneIndices.y] * IN.BoneWeights.y;
    skinTransform += Bones[IN.BoneIndices.z] * IN.BoneWeights.z;
    skinTransform += Bones[IN.BoneIndices.w] * IN.BoneWeights.w;

	float4 skinPos = mul(IN.Position, skinTransform);
    float4 clipPos = mul(skinPos, mul(World, LightViewProjection));
#else
    float4 clipPos = mul(IN.Position, mul(World, LightViewProjection));
#endif
	//clamp to the near plane
	clipPos.z = max(clipPos.z,0);
	
	output.Position = clipPos;
	output.Depth = output.Position.zw;
	
#ifdef ALPHA_MASK	
    output.TexCoord.xy = IN.TexCoord.xy;
#endif
    return output;
}

float4 ShadowPS(ShadowVSO IN) : COLOR0
{
#ifdef ALPHA_MASK	
	//read our diffuse
	//half4 diffuseMap = tex2D(DiffuseSampler, input.TexCoord);
	half4 diffuseMap = tex2Dlod(DiffuseSampler, float4(IN.TexCoord, 0, LOD));

	clip(diffuseMap.a - AlphaReference);
#endif

	float depth = IN.Depth.x / IN.Depth.y;
    return float4(depth, 1, 1, 1); 
}

technique technique0
{
    pass RenderToGBufferPass
    {
	#ifdef ALPHA_MASK	
		CullMode = None;
	#else
		CullMode = CCW;
	#endif

        VertexShader = compile vs_3_0 VS();
        PixelShader = compile ps_3_0 PS();
    }

	pass ReconstructShadingPass
    {
	#ifdef ALPHA_MASK	
		CullMode = None;
	#else
		CullMode = CCW;
	#endif

        VertexShader = compile vs_3_0 REVS();
		PixelShader = compile ps_3_0 REPS();
    }

	pass OutputShadowPass
	{		
	#ifdef ALPHA_MASK	
		CullMode = None;
	#else
		CullMode = CCW;
	#endif

		VertexShader = compile vs_3_0 ShadowVS();
		PixelShader = compile ps_3_0 ShadowPS();
	}
}

//Use it for sliceing
technique technique1
{
	pass RenderToGBufferSlicePass
	{
		CullMode = None;
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS();
	}

	pass ReconstructShadingSlicePass
	{
		CullMode = None;
		VertexShader = compile vs_3_0 REVS();
		PixelShader = compile ps_3_0 REPS();
	}

	pass OutputShadowSlicePass
	{
		CullMode = None;
		VertexShader = compile vs_3_0 ShadowVS();
		PixelShader = compile ps_3_0 ShadowPS();
	}
}