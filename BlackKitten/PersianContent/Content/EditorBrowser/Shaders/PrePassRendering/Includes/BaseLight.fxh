/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : BaseLight.fxh
 * File Description : The base light header
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 12/28/2013
 * Comment          : 
 */

#ifndef BASELIGHT_FXH
#define BASELIGHT_FXH

#define MAXMATRICES 3
#define LIGHTMAPSCALE 0.1f//the compass is in 0.0 till 10.0f

cbuffer MatricesParams
{
	matrix  WorldViewProjection : WORLDVIEWPROJECTION;
	matrix  CameraWorld;
	matrix	LightViewProjection [MAXMATRICES];
	matrix  SpotLightViewProjection;
	float2	ClipPlanes[MAXMATRICES];
}

cbuffer LightParams
{
	float4 LightColor;
	float3 LightDir;
	float3 LightPosition;
	float  SpotAngle;
	float  InvSpotAngle;
	float  SpotPower;
}

cbuffer ShadowParams
{
	float3 CascadeDistances;
	float2 ShadowMapPixelSize;
	float2 ShadowMapSize;
	bool   UsePCF2X2;
}

cbuffer OtherData
{
	float  FarClip;
	float2 tanAspectRatio;
	float2 PixelSize;
	float  DepthBias;
	float3 FrustumCorners[4];		
	float  InvertLightRadiusSqr;
}

//-----------------------------------------
// Textures
//-----------------------------------------
texture DepthBuffer;
sampler2D depthSampler = sampler_state
{
	Texture = <DepthBuffer>; AddressU = Clamp; AddressV = Clamp; MipFilter = NONE; MagFilter = POINT; MinFilter = POINT;
};
texture NormalMap;
sampler2D NormalSampler = sampler_state
{
	Texture = <NormalMap>; AddressU = Clamp; AddressV = Clamp; MipFilter = NONE; MagFilter = LINEAR; MinFilter = LINEAR; 
};
texture ShadowMap;
sampler ShadowMapSampler = sampler_state
{
    Texture = <ShadowMap>; AddressU = Clamp; AddressV = Clamp; MipFilter = POINT; MagFilter = POINT; MinFilter = POINT;
};
//------------------------
//Structures
//------------------------
struct PS_Out
{
    float4 Diffuse             : COLOR0;
    float4 Specular            : COLOR1;
};

struct VS_IN
{
    float4 Position            : POSITION0;
	float2 TexCoord            : TEXCOORD0;
};

struct VS_Out
{
    float4 Position            : POSITION0;
	float2 TexCoord            : TEXCOORD0;
	float3 FrustumRay          : TEXCOORD1;
};

struct VS_OutMesh
{
    float4 Position            : POSITION0;
	float4 TexCoordScreenSpace : TEXCOORD0;
};
//-----------------------------
//Methods
//-----------------------------
half3 GetNormal (half4 CNormal)
{
	float scale = 1.7777f;
	float3 nn = CNormal.xyz * float3(2 * scale, 2 * scale, 0) + float3(-scale, -scale, 1);
	float g = 2.0 / dot(nn.xyz,nn.xyz);
	float3 normal;
	normal.xy = g * nn.xy;
	normal.z = g-1;
	return normal;
}

float3 GetFrustumRay(in float2 texCoord)
{
	float index = texCoord.x + (texCoord.y * 2);
	return FrustumCorners[index];
}

float2 PostProjectionSpaceToScreenSpace(float4 pos)
{
	float2 screenPos = pos.xy / pos.w;
	return (0.5f * (float2(screenPos.x, -screenPos.y) + 1));
}

float ComputeAttenuation(float3 lDir)
{
	return 1 - saturate(dot(lDir,lDir)*InvertLightRadiusSqr);
}

float ShadowMapLookup(sampler shadowMap, float2 texCoord, float2 offset, float depth)
{
	return (tex2D(shadowMap, texCoord + offset * ShadowMapPixelSize).r + DepthBias < depth) ? 0.0f : 1.0f;
}

float PCF2X2(float nl, float2 UV, float depth)
{
	float samples[4];	

	float shadowOcclusion = 0.0f;    
    shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(0.0f, 0.0f), depth);
    shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(1.0f, 0.0f), depth);  
	  
    shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(0.0f, 1.0f), depth);
    shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(1.0f, 1.0f), depth);   
    
    shadowOcclusion /= 4.0f; 
	return nl * shadowOcclusion;
}

float PCF3X3(float nl, float2 UV, float depth)
{
	float samples[4];	

	float shadowOcclusion = 0.0f;
		
	shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(0.0f, 0.0f), depth);
	shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(1.0f, 0.0f), depth);
	shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(2.0f, 0.0f), depth);
	
	shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(0.0f, 1.0f), depth);
	shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(1.0f, 1.0f), depth);
	shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(2.0f, 1.0f), depth);
	
	shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(0.0f, 2.0f), depth);
    shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(1.0f, 2.0f), depth);
	shadowOcclusion += ShadowMapLookup(ShadowMapSampler, UV, float2(2.0f, 2.0f), depth);
	
	shadowOcclusion /= 9.0f;

	return nl * shadowOcclusion;
}

#endif