/*
* Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
*
* File Name        : Base.fxh
* File Description : The base header
* Generated by     : Pooya Eimandar
* Last modified by : Pooya Eimandar on 12/28/2013
* Comment          :
*/

#ifndef BASE_FXH
#define BASE_FXH

#ifdef SKINNED
#define MAXBONES 61
matrix Bones[MAXBONES];
#endif

#ifdef ALPHA_MASK
float AlphaReference = 1.0f;
#endif

#define AMBIENT_CUBEMAP
#define LightMapScaleConst 10.0f

cbuffer Params 
{
	matrix	World				: WORLD			: packoffset(c0);
	matrix	View				: VIEW			: packoffset(c4);
	matrix	Projection			: PROJECTION	: packoffset(c8);
	matrix	LightViewProjection					: packoffset(c12);
	float	FarClip								: packoffset(c13.w);
	float2	LightMapSize						: packoffset(c13.xy);
	float4	AmbientColor						: packoffset(c14);
	float	GlowIntensity						: packoffset(c13.z);
	float	LOD									: packoffset(c15.w);
	float3	LightDirection						: packoffset(c15.xyz);
	bool	UseToon								: packoffset(c16.w);
	float3  GlowColor							: packoffset(c16.xyz);
	bool    UseGlow								: packoffset(c17.w);
	float	Reflectivity						: packoffset(c17.x);
}

texture DiffuseMap;
sampler DiffuseSampler = sampler_state
{
	Texture = (DiffuseMap);	MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = LINEAR;
	AddressU = Wrap;
	AddressV = Wrap;
};

texture NormalMap;
sampler NormalSampler = sampler_state
{
	Texture = (NormalMap); MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = LINEAR;
	AddressU = Wrap;
	AddressV = Wrap;
};

texture SpecularMap;
sampler SpecularSampler = sampler_state
{
	Texture = (SpecularMap); MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = LINEAR;
	AddressU = Wrap;
	AddressV = Wrap;
};

texture EmissiveMap;
sampler EmissiveSampler = sampler_state
{
	Texture = (EmissiveMap); MAGFILTER = LINEAR; MINFILTER = LINEAR; MIPFILTER = LINEAR;
	AddressU = Wrap;
	AddressV = Wrap;
};

texture LightMap;
sampler2D LightSampler = sampler_state
{
	Texture = <LightMap>; MipFilter = POINT; MagFilter = POINT; MinFilter = POINT;
	AddressU = Clamp;
	AddressV = Clamp;
};

texture LightSpecularMap;
sampler2D LightSpecularSampler = sampler_state
{
	Texture = <LightSpecularMap>; MipFilter = NONE; MagFilter = POINT; MinFilter = POINT;
	AddressU = Clamp;
	AddressV = Clamp;
};

#ifdef AMBIENT_CUBEMAP

texture AmbientCubeMap;
samplerCUBE AmbientCubemapSampler = sampler_state
{
	Texture = <AmbientCubeMap>; MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = LINEAR;
	AddressU = WRAP;
	AddressV = WRAP;
};

#endif

texture ToonMap;
sampler2D ToonMapSampler = sampler_state
{
	Texture = <ToonMap>; MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = LINEAR;
	AddressU = WRAP;
	AddressV = WRAP;
};

texture GlowMap;
sampler2D GlowMapSampler = sampler_state
{
	Texture = <GlowMap>; MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = LINEAR;
	AddressU = WRAP;
	AddressV = WRAP;
};

#ifdef ENVIRONMENT_MAP

texture EnvironmentMap;
samplerCUBE EnvironmentSampler = sampler_state 
{ 
    texture = <EnvironmentMap>; MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = LINEAR;   
	AddressU = WRAP;
	AddressV = WRAP; 
};

#endif

//-------------------------------
// Shared Structs
//-------------------------------
struct VS_OUT
{
    float4 Position		: POSITION0;
    float3 TexCoord		: TEXCOORD0;
    float  Depth		: TEXCOORD1;
    float3 Normal	    : TEXCOORD2;
    float3 Tangent	    : TEXCOORD3;
    float3 Binormal     : TEXCOORD4; 
};
struct PSO
{
    float4 Normal : COLOR0;
    float4 Depth  : COLOR1;
	float4 Glow   : COLOR2;
};
struct FinalVS_OUT
{
    float4 Position			   : POSITION0;
    float3 TexCoord			   : TEXCOORD0;
	float4 TexCoordScreenSpace : TEXCOORD1;
	float3 Normal	           : TEXCOORD2;
};
//-------------------------------
// Shared Methods
//-------------------------------
void GetMatrices(inout matrix WorldView, inout matrix WorldViewProjection)
{
	WorldView = mul(World , View);
	WorldViewProjection = mul(WorldView, Projection);
}

half2 CreateNormal (in half3 Normal3)
{
	//Store Normal3 into Normal2...The Scale is 1.7777f
	return ( (Normal3.xy / (Normal3.z + 1)) / 1.7777f ) * 0.5f + 0.5f;
}

PSO GenerateOutput(in half3 NormalViewSpace, in half Specular, in float Depth)
{
	PSO output =(PSO)0;
	//in R and G chnnels we must store our normal 
	output.Normal.rg =  CreateNormal(normalize(NormalViewSpace));
	//in b channels we store out sepcular
	output.Normal.b = Specular;

	//the depth must be in compass of 0 till 1
	output.Depth.x = Depth;
	return output;
}

float2 PostProjectionSpaceToScreenSpace(in float4 Position)
{
	float2 ScreenPosition = Position.xy / Position.w;
	return (0.5f * (float2(ScreenPosition.x, -ScreenPosition.y) + 1));
}

half3 NormalMapToSpaceNormal(in half3 NormalMap, in float3 Normal, in float3 Binormal, in float3 Tangent)
{
	NormalMap = NormalMap * 2 - 1;
	NormalMap = half3(Normal * NormalMap.z + NormalMap.x * Tangent - NormalMap.y * Binormal);
	return NormalMap;
}

float4 GetFinalColor(in FinalVS_OUT input, in float2 screenPos, in half4 diffuseMap)
{
	half3 _emissiveMap = tex2D(EmissiveSampler, input.TexCoord).rgb;
	half3 _specularMap = tex2D(SpecularSampler, input.TexCoord).rgb;
	float4 lightColor =  tex2D(LightSampler, screenPos) * LightMapScaleConst;
	float4 specular =  tex2D(LightSpecularSampler, screenPos) * LightMapScaleConst;

	float4 finalColor = float4(diffuseMap * lightColor.rgb + specular * _specularMap + _emissiveMap + diffuseMap * AmbientColor.rgb, 1);
	half3 ambientCubemapColor = texCUBE(AmbientCubemapSampler, input.Normal);
	finalColor.rgb += AmbientColor.rgb * ambientCubemapColor.rgb * diffuseMap.rgb;
	return finalColor; 
}

#endif