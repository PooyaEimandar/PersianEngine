/*
* Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
*
* File Name        : DirectionalLight.fx
* File Description : Directionl light buffer
* Generated by     : Pooya Eimandar
* Last modified by : Pooya Eimandar on 12/28/2013
* Comment          :
*/

#include "..\Shared.fxh"
#include "Buffers.fxh"

cbuffer cbDirLight : register(b1)
{
	float3 AmbientDown	 : packoffset(c0);
	float3 AmbientUp	 : packoffset(c1);
	float  Intensity	 : packoffset(c1.w);
	float3 Direction	 : packoffset(c2);
	float4 Color		 : packoffset(c3);
};

texture ShadowMap;
sampler ShadowMapSampler = sampler_state
{
	Texture = <ShadowMap>; MinFilter = Point; MagFilter = Point; MipFilter = None; AddressU = Clamp; AddressV = Clamp;
};

struct VSI
{
	float4 Position			: POSITION0;
	float2 UV				: TEXCOORD0;
};

struct VSO
{
	float4 Position			: SV_Position;
	float2 UV   			: TEXCOORD0;
	float3 FrustumRay		: TEXCOORD1;
};

VSO VS(VSI IN)
{
	VSO OUT = (VSO) 0;

	//Used for light
	OUT.Position = IN.Position;
	//align texture coordinates
	OUT.UV = IN.UV - HalfScreenSize;
	// Set FrustumRay with FrustumCorners
	OUT.FrustumRay = GetFrustumRay(IN.UV);

	return OUT;
}

float3 CalcAmbient(float3 normal, float3 color)
{
	// Convert from [-1, 1] to [0, 1]
	float up = normal.y * 0.5 + 0.5;

	// Calculate the ambient value
	float3 ambient = AmbientDown + up * AmbientUp;

	// Apply the ambient value to the color
	return ambient * color;
}


float ComputeShadow4Samples(float nl, float2 shadowTexCoord, float ourdepth)
{
	float samples[4];
	samples[0] = tex2D(ShadowMapSampler, shadowTexCoord).r < ourdepth ? 0 : 1;
	samples[1] = tex2D(ShadowMapSampler, shadowTexCoord + float2(0, 2)* HalfScreenSize).r < ourdepth ? 0 : 1;
	samples[2] = tex2D(ShadowMapSampler, shadowTexCoord + float2(2, 0)* HalfScreenSize).r < ourdepth ? 0 : 1;
	samples[3] = tex2D(ShadowMapSampler, shadowTexCoord + float2(2, 2)* HalfScreenSize).r < ourdepth ? 0 : 1;
	float2 lerps = frac(shadowTexCoord * ShadowMapSize);
	half shadow = lerp(lerp(samples[0], samples[1], lerps.y), lerp(samples[2], samples[3], lerps.y), lerps.x);
	return nl*shadow;
}

float4 PS(VSO IN) : SV_TARGET
{
	// Unpack the GBuffer

	//Read depth
	float depth = tex2D(DepthSampler, IN.UV).r;
	//clip(-depthValue + 0.9999f);

	Material material = GetMaterialFromGBuffer(IN.UV);

	// Reconstruct the world position
	//compute screen-space position
	float4 position;
	position.x = IN.UV.x * 2.0f - 1.0f;
	position.y = -(IN.UV.x * 2.0f - 1.0f);
	position.z = depth;
	position.w = 1.0f;
	//transform to world space
	position = mul(position, InverseViewProj);
	position /= position.w;

	//Calculate phong
	// Phong diffuse   
	float NDotL = dot(Direction, material.Normal);

	float3 weights = (position.z < CascadeDistances);
	weights.xy -= weights.yz;

	matrix lightViewProj = LightViewProj[0] * weights.x + LightViewProj[1] * weights.y + LightViewProj[2] * weights.z;
	float fOffset = weights.y * 0.33333f + weights.z * 0.666666f;
	float4 lightingPosition = mul(mul(position, CameraWorld), lightViewProj);

	float2 shadowTexCoord = 0.5 * lightingPosition.xy / lightingPosition.w + float2(0.5, 0.5);
	shadowTexCoord.x = shadowTexCoord.x * 0.3333333f + fOffset;
	shadowTexCoord.y = shadowTexCoord.y;
	shadowTexCoord -= HalfScreenSize;
	float ourdepth = (lightingPosition.z / lightingPosition.w) - DepthBias;
	float shadowSkip = ClipPlanes[2].y > position.z;
	NDotL *= shadowSkip + ComputeShadow4Samples(NDotL, shadowTexCoord, ourdepth) * (1 - shadowSkip);


	float3 finalColor = CalcAmbient(material.Normal, material.Color) + Color.rgb * saturate(NDotL);
	// Blinn specular   
	float3 ToEye = EyePosition.xyz - position;
	ToEye = normalize(ToEye);
	float3 HalfWay = normalize(ToEye + Direction);
	float NDotH = saturate(dot(HalfWay, material.Normal));

	float specular = material.SpecIntensity * pow(NDotH, material.SpecPower);
	return Intensity * float4(finalColor * material.Color.rgb, specular * 0.5f);
}

technique technique0
{
	pass pass0
	{
		VertexShader = compile vs_3_0 VS();
		PixelShader = compile ps_3_0 PS();
	}
}