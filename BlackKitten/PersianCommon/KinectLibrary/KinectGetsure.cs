/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : KinectGetsure.cs
 * File Description : The getsure of kinect
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 8/17/2013
 * Comment          : 
 */

using Microsoft.Kinect;
using Microsoft.Samples.Kinect.SwipeGestureRecognizer;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace KinectLibrary
{
    public static class KinectGetsure
    {
        #region Fields & Properties

        static Recognizer recognizer;
        static Skeleton[] skeletonData;
        static KinectSensorChooser chooser;

        public static KinectSensorChooser SensorChooser
        {
            get
            {
                return chooser;
            }
        }

        static Vector2[] RightHandHistory, LeftHandHistory, CenterHistory;
        static Vector3[] RightHand3DHistory;

        public static Vector2 ScreenSize;

        public static bool KinectIsAvailable { get; private set; }
        public static JointCollection _3DJoints { get; private set; }
        public static Vector3? RightHand3D
        {
            get
            {
                if (_3DJoints != null)
                {
                    var jointType = JointType.HandRight;
                    var joint = _3DJoints[jointType].Position;
                    if (_3DJoints[jointType].TrackingState == JointTrackingState.Tracked)
                    {
                        return new Vector3(joint.X, joint.Y, joint.Z);
                    }
                }
                return null;
            }
        }
        public static Vector3? LeftHand3D
        {
            get
            {
                if (_3DJoints != null)
                {
                    var jointType = JointType.HandLeft;
                    var joint = _3DJoints[jointType].Position;
                    if (_3DJoints[jointType].TrackingState == JointTrackingState.Tracked)
                    {
                        return new Vector3(joint.X, joint.Y, joint.Z);
                    }
                }
                return null;
            }
        }
        public static Vector3? Center3D
        {
            get
            {
                if (_3DJoints != null)
                {
                    var jointType = JointType.HipCenter;
                    var joint = _3DJoints[jointType].Position;
                    return new Vector3(joint.X, joint.Y, joint.Z);
                }
                return null;
            }
        }
        public static Vector2? LeftHand2D
        {
            get
            {
                if (_3DJoints != null)
                {
                    var jointType = JointType.HandLeft;
                    var joint = _3DJoints[jointType].Position;
                    if (_3DJoints[jointType].TrackingState == JointTrackingState.Tracked)
                    {
                        return SkeletonToColorMap(joint, true);
                    }
                }
                return null;
            }
        }
        public static Vector2? RightHand2D
        {
            get
            {
                if (_3DJoints != null)
                {
                    var jointType = JointType.HandRight;
                    var joint = _3DJoints[jointType].Position;
                    if (_3DJoints[jointType].TrackingState == JointTrackingState.Tracked)
                    {
                        return SkeletonToColorMap(joint, true);
                    }
                }
                return null;
            }
        }
        public static Vector2? Center2D
        {
            get
            {
                if (_3DJoints != null)
                {
                    var jointType = JointType.HipCenter;
                    var joint = _3DJoints[jointType].Position;
                    if (_3DJoints[jointType].TrackingState == JointTrackingState.Tracked)
                    {
                        return SkeletonToColorMap(joint, true);
                    }
                }
                return null;
            }
        }

        public static Dictionary<string, bool> Events;

        #endregion

        #region Constructor/Destructor

        static KinectGetsure()
        {
            chooser = new KinectSensorChooser();
            RightHandHistory = new Vector2[5];
            LeftHandHistory = new Vector2[5];
            CenterHistory = new Vector2[5];
            RightHand3DHistory = new Vector3[5];

            Events = new Dictionary<string, bool>()
            {
                { "RightHandPushed" , false },
                { "RightHandUp" , false },
                { "RightHandSlide" , false },
                { "LeftHandSlide" , false },
                { "LeftHandUp" , false },
                { "CenterToRight" , false },
                { "CenterToLeft" , false },  
                { "CenterToUp" , false },
                { "CenterToDown" , false },    
            };

            recognizer = new Recognizer();
            recognizer.SwipeRightDetected += (s, e) =>
                {
                    Events["RightHandSlide"] = true;
                };
            recognizer.SwipeLeftDetected += (s, e) =>
            {
                Events["LeftHandSlide"] = true;
            };
        }

        #endregion

        #region Events

        /// <summary>
        /// This method ensures that we can render to the back buffer without
        /// losing the data we already had in our previous back buffer.  This
        /// is necessary for the SkeletonStreamRenderer.
        /// </summary>
        /// <param name="sender">The sending object.</param>
        /// <param name="e">The event args.</param>
        public static void OnGraphicsDevicePreparingDeviceSettings(object sender, PreparingDeviceSettingsEventArgs e)
        {
            // This is necessary because we are rendering to back buffer/render targets and we need to preserve the data
            e.GraphicsDeviceInformation.PresentationParameters.RenderTargetUsage = RenderTargetUsage.PreserveContents;
        }

        #endregion

        #region Update

        public static void GetState()
        {
            KinectIsAvailable = true;
            // If the sensor is not found, not running, or not connected, stop now
            if (chooser.Sensor == null || chooser.Sensor.IsRunning == false || chooser.Sensor.Status != KinectStatus.Connected)
            {
                KinectIsAvailable = false;
                return;
            }
            using (var skeletonFrame = chooser.Sensor.SkeletonStream.OpenNextFrame(0))
            {
                // Sometimes we get a null frame back if no data is ready
                if (null == skeletonFrame)
                {
                    return;
                }
                // Reallocate if necessary
                if (null == skeletonData || skeletonData.Length != skeletonFrame.SkeletonArrayLength)
                {
                    skeletonData = new Skeleton[skeletonFrame.SkeletonArrayLength];
                }
                skeletonFrame.CopySkeletonDataTo(skeletonData);

                foreach (var skeleton in skeletonData)
                {
                    //Todo : Trace with the first trackID
                    System.Diagnostics.Debug.WriteLine(skeleton.TrackingId);
                    if (skeleton.TrackingState == SkeletonTrackingState.Tracked)
                    {
                        _3DJoints = skeleton.Joints;
                        //Check4Events(skeleton);
                    }
                }

                recognizer.Recognize(null, skeletonFrame, skeletonData);
            }
        }

        #endregion

        #region Methods

        private static void Check4Events(Skeleton skeleton)
        {
            ClearEvents();

            if (RightHand2D.HasValue &&  LeftHand2D.HasValue && Center2D.HasValue)
            {
                var rightHand3D = RightHand3D.Value;
                var rightHand2D = RightHand2D.Value;
                var leftHand2D = LeftHand2D.Value;
                var center = Center2D.Value;

                int i = RightHandHistory.Length - 1;
                while (i >= 1)
                {
                    RightHandHistory[i] = RightHandHistory[i - 1];
                    RightHand3DHistory[i] = RightHand3DHistory[i - 1];
                    LeftHandHistory[i] = LeftHandHistory[i - 1];
                    CenterHistory[i] = CenterHistory[i - 1];
                    i--;
                }

                RightHand3DHistory[0] = rightHand3D;
                RightHandHistory[0] = rightHand2D;
                LeftHandHistory[0] = leftHand2D;
                CenterHistory[0] = center;


                #region Hand

                if ((RightHand3DHistory[2].Z > RightHand3DHistory[0].Z) && (RightHand3DHistory[2].Z - RightHand3DHistory[0].Z) > 0.1f)
                {
                    Events["RightHandPushed"] = true;
                }
                if ((RightHandHistory[0].Y < RightHandHistory[4].Y) && (RightHandHistory[0].Y - RightHandHistory[4].Y) < -70)
                {
                    Events["RightHandUp"] = true;
                }

                if ((LeftHandHistory[0].Y < LeftHandHistory[4].Y) && (LeftHandHistory[0].Y - LeftHandHistory[4].Y) < -70)
                {
                    Events["LeftHandUp"] = true;
                }
     
                #endregion

                #region Center

                if ((CenterHistory[0].X > CenterHistory[4].X) && (CenterHistory[0].X - CenterHistory[4].X) > 50)
                {
                    Events["CenterToRight"] = true;
                }
                else if ((CenterHistory[0].X < CenterHistory[4].X) && (CenterHistory[0].X - CenterHistory[4].X) < -50)
                {
                    Events["CenterToLeft"] = true;
                }

                if ((CenterHistory[0].Y > CenterHistory[4].Y) && (CenterHistory[0].Y - CenterHistory[4].Y) > 50)
                {
                    Events["CenterToDown"] = true;
                }
                else if ((CenterHistory[0].Y < CenterHistory[4].Y) && (CenterHistory[0].Y - CenterHistory[4].Y) < -50)
                {
                    Events["CenterToUp"] = true;
                }

                #endregion
            }
        }

        private static void ClearEvents()
        {
            Events["RightHandPushed"] = Events["RightHandUp"] = Events["LeftHandSlide"] =
                Events["RightHandSlide"] = Events["LeftHandUp"] = Events["CenterToRight"] =
                Events["CenterToLeft"] = Events["CenterToUp"] = Events["CenterToDown"] = false;
        }

        private static Vector2 SkeletonToColorMap(SkeletonPoint point, bool FixToScreenSize)
        {
            if ((null != chooser.Sensor) && (null != chooser.Sensor.ColorStream))
            {
                // This is used to map a skeleton point to the color image location
                var colorPt = chooser.Sensor.MapSkeletonPointToColor(point, chooser.Sensor.ColorStream.Format);
                var Result =  new Vector2(colorPt.X, colorPt.Y);
                if (FixToScreenSize)
                {
                    Result.X = ((Result.X * ScreenSize.X) / 315f) - (ScreenSize.X / 2);
                    Result.Y = ((Result.Y * ScreenSize.Y) / 315f) - (ScreenSize.Y / 3.3f);
                }
                return Result;
            }

            return Vector2.Zero;
        }

        #endregion

        #region Dispose

        public static void Dispose()
        {
            chooser.Dispose();
            Events.Clear();
        }

        #endregion
    }
}
