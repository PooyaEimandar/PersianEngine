/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : AnimationPlayer.cs
 * File Description : The animation mixer
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 10/13/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using System.Collections.Generic;
using System.Linq;

namespace SkinnedMeshRuntime
{
    public class AnimationMixer
    {
        #region Fields & Properties

        int trackindex;
        SkinningData skinningData;
        List<AnimationPlayer> MixerTracks;
        public Dictionary<int, int> BonesInherit;
        public List<string> Tracks;
        public List<bool> TracksInverese;
        public Matrix[] SkinTransforms
        {
            get
            {
                if (this.MixerTracks.Count == 0)
                {
                    return new Matrix[] { Matrix.Identity };
                }
                //return base track
                return this.MixerTracks[0].SkinTransforms;
            }
        }
        public bool IsNotVisible
        {
            get
            {
                if (this.MixerTracks.Count > 0)
                {
                    return this.MixerTracks[0].IsNotVisible;
                }
                return false;
            }
            set
            {
                if (this.MixerTracks.Count > 0)
                {
                    this.MixerTracks[0].IsNotVisible = value;
                }
            }
        }

        public AnimationPlayer Player 
        {
            get
            {
                if (this.MixerTracks.Count != 0)
                {
                    return this.MixerTracks[0];
                }
                return null;
            }
        }

        /// <summary>
        /// Delta time means between starting each animation
        /// 0, 1500 means, start first animation from zero, then start next animation after just in 1500th frame of animation 1
        /// Note : This will only use on Parallel mode of animation mixer Type(mixerType = 0)
        /// </summary>
        public List<long> DeltaBetweenFrames { get; set; }

        public enum MixType : byte 
        { 
            Parallel = 0, Sequential, SequentialLoopOnEnd 
        }

        /// <summary>
        /// True means Sequential mixing, false means Parallel mixing
        /// In sequential mixing, each animation track continues after previous animation track
        /// In parallel mixing, both animation update and bone behavioral inherits from them 
        /// </summary>
        public MixType mixType;
        public string Name { get; set; }

        //TODO : Need local animationSpeed on loading?
        public float AnimationSpeed 
        {
            get
            {
                return MixerTracks.Count > 0 ? this.MixerTracks[0].CurrentClip.AnimationSpeed : 0;
            }
            set
            {
                if (MixerTracks.Count > 0)
                {
                    this.MixerTracks[0].CurrentClip.AnimationSpeed = value;
                }
            }
        }

        long defaultBlendValue;
        List<long> blendValues;
        public List<long> BlendValue
        {
            get
            {
                return blendValues;
            }
            set
            {
                this.blendValues = value;
            }
        }

        #endregion

        #region Constructor

        public AnimationMixer(SkinningData skinningData)
        {
            this.defaultBlendValue = 7000;
            this.trackindex = -1;//Start first animation at index 1 after plusing
            this.mixType = MixType.Parallel;
            this.MixerTracks = new List<AnimationPlayer>();
            this.BonesInherit = new Dictionary<int, int>();
            this.skinningData = skinningData;
        }

        #endregion

        #region Methods

        public void Add(List<string> Tracks, List<bool> TracksInverese, 
            List<float> AnimationSpeeds, List<long> BlendValues, List<long> DeltaBetweenFrames)
        {
            this.Tracks = Tracks;
            this.TracksInverese = TracksInverese;
            this.DeltaBetweenFrames = DeltaBetweenFrames;
            this.blendValues = BlendValues;
            for (int i = 0; i < this.Tracks.Count; i++)
            {
                bool IsLoopable = false;
                //Loop is allowable just for Parallel mode and last track of sequentialLoop
                if (this.mixType == MixType.Parallel ||
                    i == this.Tracks.Count - 1 && this.mixType == MixType.SequentialLoopOnEnd)
                {
                    IsLoopable = true;
                }
                var track = this.Tracks[i];
                var isInReverse = TracksInverese[i];
                var t = new AnimationPlayer(skinningData, true, true)
                {
                    IsPaused = DeltaBetweenFrames.Count == 0 || DeltaBetweenFrames[i] == 0 ? false : true,
                    IsLoopable = IsLoopable,
                    IsInReverse = isInReverse,
                    IsNotVisible = false,
                };
                t.OnComplete += AnimationPlayerOnComplete;
                this.MixerTracks.Add(t);

                var clip = this.skinningData.GetAnimationClipByName(track);
                if (AnimationSpeeds != null && i < AnimationSpeeds.Count)
                {
                    clip.AnimationSpeed = AnimationSpeeds[i];
                }

                this.MixerTracks[this.MixerTracks.Count - 1].StartClip(
                    clip, 
                    this.blendValues == null || this.blendValues.Count == 0 ? this.defaultBlendValue : this.blendValues[i]);
            }
            AnimationPlayerOnComplete(null, null);
        }

        public void RemoveTrack(string TrackName)
        {
            var Q = from q in this.MixerTracks.AsParallel()
                    where q.CurrentClip.Name == TrackName
                    select q;

            List<AnimationPlayer> Result = Q.ToList();
            if (Result.Count > 0)
            {
                this.MixerTracks.Remove(Result[0]);
                this.Tracks.Remove(TrackName);
            }
        }

        //public void ChangeTrackTo(int index, string AnimationName, float AnimationSpeed, bool isLoopable, long BlendValue)
        //{
        //    this.Tracks[index] = AnimationName;
        //    this.MixerTracks[index].IsLoopable = isLoopable;
        //    var Clip = this.skinningData.GetAnimationClipByName(AnimationName);
        //    Clip.AnimationSpeed = AnimationSpeed;
        //    this.MixerTracks[index].BlendToClip(Clip, BlendValue);
        //}

        public void AddedTransformState(bool State, int Index)
        {
            if (this.MixerTracks.Count > 0)
            {
                this.MixerTracks[0].AddedTransformState(State, Index);
            }
        }

        public void SetAddedTransform(ref Matrix WorldTrans, int Index)
        {
            if (this.MixerTracks.Count > 0)
            {
                this.MixerTracks[0].SetAddedTransform(ref WorldTrans, Index);
            }
        }

        public bool GetWorldSpaceTransform(ref Matrix boneWorld, int Index)
        {
            if (this.MixerTracks.Count > 0)
            {
                return this.MixerTracks[0].GetWorldSpaceTransform(ref boneWorld, Index);
            }
            return false;
        }

        public void DisableTPos()
        {
            if (this.MixerTracks.Count > 0)
            {
                this.MixerTracks[0].DisableTPos();
            }
        }

        public void EnableTPos()
        {
            if (this.MixerTracks.Count > 0)
            {
                this.MixerTracks[0].EnableTPos(skinningData);
            }
        }

        public void Reset()
        {
            this.trackindex = -1;
            for (int i = 0; i < this.MixerTracks.Count; ++i)
            {
                this.MixerTracks[i].IsPaused = this.DeltaBetweenFrames.Count == 0 || this.DeltaBetweenFrames[i] == 0 ? false : true;
              //  this.MixerTracks[i].BlendToClip(this.MixerTracks[i].CurrentClip, 0, 0);
                this.MixerTracks[i].StartClip(this.MixerTracks[i].CurrentClip, this.blendValues == null || this.blendValues.Count == 0 ? this.defaultBlendValue : this.blendValues[i]);
            }
        }

        public void ResetAndPause()
        {
            this.trackindex = -1;
            for (int i = 0; i < this.MixerTracks.Count; ++i)
            {
                this.MixerTracks[i].StartClip(this.MixerTracks[i].CurrentClip, this.blendValues == null || this.blendValues.Count == 0 ? this.defaultBlendValue : this.blendValues[i]);
                this.MixerTracks[i].IsPaused = true;
            }
        }

        #endregion

        #region Events

        bool ApplyChange = false;
        void AnimationPlayerOnComplete(object sender, System.EventArgs e)
        {
            if (this.mixType == MixType.Parallel) return;
            if (this.trackindex == this.MixerTracks.Count - 1 && this.mixType == MixType.SequentialLoopOnEnd) return;

            this.ApplyChange = true;
        }

        #endregion

        #region Update

        public void Update(float Time)
        {
            var BonesTransform = new List<Matrix[]>();

            if (this.mixType == MixType.Parallel)
            {
                Time /= this.MixerTracks[0].CurrentClip.AnimationSpeed;

                if (this.MixerTracks[0].CurrentTimeInTheAnimationInTicks / 1000.000f >= this.DeltaBetweenFrames[1])
                {
                    this.MixerTracks[1].IsPaused = false;
                }

                foreach (var mixTrack in this.MixerTracks)
                {
                    var bt = mixTrack.UpdateStep1(Time);
                    BonesTransform.Add(bt);
                }

                if (BonesTransform[0] != null)
                {
                    if (BonesInherit != null && BonesInherit.Count > 0)
                    {
                        for (int i = 0; i < BonesInherit.Count; i++)
                        {
                            var i0 = BonesInherit.ElementAt(i).Value;

                            if (BonesTransform[i0] != null)
                            {
                                var j0 = BonesInherit.ElementAt(i).Key;
                                BonesTransform[0][BonesInherit.ElementAt(i).Key] = BonesTransform[i0][j0];
                            }
                        }
                    }

                    //Edit first track
                    this.MixerTracks[0].UpdateStep2(Time, BonesTransform[0]);
                }
            }
            else
            {
                if (this.ApplyChange)
                {
                    this.ApplyChange = false;
                    bool IsLoopable = false;
                    //Loop is allow on final track of SequentialLoopOnEnd mode
                    this.trackindex = (this.trackindex + 1) % this.MixerTracks.Count;
                    if (this.trackindex == this.Tracks.Count - 1 && this.mixType == MixType.SequentialLoopOnEnd)
                    {
                        IsLoopable = true;
                    }
                    var clip = this.skinningData.GetAnimationClipByName(this.Tracks[this.trackindex]);
                    clip.AnimationSpeed = this.AnimationSpeed;
                    this.MixerTracks[0].IsLoopable = IsLoopable;
                    this.MixerTracks[0].IsInReverse = this.TracksInverese[this.trackindex];
                    this.MixerTracks[0].StartClip(clip,
                        this.blendValues == null || this.blendValues.Count == 0 ? this.defaultBlendValue : this.blendValues[this.trackindex]);
                }
                this.MixerTracks[0].Update(Time);
            }
        }

        #endregion
    }
}
