/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : Bounding.cs
 * File Description : Represents statics methods for bounding boxes
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 8/27/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Graphics.VertexType;
using System;
using System.Collections.Generic;

namespace PersianCore
{
    public static class Bounding
    {
        #region Fields

        static  VertexBuffer VBuffer;
        static  IndexBuffer IBuffer;

        #endregion

        #region Methods

        public static BoundingBox GetBoundingBox(Model mesh)
        {
            Matrix[] boneTransforms = new Matrix[mesh.Bones.Count];
            mesh.CopyAbsoluteBoneTransformsTo(boneTransforms);

            var min = new Vector3();
            var max = new Vector3();

            var vertexStride = mesh.Meshes[0].MeshParts[0].VertexBuffer.VertexDeclaration.VertexStride;

            foreach (var modelMesh in mesh.Meshes)
            {
                foreach (var part in modelMesh.MeshParts)
                {
                    if (vertexStride == 56)
                    {
                        //Pos, Texcoord, Normal, Tangent and Bionormal
                        var vertices = new VertexMesh[part.VertexBuffer.VertexCount];
                        part.VertexBuffer.GetData<VertexMesh>(vertices);

                        // Find min, max
                        min = vertices[0].Position;
                        max = vertices[0].Position;

                        for (int i = 1; i < vertices.Length; i++)
                        {
                            min = Vector3.Min(min, vertices[i].Position);
                            max = Vector3.Max(max, vertices[i].Position);
                        }
                    }
                    else
                    {
                        var vertices = new VertexPositionNormalTexture[part.VertexBuffer.VertexCount];
                        part.VertexBuffer.GetData<VertexPositionNormalTexture>(vertices);

                        // Find min, max
                        min = vertices[0].Position;
                        max = vertices[0].Position;

                        for (int i = 1; i < vertices.Length; i++)
                        {
                            min = Vector3.Min(min, vertices[i].Position);
                            max = Vector3.Max(max, vertices[i].Position);
                        }
                    }
                    
                    // We need to take into account the fact that the mesh may have a bone transform
                    min = Vector3.Transform(min, boneTransforms[modelMesh.ParentBone.Index]);
                    max = Vector3.Transform(max, boneTransforms[modelMesh.ParentBone.Index]);
                }
            }

            return new BoundingBox(min, max);
        }

        public static BoundingSphere GetBoundingSphere(Model mesh)
        {
            BoundingSphere BSphere = new BoundingSphere();

            Matrix[] modelTransforms = new Matrix[mesh.Bones.Count];
            mesh.CopyAbsoluteBoneTransformsTo(modelTransforms);

            foreach (ModelMesh modelMesh in mesh.Meshes)
            {
                BoundingSphere origMeshSphere = modelMesh.BoundingSphere;
                BoundingSphere transMeshSphere = TransformBoundingSphere(origMeshSphere, modelTransforms[modelMesh.ParentBone.Index]);
                BSphere =BoundingSphere.CreateMerged(BSphere, transMeshSphere);
            }

            return BSphere;
        }

        public static List<BoundingSphere> GetBoundingSpheres(Model mesh)
        {
            List<BoundingSphere> BoundingSpheres = new List<BoundingSphere>();

            Matrix[] modelTransforms = new Matrix[mesh.Bones.Count];
            mesh.CopyAbsoluteBoneTransformsTo(modelTransforms);
            
            foreach (ModelMesh modelMesh in mesh.Meshes)
            {
                BoundingSphere origMeshSphere = modelMesh.BoundingSphere;
                BoundingSphere transMeshSphere = TransformBoundingSphere(origMeshSphere, modelTransforms[modelMesh.ParentBone.Index]);
            }

            return BoundingSpheres;
        }

        public static void TransformBoundingBox(ref BoundingBox OriginalBox, ref Matrix Transform, out BoundingBox Destination)
        {
            Vector3 center, extents, rotatedExtents = Vector3.Zero;

            center = (OriginalBox.Min + OriginalBox.Max) * 0.5f;
            extents = OriginalBox.Max - center;

            rotatedExtents.X = Math.Abs(extents.X * Transform.Right.X) + Math.Abs(extents.Y * Transform.Up.X) + Math.Abs(extents.Z * Transform.Forward.X);
            rotatedExtents.Y = Math.Abs(extents.X * Transform.Right.Y) + Math.Abs(extents.Y * Transform.Up.Y) + Math.Abs(extents.Z * Transform.Forward.Y);
            rotatedExtents.Z = Math.Abs(extents.X * Transform.Right.Z) + Math.Abs(extents.Y * Transform.Up.Z) + Math.Abs(extents.Z * Transform.Forward.Z);

            center = Vector3.Transform(center, Transform);

            Destination.Min = center - rotatedExtents;
            Destination.Max = center + rotatedExtents;
        }

        public static BoundingBox TransformBoundingBox(BoundingBox OriginalBox, Matrix Transform)
        {
            Vector3 origCorner1 = OriginalBox.Min;
            Vector3 origCorner2 = OriginalBox.Max;

            Vector3 transCorner1 = Vector3.Transform(origCorner1, Transform);
            Vector3 transCorner2 = Vector3.Transform(origCorner2, Transform);

            return new BoundingBox(transCorner1, transCorner2);
        }

        public static BoundingSphere TransformBoundingSphere(BoundingSphere originalBoundingSphere, Matrix transformationMatrix)
        {
            Vector3 trans;
            Vector3 scaling;
            Quaternion rot;
            transformationMatrix.Decompose(out scaling, out rot, out trans);

            float maxScale = scaling.X;
            if (maxScale < scaling.Y)
                maxScale = scaling.Y;
            if (maxScale < scaling.Z)
                maxScale = scaling.Z;

            float transformedSphereRadius = originalBoundingSphere.Radius * maxScale;
            Vector3 transformedSphereCenter = Vector3.Transform(originalBoundingSphere.Center, transformationMatrix);

            BoundingSphere transformedBoundingSphere = new BoundingSphere(transformedSphereCenter, transformedSphereRadius);

            return transformedBoundingSphere;
        }

        public static void DrawBoundingBox(BoundingBox bBox, GraphicsDevice GDevice, Effect baseEffect, Matrix? World, Color? color)
        {
            var v1 = bBox.Min;
            var v2 = bBox.Max;

            var cubeLineVertices = new VertexPositionColor[8]
            {
                new VertexPositionColor(v1, color != null ? (Color)color : Color.White),
                new VertexPositionColor(new Vector3(v2.X, v1.Y, v1.Z), color!= null ? (Color)color : Color.Red),
                new VertexPositionColor(new Vector3(v2.X, v1.Y, v2.Z), color!= null ? (Color)color :Color.Green),
                new VertexPositionColor(new Vector3(v1.X, v1.Y, v2.Z), color!= null ? (Color)color : Color.Blue),
                new VertexPositionColor(new Vector3(v1.X, v2.Y, v1.Z), color != null ? (Color)color : Color.White),
                new VertexPositionColor(new Vector3(v2.X, v2.Y, v1.Z), color != null ? (Color)color : Color.Red),
                new VertexPositionColor(v2, color != null ? (Color)color : Color.Green),
                new VertexPositionColor(new Vector3(v1.X, v2.Y, v2.Z), color != null ? (Color)color : Color.Blue),
            };

            short[] cubeLineIndices = { 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 };


            VBuffer = new VertexBuffer(GDevice, typeof(VertexPositionColor), cubeLineVertices.Length, BufferUsage.WriteOnly);
            IBuffer = new IndexBuffer(GDevice, 0, cubeLineIndices.Length, BufferUsage.WriteOnly);

            VBuffer.SetData(cubeLineVertices);
            IBuffer.SetData(cubeLineIndices);

            Vector3 size = bBox.Max - bBox.Min;
            Matrix WorldMatrix = (Matrix)(World != null ? World : Matrix.CreateScale(size) * Matrix.CreateTranslation(bBox.Max - size * 0.5f));

            try
            {
                //World View Projection
                baseEffect.Parameters[0].SetValue(WorldMatrix * Persian.Camera.View * Persian.Camera.Projection);
                baseEffect.CurrentTechnique.Passes[0].Apply();
            }
            catch (Exception Ex)
            {
                Logger.WriteError(string.Format("Problem on setting effectparameter of Bounding because of : {0}", Ex.ToStandardString()));
            }

            var rasterizerState = GDevice.RasterizerState;
            GDevice.RasterizerState = CoreShared.Wireframe;
            GDevice.SetVertexBuffer(VBuffer);
            GDevice.DrawUserIndexedPrimitives<VertexPositionColor>(PrimitiveType.LineList, cubeLineVertices, 0, 8, cubeLineIndices, 0, 12);
            GDevice.RasterizerState = rasterizerState;
        }

        public static void DrawSphereSpikes(BoundingSphere sphere, GraphicsDevice GDevice,
            Effect baseEffect, Matrix worldMatrix, Color color)
        {
            Vector3 up = sphere.Center + sphere.Radius * Vector3.Up;
            Vector3 down = sphere.Center + sphere.Radius * Vector3.Down;
            Vector3 right = sphere.Center + sphere.Radius * Vector3.Right;
            Vector3 left = sphere.Center + sphere.Radius * Vector3.Left;
            Vector3 forward = sphere.Center + sphere.Radius * Vector3.Forward;
            Vector3 back = sphere.Center + sphere.Radius * Vector3.Backward;

            VertexPositionColor[] sphereLineVertices = new VertexPositionColor[6]
            {
                new VertexPositionColor(up, color),
                new VertexPositionColor(down, color),
                new VertexPositionColor(left, color),
                new VertexPositionColor(right, color),
                new VertexPositionColor(forward, color),
                new VertexPositionColor(back, color)
            };

            VBuffer = new VertexBuffer(GDevice, typeof(VertexPositionColor), sphereLineVertices.Length, BufferUsage.WriteOnly);
            VBuffer.SetData(sphereLineVertices);

            try
            {
                //World View Projection
                baseEffect.Parameters[0].SetValue(worldMatrix * Persian.Camera.View * Persian.Camera.Projection);
                baseEffect.CurrentTechnique.Passes[0].Apply();
            }
            catch (Exception Ex)
            {
                Logger.WriteError(string.Format("Problem on setting effectparameter of Bounding because of : {0}", Ex.ToStandardString()));
            }

            GDevice.SetVertexBuffer(VBuffer);
            GDevice.DrawUserPrimitives<VertexPositionColor>(PrimitiveType.LineList, sphereLineVertices, 0, 3);
        }

        internal static bool IsInSight(BoundingSphere boundingSphere, Matrix World)
        {
            var TransSphere = boundingSphere.Transform(World);
            var Sight = new BoundingFrustum(Persian.Camera.View * Persian.Camera.Projection);
            if (Sight.Contains(TransSphere) != ContainmentType.Disjoint) return true;
            return false;
        }
        
        #endregion

        #region Dispose

        public static void Dispose()
        {
            SystemMemory.SafeDispose(IBuffer);
            SystemMemory.SafeDispose(VBuffer);
        }

        #endregion
    }
}
