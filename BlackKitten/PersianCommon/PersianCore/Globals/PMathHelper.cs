/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : PMathHelper.cs
 * File Description : My math helper extenstion 
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 8/27/2013
 * Comment          : 
 */

using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Framework;
using PersianCore.Graphics.VertexType;
using JitterPhysic.LinearMath;

public static class PMathHelper
{
    public static bool inCompass(double value, double from, double till, Compass compass)
    {
        switch (compass)
        {
            case Compass.From_EQ_Till_EQ:
                if (value >= from && value <= till)
                {
                    return true;
                }
                break;
            case Compass.From_EQ_Till_NotEQ:
                if (value >= from && value < till)
                {
                    return true;
                }
                break;
            case Compass.From_NotEQ_Till_EQ:
                if (value > from && value <= till)
                {
                    return true;
                }
                break;
            case Compass.From_NotEQ_Till_NotEQ:
                if (value > from && value < till)
                {
                    return true;
                }
                break;
            case Compass.GreatFrom:
                if (value > from)
                {
                    return true;
                }
                break;
            case Compass.GreatEqualfrom:
                if (value >= from)
                {
                    return true;
                }
                break;
            case Compass.LessEqualFrom:
                if (value <= from)
                {
                    return true;
                }
                break;
            case Compass.LessFrom:
                if (value < from)
                {
                    return true;
                }
                break;
        }
        return false;
    }

    public static void Restrict(double value, double from, double till)
    {
        if (value < from)
        {
            value = from;
        }
        else if (value > till)
        {
            value = till;
        }
    }

    public static Matrix CreateRotationMatrix(Vector3 vector3)
    {
        return Matrix.CreateRotationX(vector3.X) * Matrix.CreateRotationY(vector3.Y) * Matrix.CreateRotationZ(vector3.Z);
    }

    public static Matrix CreateRotationMatrix(Vector2 vector2)
    {
        return Matrix.CreateRotationX(vector2.X) * Matrix.CreateRotationY(vector2.Y);
    }

    public static Vector3 ScreenProjectedPosition(Viewport viewport, Vector3 Position)
    {
        return viewport.Project(Position, Persian.Camera.Projection, Persian.Camera.View, Matrix.Identity);
    }

    #region Slide

    public static int CheckPlaneState(CutPlane p, Vector3 point)
    {
        Vector3 vector2 = point - p.Apoint;
        float f = Vector3.Dot(p.Normal, vector2);
        return float.IsNaN(f) ? 0 : Math.Sign(f);
    }

    public static CutPlane CreatePlane(Ray r1, Ray r2)
    {
        Vector3 vector1 = Vector3.Cross(r1.Direction, r2.Direction);
        vector1.Normalize();
        return new CutPlane()
        {
            A = vector1.X,
            B = vector1.Y,
            C = vector1.Z,
            D = Vector3.Dot(vector1, r2.Position),
            Apoint = r2.Position,
            Ray1 = r1,
            Ray2 = r2
        };
    }

    private static void AnalyzeVertex(PersianCore.Meshes.Components.Base.Slice m, CutPlane p, 
        int ind, Dictionary<int, VertexMesh> dic, out int s, out VertexMesh v)
    {
        v = m.Vertices[ind];
        s = PMathHelper.CheckPlaneState(p, v.Position);

        if (!dic.ContainsKey(ind))
        {
            dic.Add(ind, v);
        }
    }

    public static bool Slice(PersianCore.Meshes.Components.Base.Slice m, CutPlane p)
    {
        for (int j = 0; j < 1; j++)
        {
            m.vb1.Clear();
            m.vb_1.Clear();
            m.vbro.Clear();
            //effect.World = Matrix.CreateTranslation(0, -j, 0);

            var dic1 = new Dictionary<int, VertexMesh>();
            //TODO : move to amp
            for (int i = 0; i < m.Indices.Count; i++)
            {
                var ind0 = m.Indices[i];
                //First Vertex
                int s0;
                VertexMesh p0;
                AnalyzeVertex(m, p, ind0, dic1, out s0, out p0);
                ++i;

                //Second Vertex
                var ind1 = m.Indices[i];
                int s1;
                VertexMesh p1;
                AnalyzeVertex(m, p, ind1, dic1, out s1, out p1);

                ++i;

                var ind2 = m.Indices[i];

                //Threeth Vertex
                int s2;
                VertexMesh p2;
                AnalyzeVertex(m, p, ind2, dic1, out s2, out p2);

                #region Calculate vertices

                var ro0 = new VertexMesh { Texture = new Vector2(-1, -1) };
                var ro1 = new VertexMesh { Texture = new Vector2(-1, -1) };
                if (s0 == 1 && s1 == 1 && s2 == 1)
                {
                    m.vb1.Add(p0);
                    m.vb1.Add(p1);
                    m.vb1.Add(p2);
                }
                else if (s0 == -1 && s1 == -1 && s2 == -1)
                {
                    m.vb_1.Add(p0);
                    m.vb_1.Add(p1);
                    m.vb_1.Add(p2);
                }

                else if (s0 == -1 && s1 == 1 && s2 == -1)
                {
                    ro0 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p0, p1), p);
                    ro1 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p2, p1), p);

                    m.vbro.Add(ro0);
                    m.vbro.Add(ro1);


                    m.vb_1.Add(ro0);
                    m.vb_1.Add(p2);
                    m.vb_1.Add(p0);

                    m.vb_1.Add(ro0);
                    m.vb_1.Add(ro1);
                    m.vb_1.Add(p2);

                    m.vb1.Add(ro0);
                    m.vb1.Add(p1);
                    m.vb1.Add(ro1);

                }
                else if (s0 == 1 && s1 == -1 && s2 == 1)
                {
                    ro0 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p0, p1), p);
                    ro1 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p2, p1), p);

                    m.vbro.Add(ro0);
                    m.vbro.Add(ro1);


                    m.vb1.Add(ro0);
                    m.vb1.Add(p2);
                    m.vb1.Add(p0);

                    m.vb1.Add(ro0);
                    m.vb1.Add(ro1);
                    m.vb1.Add(p2);

                    m.vb_1.Add(ro0);
                    m.vb_1.Add(p1);
                    m.vb_1.Add(ro1);

                }
                else if (s0 == 1 && s1 == 1 && s2 == -1)
                {
                    ro0 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p0, p2), p);
                    ro1 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p1, p2), p);

                    m.vbro.Add(ro0);
                    m.vbro.Add(ro1);


                    m.vb1.Add(ro0);
                    m.vb1.Add(p0);
                    m.vb1.Add(p1);

                    m.vb1.Add(ro0);
                    m.vb1.Add(p1);
                    m.vb1.Add(ro1);

                    m.vb_1.Add(ro0);
                    m.vb_1.Add(ro1);
                    m.vb_1.Add(p2);
                }
                else if (s0 == -1 && s1 == 1 && s2 == 1)
                {
                    ro0 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p1, p0), p);
                    ro1 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p2, p0), p);

                    m.vbro.Add(ro0);
                    m.vbro.Add(ro1);


                    m.vb_1.Add(ro0);
                    m.vb_1.Add(ro1);
                    m.vb_1.Add(p0);

                    m.vb1.Add(ro0);
                    m.vb1.Add(p2);
                    m.vb1.Add(ro1);

                    m.vb1.Add(ro0);
                    m.vb1.Add(p1);
                    m.vb1.Add(p2);
                }
                else if (s0 == -1 && s1 == -1 && s2 == 1)
                {
                    ro0 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p0, p2), p);
                    ro1 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p1, p2), p);

                    m.vbro.Add(ro0);
                    m.vbro.Add(ro1);


                    m.vb1.Add(ro0);
                    m.vb1.Add(ro1);
                    m.vb1.Add(p2);

                    m.vb_1.Add(ro0);
                    m.vb_1.Add(p0);
                    m.vb_1.Add(p1);

                    m.vb_1.Add(ro0);
                    m.vb_1.Add(p1);
                    m.vb_1.Add(ro1);
                }
                else if (s0 == 1 && s1 == -1 && s2 == -1)
                {
                    ro0 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p1, p0), p);
                    ro1 = PMathHelper.Line3DIntersectPlane(Line3D.CreateLin3D(p2, p0), p);

                    m.vbro.Add(ro0);
                    m.vbro.Add(ro1);

                    m.vb1.Add(ro0);
                    m.vb1.Add(ro1);
                    m.vb1.Add(p0);

                    m.vb_1.Add(ro0);
                    m.vb_1.Add(p1);
                    m.vb_1.Add(p2);

                    m.vb_1.Add(ro0);
                    m.vb_1.Add(p2);
                    m.vb_1.Add(ro1);
                }
                if (ro0.Texture.X >= 0)
                {
                    m.vbro.Add(ro0);
                    m.vbro.Add(ro1);
                }


                #endregion
            }
            if (m.vb1.Count == 0 || m.vb_1.Count == 0) return false;
                if (m.ib1.Count != 0)
                {
                    m._ib1 = new IndexBuffer(Persian.GDevice, typeof(ushort), m.ib1.Count, BufferUsage.WriteOnly);
                    m._ib1.SetData(m.ib1.ToArray());
                }
                if (m.ib_1.Count != 0)
                {
                    m._ib_1 = new IndexBuffer(Persian.GDevice, typeof(ushort), m.ib_1.Count, BufferUsage.WriteOnly);
                    m._ib_1.SetData(m.ib_1.ToArray());
                }
                var inds = new List<ushort>();
                if (m.vbro.Count > 2)
                {
                    m.vbro.Insert(0,
                                new VertexMesh
                                {
                                    Position = ((m.vbro[0].Position + m.vbro[m.vbro.Count / 2].Position) / 2f),
                                    Normal = (m.vbro[0].Normal + m.vbro[m.vbro.Count / 2].Normal) / 2f,
                                    Texture = (m.vbro[0].Texture + m.vbro[m.vbro.Count / 2].Texture) / 2f
                                });
                }
                for (int i = 1; i < m.vbro.Count; i += 2)
                {
                    inds.Add(0);
                    inds.Add((ushort)(i + 0));
                    inds.Add((ushort)(i + 1));
                }

                if (inds.Count != 0)
                {
                    m._ibro = new IndexBuffer(Persian.GDevice, typeof(ushort), inds.Count, BufferUsage.WriteOnly);
                    m._ibro.SetData(inds.ToArray());
                    m._ibro1 = new IndexBuffer(Persian.GDevice, typeof(ushort), inds.Count, BufferUsage.WriteOnly);
                    m._ibro1.SetData(inds.ToArray());
                }

                if (m.vbro.Count != 0)
                {
                    m._vbro = new VertexBuffer(Persian.GDevice, VertexMesh._VertexDeclaration, m.vbro.Count,                                             BufferUsage.None);
                    m._vbro.SetData(m.vbro.ToArray());

                    m._vbro1 = new VertexBuffer(Persian.GDevice, VertexMesh._VertexDeclaration, m.vbro.Count,                                             BufferUsage.None);
                    m._vbro1.SetData(m.vbro.ToArray());
                }
                if (m.vb1.Count != 0)
                {
                    m._vb1 = new VertexBuffer(Persian.GDevice, VertexMesh._VertexDeclaration, m.vb1.Count, BufferUsage.None);
                    m._vb1.SetData(m.vb1.ToArray());
                }
                if (m.vb_1.Count != 0)
                {
                    m._vb_1 = new VertexBuffer(Persian.GDevice, VertexMesh._VertexDeclaration, m.vb_1.Count,
                                             BufferUsage.None);
                    m._vb_1.SetData(m.vb_1.ToArray());
                }
            }

        return true;
        //if (m.vb1.Count == 0 || m.vbro.Count == 0)
        //{
        //    m._isSlicing = false;
        //}
        //else
        //{
        //    m._isSlicing = true;
        //    m._cutT = 0;
        //    m._throwT = 0;
        //    m._world1 = m._world_1 = m.World;
        //    m._a = m.World.M42;
        //    m._z0 = m.World.M43;

        //}
    }

    public static VertexMesh Line3DIntersectPlane(Line3D l, CutPlane p)
    {
        float num1 = (float)(-((double)p.A * (double)l.Point.X + (double)p.B * (double)l.Point.Y + (double)p.C * (double)l.Point.Z - (double)p.D) / ((double)p.A * (double)l.Hadi.X + (double)p.B * (double)l.Hadi.Y + (double)p.C * (double)l.Hadi.Z));
        Vector3 Position = new Vector3(num1 * l.Hadi.X + l.Point.X, num1 * l.Hadi.Y + l.Point.Y, num1 * l.Hadi.Z + l.Point.Z);
        float num2 = Vector3.Distance(l.P0.Position, l.P1.Position);
        float amount = Vector3.Distance(l.P0.Position, Position) / num2;
        return new VertexMesh(Position, Vector3.Lerp(l.P0.Normal, l.P1.Normal, amount), Vector2.Lerp(l.P0.Texture, l.P1.Texture, amount), Vector3.Lerp(l.P0.Tangent, l.P1.Tangent, amount), Vector3.Lerp(l.P0.Bionormal, l.P1.Bionormal, amount));
    }

    #endregion

    internal static Vector3 Lerp(Vector3 vector0, Vector3 vector1, float amount)
    {
        return new Vector3(
            MathHelper.Lerp(vector0.X, vector1.X, amount),
            MathHelper.Lerp(vector0.Y, vector1.Y, amount),
            MathHelper.Lerp(vector0.Z, vector1.Z, amount));
    }
}