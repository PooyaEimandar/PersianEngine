/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : ObjectsManager.cs
 * File Description : The mesh manager
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 7/29/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Graphics;
using PersianCore.Graphics.Particles;
using PersianCore.Meshes;
using PersianCore.Meshes.Components;
using System;
using System.Collections.Generic;

namespace PersianCore
{
    public class ObjectsManager : Node
    {
        #region Fields & Properties

        public static List<Mesh> SelectedMeshes = new List<Mesh>();
        public static List<BoneData> SelectedBones = new List<BoneData>();
        public static List<ParticleSystem> SelectedParticles = new List<ParticleSystem>();

        byte signalForNeedUpdate;
        BlendState oQueryBlendState;
        bool needToLoad;
        List<Mesh> toBeAdd;
        List<Mesh> meshes;
        /// <summary>
        /// Get All Meshes
        /// </summary>
        public List<Mesh> Meshes
        {
            get
            {
                return this.meshes;
            }
        }

        //public List<Mesh> AddAtRuntime { get; set; }

        public ParticlesManager ParticlesManager { get; set; }

        EnvironmentManager envManager;
        public EnvironmentManager EnvManager
        {
            get
            {
                return this.envManager;
            }
        }

        #endregion

        #region Constructor

        public ObjectsManager()
        {
            this.signalForNeedUpdate = 0;
            this.needToLoad = false;
            this.ParticlesManager = new ParticlesManager();
            this.meshes = new List<Mesh>();
            this.toBeAdd = new List<Mesh>();
            //Add skydome
            this.envManager = new EnvironmentManager();
            if (!Persian.RunningEngine)
            {
                SelectedMeshes = new List<Mesh>();
                SelectedBones = new List<BoneData>();
            }
            this.oQueryBlendState = new BlendState()
            {
                ColorWriteChannels = ColorWriteChannels.None
            };
        }

        ~ObjectsManager()
        {
            this.Dispose(false);
        }

        #endregion

        #region Initialize

        public void Initialize()
        {
            string textureName = "Night.png";
            string cloudsName = "DarkClouds.png";
            Vector3 sunVector = new Vector3(0, -2, 0);
            bool allowRotate = false;

            if (!Persian.RunningEngine)
            {
                textureName = "Rainy.png";
                cloudsName = "Clouds.png";
                sunVector = new Vector3(0, 0.1f, 0);
                allowRotate = true;
            }

            this.envManager.LoadSky(
                new PersianSettings.SkySet()
                {
                    UseSameTexture = false,
                    AllowRotate = allowRotate,
                    TextureName = textureName,
                    CloudsName = cloudsName,
                    SunVector = sunVector,
                    TexCoordScale = 1.0f
                });
        }

        #endregion

        #region Load

        public void Load(GraphicsDevice GDevice, string ID, Dictionary<string, Type> ContentParams, bool isSkinned)
        {
            string HResult = null;
            var mesh = new Mesh()
            {
                ID = ID
            };
            HResult = mesh.Load(null);
            if (HResult != null)
            {
                Logger.WriteError(string.Format("Could not load mesh with ID : {0}", mesh.ID));
                return;
            }
            this.meshes.Add(mesh);
        }

        #endregion

        #region Methods

        public void StartLoading()
        {
            this.needToLoad = true;
        }

        /// <summary>
        /// Hide or visible meshes
        /// </summary>
        /// <param name="value"></param>
        /// <param name="IDs"></param>
        public void VisiblityMeshes(bool value, params string[] IDs)
        {
            for (int i = 0; i < IDs.Length; ++i)
            {
                for (int j = 0; j < this.meshes.Count; ++j)
                {
                    var mesh = this.meshes[j];
                    if (mesh.ID == IDs[i])
                    {
                        mesh.Visibility = value;
                    }
                }
            }
        }

        public void AddMesh(Mesh mesh)
        {
            this.toBeAdd.Add(mesh);
        }

        public void RemoveAll()
        {
            var mustLive = new List<Mesh>();
            foreach (var item in this.meshes)
            {
                if (item.MustLiveUntilEnd)
                {
                    mustLive.Add(item);
                }
            }

            //Clear them then add the live meshes again
            this.meshes.Clear();
            for (int i = 0; i < mustLive.Count; ++i)
            {
                this.meshes.Add(mustLive[i]);
            }
            this.ParticlesManager.RemoveAll();
            this.envManager.RemoveAll();
        }

        public void RemoveRange(List<Guid> toBeRemoved)
        {
            for (int i = 0; i < toBeRemoved.Count; ++i)
            {
                if (!Remove(toBeRemoved[i]))
                {
                    Logger.WriteError(string.Format("Disposing failed. Could not find the mesh with following guid : {0}",
                        toBeRemoved[i]));
                }
            }
        }

        public bool Remove(Guid guid)
        {
            foreach (var item in this.meshes)
            {
                if (item.GUID == guid)
                {
                    item.Dispose();
                    this.meshes.Remove(item);
                    return true;
                }
            }
            return false;
        }

        public void Remove(Mesh mesh)
        {
            mesh.Dispose();
            this.meshes.Remove(mesh);
        }

        public void SelectMeshe(Mesh mesh)
        {
            SelectedMeshes.Add(mesh);
            mesh.SelectionColor = 1;
        }

        public void SelectBone(BoneData bone)
        {
            SelectedBones.Add(bone);
            bone.IsSelected = true;
        }

        public void VisibleAll()
        {
            foreach (var mesh in this.meshes)
            {
                if (!mesh.Visibility)
                {
                    mesh.Visibility = true;
                }

                if (mesh.BonesVisibility)
                {
                    foreach (var bone in mesh.BonesData)
                    {
                        if (bone.Visibility != 1)
                        {
                            bone.Visibility = 1;
                        }
                    }
                }
            }
        }

        public bool FindMesh(string ID, out Mesh mesh)
        {
            bool find = false;
            mesh = null;
            for (int i = 0; i < this.meshes.Count; ++i)
            {
                if (this.meshes[i].ID == ID)
                {
                    mesh = this.meshes[i];
                    find = true;
                    break;
                }
            }
            if (!find)
            {
                //Search in load on demands
                for (int i = 0; i < this.toBeAdd.Count; ++i)
                {
                    if (this.toBeAdd[i].ID == ID)
                    {
                        mesh = this.toBeAdd[i];
                        find = true;
                        break;
                    }
                }
            }
            return find;
        }

        private void PlusVisibleModels()
        {
            Debugger.UsageReporter.debugInfo.VisibleModels++;
        }
        private void ResetVisibleModels()
        {
            Debugger.UsageReporter.debugInfo.VisibleModels = 0;
        }

        #endregion

        #region Update

        public void Update()
        {
            //Check whether any mesh wants to add to our render collection or not
            //After adding, pass one frame without rendering objects, then start render all again
            if (this.needToLoad && this.toBeAdd.Count > 0)
            {
                for (int i = 0; i < this.toBeAdd.Count; ++i)
                {
                    this.meshes.Add(this.toBeAdd[i]);
                }
                this.toBeAdd.Clear();
                this.needToLoad = false;
                //Call for updating occlusion culling
                this.signalForNeedUpdate = 3;
            }
            else
            {
                foreach (var item in this.meshes)
                {
                    item.Update();
                }
            }
            this.envManager.Update();
            this.ParticlesManager.Update();
        }

        #endregion

        #region Draw

        internal void OcclusionQuery()
        {
            if (this.signalForNeedUpdate != 0)
            {
                this.signalForNeedUpdate--;
                Persian.Camera.NeedUpdate = true;
            }

            if (RenderManager.CachingGPU || !Persian.Camera.NeedUpdate || this.meshes.Count == 0) return;
#if DEBUG
            ResetVisibleModels();
#endif
            this.meshes.Sort();

            Persian.GDevice.BlendState = BlendState.Opaque;
            Persian.GDevice.DepthStencilState = DepthStencilState.Default;

            var rasterizerState = Persian.GDevice.RasterizerState;
            Persian.GDevice.RasterizerState = RasterizerState.CullNone;
            //Apply Occlusion Query for all meshes
            foreach (var item in this.meshes)
            {
                item.OcclusionQuery();
            }
            Persian.GDevice.RasterizerState = rasterizerState;

            //Wait for all to execute their queries
            bool firstTime = true;
            var count = this.meshes.Count;
            var UnDone = new List<int>();
            while (true)
            {
                if (firstTime)
                {
                    //Query for all meshes and move index of undone to another list
                    firstTime = false;
                    for (int i = 0; i < count; ++i)
                    {
                        var mesh = this.meshes[i];
                        if (mesh.isInSigh && mesh.Visibility && !mesh.AlwaysVisible)
                        {
                            if (mesh.occlusionQuery.IsComplete)
                            {
                                if (mesh.occlusionQuery.PixelCount > 0)
                                {
                                    mesh.isInSigh = true;
                                    Debugger.UsageReporter.debugInfo.Add(mesh.ID);
#if DEBUG
                                    PlusVisibleModels();
#endif
                                }
                                else
                                {
                                    mesh.isInSigh = false;
                                }
                            }
                            else
                            {
                                UnDone.Add(i);
                            }
                        }
                    }
                }
                else
                {
                    for (int i = 0; i < UnDone.Count; ++i)
                    {
                        var doneAt = UnDone[i];
                        var mesh = this.meshes[doneAt];
                        if (mesh.occlusionQuery.IsComplete)
                        {
                            if (mesh.occlusionQuery.PixelCount > 0)
                            {
                                mesh.isInSigh = true;
                                Debugger.UsageReporter.debugInfo.Add(mesh.ID);
#if DEBUG
                                PlusVisibleModels();
#endif
                            }
                            else
                            {
                                mesh.isInSigh = false;
                            }
                            UnDone.Remove(doneAt);
                        }
                    }
                }
                if (UnDone.Count == 0) break;
            }
        }

        internal void DrawShadowMap(ref Matrix LightViewProj)
        {
            foreach (var item in this.meshes)
            {
                item.DrawShadowMap(ref LightViewProj);
            }
        }

        internal void DrawToGBuffer()
        {
            foreach (var item in this.meshes)
            {
                item.DrawToGBuffer();
            }
        }

        internal void ReConstructShading(RenderTarget2D LightMap)
        {
            foreach (var item in this.meshes)
            {
                item.ReConstructShading(LightMap);
            }
        }

        internal void DrawOpaqueObjects()
        {

        }

        internal void DrawSky()
        {
            this.envManager.DrawSky();
        }

        internal void DrawBlendObjects()
        {
            this.ParticlesManager.Draw();
            this.envManager.DrawParticles();
        }

        internal void DrawToGlowMap()
        {
            foreach (var item in this.meshes)
            {
                item.DrawToGlowMap();
            }
        }


        #endregion

        #region Dispose

        protected override void Dispose(bool disposing)
        {
            if (!disposing || isDisposed) return;

            foreach (var item in this.meshes)
            {
                item.Dispose();
            }
            this.meshes.Clear();

            foreach (var item in this.toBeAdd)
            {
                item.Dispose();
            }
            this.toBeAdd.Clear();

            this.envManager.Dispose();
            this.ParticlesManager.Dispose();
            base.Dispose(disposing);
        }

        #endregion
    }
}
