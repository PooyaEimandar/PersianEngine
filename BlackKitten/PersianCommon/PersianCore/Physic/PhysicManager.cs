/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : PhysicManager.cs
 * File Description : This manager for physic
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 8/5/2013
 * Comment          : 
 */

using Debugger;
using JitterPhysic;
using JitterPhysic.Collision;
using JitterPhysic.Collision.Shapes;
using JitterPhysic.Dynamics;
using JitterPhysic.Dynamics.Constraints;
using JitterPhysic.LinearMath;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Physic.Primitives3D;
using System;

namespace PersianCore.Physic
{
    //public enum PhysicTags { Bullet };
    public enum PhysicTypes { NoPhysic, Static, Dynamic, DynamicLoadAtRunTime }
    
    public class PhysicManager
    {
        enum Primitives { box, sphere, cylinder, cone, capsule }
        PersianCore.Physic.Primitives3D.GeometricPrimitive[] primitives;
        Random random;
        bool multithread;
        int activeBodies;
        public DebugDrawer DebugDrawer { private set; get; }
        public BasicEffect basicEffect { private set; get; }

        public static bool Enable = true;
        public static PhysicWorld physicWorld { private set; get; }
        public static float? Step = null;

        RasterizerState wireframe, cullMode, normal;
        Color[] rndColors;
        // Store information for drag and drop
        
        //SoftBodyJenga Scene;///////////////////////

        public PhysicManager()
        {

            random = new Random();
            rndColors = new Color[20];

            for (int i = 0; i < 20; i++)
            {
                rndColors[i] = new Color((float)random.NextDouble(), (float)random.NextDouble(), (float)random.NextDouble());
            }

            multithread = true;
            activeBodies = 0;
            primitives = new PersianCore.Physic.Primitives3D.GeometricPrimitive[5];
            wireframe = new RasterizerState();
            wireframe.FillMode = FillMode.WireFrame;

            cullMode = new RasterizerState();
            cullMode.CullMode = CullMode.None;
            
            normal = new RasterizerState();

            Initialize();
        }

        public void Initialize()
        {
            var collision = new CollisionSystemPersistentSAP();
            physicWorld = new PhysicWorld(collision)
            {
                AllowDeactivation = true,
                Gravity = new JVector(0, -98.1f, 0),
            };
            

            DebugDrawer = new DebugDrawer();
            DebugDrawer.Initialize();

            primitives[(int)Primitives.box] = new BoxPrimitive();
            primitives[(int)Primitives.capsule] = new CapsulePrimitive();
            primitives[(int)Primitives.cone] = new ConePrimitive();
            primitives[(int)Primitives.cylinder] = new CylinderPrimitive();
            primitives[(int)Primitives.sphere] = new SpherePrimitive();

            basicEffect = new BasicEffect(Persian.GDevice);
            basicEffect.EnableDefaultLighting();
            basicEffect.PreferPerPixelLighting = true;

            //Scene = new SoftBodyJenga();/////////////////////////
        }

        public void Dispose()
        {
        }

        private Vector3 RayTo(Vector2 xy)
        {
            var nearSource = new Vector3(xy.X, xy.Y, 0);
            var farSource = new Vector3(xy.X, xy.Y, 1);

            var world = Matrix.Identity;

            var nearPoint = Persian.GDevice.Viewport.Unproject(nearSource, Persian.Camera.Projection, Persian.Camera.View, world);
            var farPoint = Persian.GDevice.Viewport.Unproject(farSource, Persian.Camera.Projection, Persian.Camera.View, world);

            var direction = farPoint - nearPoint;
            return direction;
        }


        public void Update()
        {
            if (!Enable) return;

            float step = 0;
            if (PhysicManager.Step.HasValue)
            {
                step = PhysicManager.Step.Value;
            }
            else
            {
                step = (float)Persian.gameTime.ElapsedGameTime.TotalSeconds;
                if (step > 1.0f / 100.0f) step = 1.0f / 100.0f;
            }
            physicWorld.Step(step, multithread);
            UpdateDisplayText();
        }

        private bool RaycastCallback(RigidBody body, JVector normal, float fraction)
        {
            if (body.IsStatic) return false;
            else return true;
        }

        RigidBody lastBody = null;

        #region Spawn Random Primitive
        private void SpawnRandomPrimitive(JVector position, JVector velocity)
        {
            RigidBody body = null;
            int rndn = rndn = random.Next(7);

            // less of the more advanced objects
            if (rndn == 5 || rndn == 6) rndn = random.Next(7);

            switch (rndn)
            {
                case 0:
                    body = new RigidBody(new ConeShape((float)random.Next(5, 50) / 20.0f, (float)random.Next(10, 20) / 20.0f));
                    break;
                case 1:
                    body = new RigidBody(new BoxShape((float)random.Next(10, 30) / 20.0f, (float)random.Next(10, 30) / 20.0f, (float)random.Next(10, 30) / 20.0f));
                    break;
                case 2:
                    body = new RigidBody(new SphereShape(0.4f));
                    break;
                case 3:
                    body = new RigidBody(new CylinderShape(1.0f, 0.5f));
                    break;
                case 4:
                    body = new RigidBody(new CapsuleShape(1.0f, 0.5f));
                    break;
                case 5:
                    Shape b1 = new BoxShape(new JVector(3, 1, 1));
                    Shape b2 = new BoxShape(new JVector(1, 1, 3));
                    Shape b3 = new CylinderShape(3.0f, 0.5f);

                    CompoundShape.TransformedShape t1 = new CompoundShape.TransformedShape(b1, JMatrix.Identity, JVector.Zero);
                    CompoundShape.TransformedShape t2 = new CompoundShape.TransformedShape(b2, JMatrix.Identity, JVector.Zero);
                    CompoundShape.TransformedShape t3 = new CompoundShape.TransformedShape(b3, JMatrix.Identity, new JVector(0, 0, 0));

                    CompoundShape ms = new CompoundShape(new CompoundShape.TransformedShape[3] { t1, t2, t3 });

                    body = new RigidBody(ms);
                    break;
                case 6:
                    //ConvexHullObject obj2 = new ConvexHullObject();
                    //obj2.LoadContent(Content);
                    //Components.Add(obj2);
                    //body = obj2.body;
                    //body.Material.Restitution = 0.2f;
                    //body.Material.StaticFriction = 0.8f;
                    body = new RigidBody(new CapsuleShape(1.0f, 0.5f));
                    break;
            }

            physicWorld.AddBody(body);
            //body.IsParticle = true;
            // body.EnableSpeculativeContacts = true;
            body.Position = position;
            body.LinearVelocity = velocity;
            lastBody = body;
        }
        #endregion

        #region update the display text informations

        private void UpdateDisplayText()
        {
            int entries = (int)PhysicWorld.DebugType.Num;
            double total = 0;

            for (int i = 0; i < entries; i++)
            {
                var type = (PhysicWorld.DebugType)i;

                UsageReporter.debugInfo.Add(type.ToString() + ": " + ((double)physicWorld.DebugTimes[i]).ToString("0.00"));

                total += physicWorld.DebugTimes[i];
            }

            UsageReporter.debugInfo.Add((multithread) ? "Multithreaded" : "Single Threaded");
            UsageReporter.debugInfo.Add("Total Physics Time: " + total.ToString("0.00"));
            UsageReporter.debugInfo.Add("Physics Framerate: " + (1000.0d / total).ToString("0") + " fps");

            return;

            //accUpdateTime += (float)time.ElapsedGameTime.TotalSeconds;
            //if (accUpdateTime < 0.1f) return;

            //accUpdateTime = 0.0f;

            int contactCount = 0;
            foreach (Arbiter ar in physicWorld.ArbiterMap.Arbiters)
                contactCount += ar.ContactList.Count;

            UsageReporter.debugInfo.Add("Arbitercount: " + physicWorld.ArbiterMap.Arbiters.Count.ToString() + ";" + " Contactcount: " + contactCount.ToString());
            UsageReporter.debugInfo.Add("Islandcount: " + physicWorld.Islands.Count.ToString());
            UsageReporter.debugInfo.Add("Bodycount: " + physicWorld.RigidBodies.Count + " (" + activeBodies.ToString() + ")");

            UsageReporter.debugInfo.Add("gen0: " + GC.CollectionCount(0).ToString() + "  gen1: " + GC.CollectionCount(1).ToString() + "  gen2: " + GC.CollectionCount(2).ToString());
        }

        #endregion

        #region add draw matrices to the different primitives

        private void AddShapeToDrawList(Shape shape, JMatrix ori, JVector pos)
        {
            PersianCore.Physic.Primitives3D.GeometricPrimitive primitive = null;
            var scaleMatrix = Matrix.Identity;

            if (shape is BoxShape)
            {
                primitive = primitives[(int)Primitives.box];
                scaleMatrix = Matrix.CreateScale((shape as BoxShape).Size.ToXNAVector());
            }
            else if (shape is SphereShape)
            {
                primitive = primitives[(int)Primitives.sphere];
                scaleMatrix = Matrix.CreateScale((shape as SphereShape).Radius);
            }
            else if (shape is CylinderShape)
            {
                primitive = primitives[(int)Primitives.cylinder];
                var cs = shape as CylinderShape;
                scaleMatrix = Matrix.CreateScale(cs.Radius, cs.Height, cs.Radius);
            }
            else if (shape is CapsuleShape)
            {
                primitive = primitives[(int)Primitives.capsule];
                var cs = shape as CapsuleShape;
                scaleMatrix = Matrix.CreateScale(cs.Radius * 2, cs.Length, cs.Radius * 2);
            }
            else if (shape is ConeShape)
            {
                var cs = shape as ConeShape;
                scaleMatrix = Matrix.CreateScale(cs.Radius, cs.Height, cs.Radius);
                primitive = primitives[(int)Primitives.cone];
            }

            if (primitive != null)
            {
                primitive.AddWorldMatrix(
                    scaleMatrix * ori.ToXNAMatrix() * Matrix.CreateTranslation(pos.ToXNAVector()));
            }
        }

        private void AddBodyToDrawList(RigidBody rigidBody)
        {
            if (rigidBody.drawType == DrawType.DoNotDraw) return;

            bool isCompoundShape = (rigidBody.Shape is CompoundShape);

            if (!isCompoundShape)
            {
                AddShapeToDrawList(rigidBody.Shape, rigidBody.Orientation, rigidBody.Position);
            }
            else
            {
                CompoundShape cShape = rigidBody.Shape as CompoundShape;
                JMatrix orientation = rigidBody.Orientation;
                JVector position = rigidBody.Position;

                foreach (var ts in cShape.Shapes)
                {
                    JVector pos = ts.Position;
                    JMatrix ori = ts.Orientation;

                    JVector.Transform(ref pos, ref orientation, out pos);
                    JVector.Add(ref pos, ref position, out pos);

                    JMatrix.Multiply(ref ori, ref orientation, out ori);

                    AddShapeToDrawList(ts.Shape, ori, pos);
                }

            }

        }
        #endregion

        #region draw jitter debug data


        private void DrawJitterDebugInfo()
        {
            int cc = 0;

            foreach (Constraint constr in physicWorld.Constraints)
                constr.DebugDraw(DebugDrawer);

            foreach (RigidBody body in physicWorld.RigidBodies)
            {
                DebugDrawer.Color = rndColors[cc % rndColors.Length];
                body.DebugDraw(DebugDrawer);
                cc++;
            }
        }

        private void Walk(DynamicTree<SoftBody.Triangle> tree, int index)
        {
            DynamicTreeNode<SoftBody.Triangle> tn = tree.Nodes[index];
            if (tn.IsLeaf()) return;
            else
            {
                Walk(tree, tn.Child1);
                Walk(tree, tn.Child2);

                DebugDrawer.DrawAabb(tn.AABB.Min, tn.AABB.Max, Color.Red);
            }
        }

        private void DrawDynamicTree(SoftBody cloth)
        {
            Walk(cloth.DynamicTree, cloth.DynamicTree.Root);
        }


        private void DrawIslands()
        {
            JBBox box;

            foreach (CollisionIsland island in physicWorld.Islands)
            {
                box = JBBox.SmallBox;

                foreach (RigidBody body in island.Bodies)
                {
                    box = JBBox.CreateMerged(box, body.BoundingBox);
                }

                DebugDrawer.DrawAabb(box.Min, box.Max, island.IsActive() ? Color.Green : Color.Yellow);

            }
        }
        #endregion

        #region Draw Cloth

        private void DrawCloth()
        {
            foreach (SoftBody body in physicWorld.SoftBodies)
            {
                if (body.drawType == DrawType.DoNotDraw)
                {
                    return;
                }
                for (int i = 0; i < body.Triangles.Count; i++)
                {
                    DebugDrawer.DrawTriangle(body.Triangles[i].VertexBody1.Position,
                        body.Triangles[i].VertexBody2.Position,
                        body.Triangles[i].VertexBody3.Position,
                        new Color(0, 0.95f, 0, 0.5f));
                }
                //DrawDynamicTree(body);
            }
        }
        #endregion

        public void Draw()
        {
            return;
            var GDevice = Persian.GDevice;
            GDevice.DepthStencilState = DepthStencilState.Default;

            basicEffect.View = Persian.Camera.View;
            basicEffect.Projection = Persian.Camera.Projection;

            activeBodies = 0;

            // Draw all shapes
            foreach (RigidBody body in physicWorld.RigidBodies)
            {
                if (body.IsActive) activeBodies++;
                if (body.drawType == DrawType.DoNotDraw || body.IsParticle) continue;
                AddBodyToDrawList(body);
            }

            //basicEffect.DiffuseColor = Color.LightGray.ToVector3();

            //DrawCloth();

            var rasterizerState = GDevice.RasterizerState;
            GDevice.RasterizerState = CoreShared.Wireframe;
            // Draw the debug data provided by Jitter
            DrawIslands();
            DrawJitterDebugInfo();

            #region Debug Draw All Contacts
            foreach (Arbiter a in physicWorld.ArbiterMap)
            {
                foreach (Contact c in a.ContactList)
                {
                    //Copy Collision Type to both objects that collide
                    if (TypeOfPhysicCollision(c.Body1))
                    {
                        c.Body2.CollisionTags = c.Body1.CollisionTags;
                        c.Body2.CollisionPosition = c.Body1.Position;
                    }
                    else if (TypeOfPhysicCollision(c.Body2))
                    {
                        c.Body1.CollisionTags = c.Body2.CollisionTags;
                        c.Body1.CollisionPosition = c.Body2.Position;
                    }

                    DebugDrawer.DrawLine(c.Position1 + 0.5f * JVector.Left, c.Position1 + 0.5f * JVector.Right, Color.Green);
                    DebugDrawer.DrawLine(c.Position1 + 0.5f * JVector.Up, c.Position1 + 0.5f * JVector.Down, Color.Green);
                    DebugDrawer.DrawLine(c.Position1 + 0.5f * JVector.Forward, c.Position1 + 0.5f * JVector.Backward, Color.Green);


                    DebugDrawer.DrawLine(c.Position2 + 0.5f * JVector.Left, c.Position2 + 0.5f * JVector.Right, Color.Red);
                    DebugDrawer.DrawLine(c.Position2 + 0.5f * JVector.Up, c.Position2 + 0.5f * JVector.Down, Color.Red);
                    DebugDrawer.DrawLine(c.Position2 + 0.5f * JVector.Forward, c.Position2 + 0.5f * JVector.Backward, Color.Red);
                }
            }
            #endregion

            foreach (var prim in primitives)
            {
                prim.Draw(basicEffect);
            }
            GDevice.RasterizerState = rasterizerState;
            GDevice.RasterizerState = cullMode;

            //this.Scene.Draw(GraphicsDevice);/////////////////////////////////////
            DebugDrawer.Draw(GDevice);

            GDevice.RasterizerState = normal;
        }

        private bool TypeOfPhysicCollision(RigidBody Body)
        {
            //if (Body.Tag != null && Body.Tag.GetType() == typeof(PhysicTags))
            //{
            //    Body.CollisionTags = CollisionTags.BulletWithStatic;
            //    return true;
            //}
            return false;
        }
    }
}
