/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : CutScene.cs
 * File Description : Cut Scene
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 8/27/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using PersianCore.Cameras;
using PersianCore.Meshes;
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace PersianCore.Framework.Animation
{
    public class CutScene : Node
    {
        #region Fields & Properties

        List<Mesh> animatedModels { get; set; }
        AnimatedCamera animatedCamera { get; set; }

        string absoluteAnimatedCameraPath;
        [DoNotSave]
        [Browsable(false)]
        public string AbsoluteAnimatedCameraPath
        {
            get
            {
                return this.absoluteAnimatedCameraPath;
            }
            set
            {
                if (this.absoluteAnimatedCameraPath != value)
                {
                    this.absoluteAnimatedCameraPath = value;
                    AddAnimatedCamera(value, false);
                }
            }
        }
        
        List<Guid> animatedModelsGuids;
        [Description("The guids of all animated models associated to the CutScene")]
        [Category("CutScene")]
        public List<Guid> AnimatedModelsGuids
        {
            get
            {
                return this.animatedModelsGuids;
            }
            set
            {
                this.animatedModelsGuids = value;
            }
        }
        
        [Description("Name of cutScene")]
        [Category("CutScene")]
        public string Name { get; set; }

        bool active;
        [Description("Active or deactive the cutScene")]
        [Category("CutScene")]
        public bool Active 
        { 
            get
            {
                return this.active;
            }
            set
            {
                if (this.active != value)
                {
                    this.active = value;
                    if (this.animatedCamera != null)
                    {
                        this.animatedCamera.IsActive = value;
                    }
                    bool? Value = null;
                    if (value)
                    {
                        Value = false;
                    }
                    foreach (var mesh in animatedModels)
                    {
                        SetAnimationState(mesh, Value, null);
                    }
                }
            }
        }

        [Description("Name of animated camera")]
        [Category("Camera")]
        public string AnimatedCameraName { get; set; }

        string animatedCameraPath;
        [Description("Path of animated camera")]
        [Category("Camera")]
        public string AnimatedCameraPath
        {
            get
            {
                return this.animatedCameraPath;
            }
            set
            {
                if (this.animatedCameraPath != value)
                {
                    this.animatedCameraPath = value;
                    AddAnimatedCamera(value, true);
                }
            }
        }

        float animationSpeed;
        [Description("The speed of camera, higher value means lower speed")]
        [Category("Camera")]
        public float CameraSpeed
        {
            get
            {
                return this.animationSpeed;
            }
            set
            {
                if (this.animationSpeed != value)
                {
                    this.animationSpeed = value;
                    if (this.animatedCamera != null)
                    {
                        this.animatedCamera.AnimationDelayInMS = value;
                    }
                }
            }
        }

        bool loopable;
        [Description("Is animated camera is loopable or not")]
        [Category("Camera")]
        public bool Loopable
        {
            get
            {
                return this.loopable;
            }
            set
            {
                if (this.loopable != value)
                {
                    this.loopable = value;
                    if (this.animatedCamera != null)
                    {
                        this.animatedCamera.Loopable = value;
                    }
                }
            }
        }

        [Description("Initialize position of camera")]
        [Category("Camera")]
        public Vector3 InitialPosition { get; set; }

        [Description("Current frame of animated camera")]
        [Category("Camera")]
        public int CurrentFrame
        {
            get
            {
                if (this.animatedCamera != null)
                {
                    return this.animatedCamera.Index;
                }
                return -1;
            }
        }

        [Description("Count of frames to be leaved before endo of animated camera")]
        [Category("Camera")]
        public int LeaveFramesBeforeEnd
        {
            get
            {
                if (this.animatedCamera != null)
                {
                    return this.animatedCamera.LeaveFramesBeforeEnd;
                }
                return 0;
            }
            set
            {
                if (this.animatedCamera != null)
                {
                    this.animatedCamera.LeaveFramesBeforeEnd = value;
                }
            }
        }

        public event EventHandler OnComplete;
        public CoreFrameWork cFrameWork { get; set; }
        public bool ForceToDisposeModels { get; set; }

        #endregion

        #region Constructor

        public CutScene()
        {
            this.active = true;
            this.Name = "CutScene";
            this.AnimatedCameraName = "CameraCutScene";
            this.animatedCameraPath = string.Empty;
            this.animatedModels = new List<Mesh>();
            this.animatedModelsGuids = new List<Guid>();
            this.animationSpeed = 1950f;
            this.animatedCamera = new AnimatedCamera();
            this.animatedCamera.OnComplete += delegate(object sender, EventArgs e)
            {
                if (this.OnComplete != null) OnComplete(this, null);
            };
        }

        #endregion

        #region Load

        public void LoadAnimatedModelsFromGuids(ref CoreFrameWork coreFrameWork)
        {
            this.cFrameWork = coreFrameWork;
            for (int i = 0; i < this.animatedModelsGuids.Count; ++i)
            {
                AddModelByGuid(this.animatedModelsGuids[i], ref coreFrameWork);
            }
        }

        #endregion

        #region Methods

        public void AddModelByGuid(Guid guid, ref CoreFrameWork coreFrameWork)
        {
            this.cFrameWork = coreFrameWork;
            foreach (var mesh in coreFrameWork.ObjectsManager.Meshes)
            {
                if (mesh.GUID == guid)
                {
                    AddAnimatedMesh(mesh);
                }
            }
        }

        private void AddAnimatedCamera(string value, bool LoadFromContent)
        {
            var contentPath = string.Empty;
            if (LoadFromContent)
            {
                //Load from save file, so we need related path
                contentPath = System.IO.Path.GetFullPath(Persian.EngineContentDir + @"\" + this.animatedCameraPath);
            }
            else
            {
                //Import from absolute path, so convert it to relative path
                this.animatedCameraPath = @"\CutScenes\" + System.IO.Path.GetFileName(value);
                contentPath = System.IO.Path.GetFullPath(Persian.EngineContentDir + this.animatedCameraPath);
                //Copy new one to content
                var HResult = IOHelper.CopyFile(value, contentPath, true);
                if (HResult != null)
                {
                    Logger.WriteError("Failed on copy animated camera to content");
                }
            }

            //Load data of animated camera
            this.animatedCamera.Load(contentPath);
            if (this.animatedCamera == null)
            {
                Logger.WriteError("Failed on loading animated camera");
            }
            // this.animatedCamera.AnimationSpeed = this.animationSpeed;
            this.animatedCamera.Loopable = this.loopable;
        }

        private bool NoAnimatedCamera()
        {
            if (this.animatedCamera == null) return true;
            return false;
        }

        public void Play()
        {
            if (NoAnimatedCamera()) return;

            this.Active = true;
            this.animatedCamera.IsActive = true;
            foreach (var mesh in animatedModels)
            {
                SetAnimationState(mesh, null, null);
            }
        }

        public void Pause()
        {
            if (NoAnimatedCamera()) return;

            this.animatedCamera.IsActive = false;
            foreach (var mesh in animatedModels)
            {
                SetAnimationState(mesh, false, null);
            }
        }

        public void Stop()
        {
            if (NoAnimatedCamera()) return;

            this.animatedCamera.Reset();
            foreach (var mesh in animatedModels)
            {
                mesh.ResetAnimation();
            }
        }

        private void SetAnimationState(Mesh mesh, bool? Value, bool? isInverse)
        {
            if (isInverse != null)
            {
                bool Inverse = (bool)isInverse;
                if (mesh.InverseAnimation != Inverse)
                {
                    mesh.InverseAnimation = Inverse;
                }
            }
            mesh.PlayAnimation(Value);
        }

        public void AddAnimatedMesh(Meshes.Mesh mesh)
        {
            this.animatedModels.Add(mesh);
            if (!this.animatedModelsGuids.Contains(mesh.GUID))
            {
                this.animatedModelsGuids.Add(mesh.GUID);
            }
        }

        #endregion

        #region Update

        public void Update()
        {
            if (this.animatedCamera.Update())
            {
                Persian.Camera.Position += this.InitialPosition;
            }
        }

        #endregion

        #region Dispose

        protected override void Dispose(bool disposing)
        {
            if (disposing && !isDisposed)
            {
                if (this.cFrameWork != null && ForceToDisposeModels)
                {
                    foreach (var item in this.animatedModelsGuids)
                    {
                        cFrameWork.ObjectsManager.Remove(item);
                    }
                }
                this.animatedModels.Clear();
                this.animatedModelsGuids.Clear();
                this.animatedCamera.Dispose();
            }
            base.Dispose(disposing);
        }

        #endregion


    }
}
