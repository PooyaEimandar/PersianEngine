/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : XCursor.cs
 * File Description : Cursor class
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 5/20/2013
 * Comment          : 
 */
using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;

namespace PersianCore
{
    public class XCursor : IDisposable
    {
        #region Constants

        const float CursorSpeed = 250.0f;

        #endregion

        #region Fields and Properties

        bool isDisposed;
        Texture2D cursorTexture;
        Vector2 textureCenter;
        Vector2 position;
        public Vector2 Position
        {
            get 
            { 
                return this.position;
            }
        }

        #endregion

        #region Constructor

        public XCursor()
        {
            this.isDisposed = false;
        }

        ~XCursor()
        {
            this.Dispose(false);
        }

        #endregion

        #region Load

        /// <summary>
        /// Just call it from Engine please
        /// </summary>
        public void Load()
        {
            cursorTexture = Persian.EngineContent.Load<Texture2D>(@"Utilities\Cursors\X");
            textureCenter = new Vector2(cursorTexture.Width / 2, cursorTexture.Height / 2);
        }
        
        #endregion

        #region Methods
        
        /// <summary>
        /// Calculates a world space ray starting at the camera's eye and pointing in the direction of the cursor
        /// </summary>
        /// <param name="viewport"></param>
        /// <param name="projectionMatrix"></param>
        /// <param name="viewMatrix"></param>
        /// <returns></returns>
        public Ray CalculateCursorRay(Viewport viewport, Matrix projectionMatrix, Matrix viewMatrix)
        {
            // create 2 positions in screenspace using the cursor position. 0 is as
            // close as possible to the camera, 1 is as far away as possible.
            Vector3 nearSource = new Vector3(Position, 0f);
            Vector3 farSource = new Vector3(Position, 1f);

            // use Viewport.Unproject to tell what those two screen space positions
            // would be in world space. we'll need the projection matrix and view
            // matrix, which we have saved as member variables. We also need a world
            // matrix, which can just be identity.
            Vector3 nearPoint = viewport.Unproject(nearSource, projectionMatrix, viewMatrix, Matrix.Identity);
            Vector3 farPoint = viewport.Unproject(farSource, projectionMatrix, viewMatrix, Matrix.Identity);

            // find the direction vector that goes from the nearPoint to the farPoint
            // and normalize it....
            Vector3 direction = farPoint - nearPoint;
            direction.Normalize();

            // and then create a new ray using nearPoint as the source.
            return new Ray(nearPoint, direction);
        }

        #endregion

        #region Update

        public void Update(Viewport viewPort, MouseState mouseState)
        {
            position.X = mouseState.X;
            position.Y = mouseState.Y;

            if ((viewPort.X <= position.X) && (position.X <= (viewPort.X + viewPort.Width)) && (viewPort.Y <= position.Y) && (position.Y <= (viewPort.Y + viewPort.Height)))
            {
                position.X = MathHelper.Clamp(position.X, viewPort.X, viewPort.X + viewPort.Width);
                position.Y = MathHelper.Clamp(position.Y, viewPort.Y, viewPort.Y + viewPort.Height);
            }
        }

        #endregion

        #region Draw

        /// <summary>
        /// Just call it from engine please
        /// </summary>
        /// <param name="spriteBatch"></param>
        public void Draw(SpriteBatch spriteBatch)
        {
            spriteBatch.Begin();
            {
                spriteBatch.Draw(cursorTexture, Position, null, Color.White, 0.0f, textureCenter, 1.0f, SpriteEffects.None, 0.0f);
                spriteBatch.End();
            }
        }

        #endregion

        #region Dispose

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected void Dispose(bool isdisposing)
        {
            if (!this.isDisposed)
            {
                this.isDisposed = true;
                SystemMemory.SafeDispose(this.cursorTexture);
            }
        }

        #endregion
    }
}
