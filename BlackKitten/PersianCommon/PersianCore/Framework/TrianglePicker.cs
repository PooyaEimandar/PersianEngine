/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : TrianglePicker.cs
 * File Description : This class responsible to pick triangle with ray
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 6/1/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System.Collections.Generic;

namespace PersianCore.Framework
{
    public class TrianglePicker
    {
        #region Fields & Properties

        double TrianglesCounts;
        string pickedModelName;

        #endregion

        #region Constructor

        public TrianglePicker()
        {
        }

        #endregion

        #region Methods

        public static float? RayIntersectsModel(Ray ray, Meshes.Mesh mesh,
            out bool insideBoundingSphere, out Vector3[] Vertices)
        {
            Dictionary<string, object> TagData = mesh.ModelTag;
            Matrix _World = mesh.World;

            Vertices = new Vector3[3]
            {
                Vector3.Zero,
                Vector3.Zero,
                Vector3.Zero,
            };

            // The input ray is in world space, but our model data is stored in object
            // space. We would normally have to transform all the model data by the
            // modelTransform matrix, moving it into world space before we test it
            // against the ray. That transform can be slow if there are a lot of
            // triangles in the model, however, so instead we do the opposite.
            // Transforming our ray by the inverse modelTransform moves it into object
            // space, where we can test it directly against our model data. Since there
            // is only one ray but typically many triangles, doing things this way
            // around can be much faster.

            var inverseTransform = Matrix.Invert(_World);

            ray.Position = Vector3.Transform(ray.Position, inverseTransform);
            ray.Direction = Vector3.TransformNormal(ray.Direction, inverseTransform);

            if (TagData == null)
            {
                Logger.WriteError("Model.Tag is not set correctly. Make sure your model was built using the custom MeshPipeLine.");
            }

            // Start off with a fast bounding sphere test.
            var boundingSphere = (BoundingSphere)TagData["BoundingSphere"];

            if (boundingSphere.Intersects(ray) == null)
            {
                // If the ray does not intersect the bounding sphere, we cannot
                // possibly have picked this model, so there is no need to even
                // bother looking at the individual triangle data.
                insideBoundingSphere = false;

                return null;
            }
            else
            {
                // The bounding sphere test passed, so we need to do a full
                // triangle picking test.
                insideBoundingSphere = true;

                // Keep track of the closest triangle we found so far,
                // so we can always return the closest one.
                float? closestIntersection = null;

                // Loop over the vertex data, 3 at a time (3 vertices = 1 triangle).
                Vector3[] TagVertices = (Vector3[])TagData["Vertices"];

                for (int i = 0; i < TagVertices.Length; i += 3)
                {
                    // Perform a ray to triangle intersection test.
                    float? intersection;

                    RayIntersectsTriangle(ref ray,
                                          ref TagVertices[i],
                                          ref TagVertices[i + 1],
                                          ref TagVertices[i + 2],
                                          out intersection);

                    // Does the ray intersect this triangle?
                    if (intersection != null)
                    {
                        // If so, is it closer than any other previous triangle?
                        if ((closestIntersection == null) ||
                            (intersection < closestIntersection))
                        {
                            // Store the distance to this triangle.
                            closestIntersection = intersection;

                            // Transform the three vertex positions into world space,
                            // and store them into the output vertex parameters.
                            Vector3.Transform(ref TagVertices[i],
                                              ref _World, out Vertices[0]);

                            Vector3.Transform(ref TagVertices[i + 1],
                                              ref _World, out Vertices[1]);

                            Vector3.Transform(ref TagVertices[i + 2],
                                              ref _World, out Vertices[2]);
                        }
                    }
                }

                return closestIntersection;
            }
        }

        public static void RayIntersectsTriangle(ref Ray ray, ref Vector3 vertex1, ref Vector3 vertex2,
            ref Vector3 vertex3, out float? result)
        {
            // Compute vectors along two edges of the triangle.
            Vector3 edge1, edge2;

            Vector3.Subtract(ref vertex2, ref vertex1, out edge1);
            Vector3.Subtract(ref vertex3, ref vertex1, out edge2);

            // Compute the determinant.
            Vector3 directionCrossEdge2;
            Vector3.Cross(ref ray.Direction, ref edge2, out directionCrossEdge2);

            float determinant;
            Vector3.Dot(ref edge1, ref directionCrossEdge2, out determinant);

            // If the ray is parallel to the triangle plane, there is no collision.
            if (determinant > -float.Epsilon && determinant < float.Epsilon)
            {
                result = null;
                return;
            }

            float inverseDeterminant = 1.0f / determinant;

            // Calculate the U parameter of the intersection point.
            Vector3 distanceVector;
            Vector3.Subtract(ref ray.Position, ref vertex1, out distanceVector);

            float triangleU;
            Vector3.Dot(ref distanceVector, ref directionCrossEdge2, out triangleU);
            triangleU *= inverseDeterminant;

            // Make sure it is inside the triangle.
            if (triangleU < 0 || triangleU > 1)
            {
                result = null;
                return;
            }

            // Calculate the V parameter of the intersection point.
            Vector3 distanceCrossEdge1;
            Vector3.Cross(ref distanceVector, ref edge1, out distanceCrossEdge1);

            float triangleV;
            Vector3.Dot(ref ray.Direction, ref distanceCrossEdge1, out triangleV);
            triangleV *= inverseDeterminant;

            // Make sure it is inside the triangle.
            if (triangleV < 0 || triangleU + triangleV > 1)
            {
                result = null;
                return;
            }

            // Compute the distance along the ray to the triangle.
            float rayDistance;
            Vector3.Dot(ref edge2, ref distanceCrossEdge1, out rayDistance);
            rayDistance *= inverseDeterminant;

            // Is the triangle behind the ray origin?
            if (rayDistance < 0)
            {
                result = null;
                return;
            }

            result = rayDistance;
        }

        #endregion

        #region Update

        public Ray Update(CoreFrameWork coreFrameWork, Viewport viewport, bool AllowMultipleSelection)
        {
            var ray = InputManager.xCursor.CalculateCursorRay(viewport, Persian.Camera.Projection, Persian.Camera.View);  
            pickedModelName = null;

            // Keep track of the closest object we have seen so far, so we can
            // choose the closest one if there are several models under the cursor.
            float closestIntersection = float.MaxValue;
            BoundingSphere sphere;
            
            #region Check 4 picking bounding box of meshes

            foreach (var mesh in coreFrameWork.ObjectsManager.Meshes)
            {
                if (mesh.Visibility || (!mesh.Visibility && mesh.ShowBoundings))
                {
                    bool BoneSelected;

                    #region Select Bones

                    if (mesh.IsSkinned && mesh.BonesVisibility)
                    {
                        BoneSelected = false;
                        for (int j = 0; j < mesh.BonesData.Length; j++)
                        {
                            #region if Allow Multipels so add last selected bones

                            if (AllowMultipleSelection)
                            {
                                if (mesh.BonesData[j].IsSelected)
                                    ObjectsManager.SelectedBones.Add(mesh.BonesData[j]);
                            }
                            else
                            {
                                mesh.BonesData[j].IsSelected = false;
                            }

                            #endregion

                            if (!BoneSelected && mesh.BonesData[j].Visibility == 1)
                            {
                                sphere = new BoundingSphere(mesh.BonesData[j].Center , mesh.BonesData[j].Radius);
                                if (IsClicked(ray, sphere, ref closestIntersection))
                                {
                                    #region when click on selected bone...must be deselecting

                                    if (AllowMultipleSelection)
                                    {
                                        mesh.BonesData[j].IsSelected = !mesh.BonesData[j].IsSelected;
                                        if (mesh.BonesData[j].IsSelected)
                                        {
                                            ObjectsManager.SelectedBones.Add(mesh.BonesData[j]);
                                        }
                                    }
                                    else
                                    {
                                        coreFrameWork.ObjectsManager.SelectBone(mesh.BonesData[j]);
                                    }

                                    #endregion

                                    BoneSelected = true;
                                }
                            }
                        }
                    }

                    #endregion

                    if (!AllowMultipleSelection)
                    {
                        mesh.SelectionColor = 0;
                    }

                    if (mesh.IsSkinned)
                    {
                        #region Select Skinned With Bounding Sphere

                        sphere = mesh.PhysicData.boundingSphere;
                        sphere.Center = mesh.Position;

                        if (IsClicked(ray, sphere, ref closestIntersection))
                        {
                            #region When click on selected mesh...must be deselecting

                            if (AllowMultipleSelection)
                            {
                                if (mesh.SelectionColor == 1)
                                {
                                    mesh.SelectionColor = 0;
                                }
                                else
                                {
                                    mesh.SelectionColor = 1;
                                }
                            }
                            else
                            {
                                mesh.SelectionColor = 1;
                            }

                            #endregion
                        }

                        #endregion
                    }
                    else
                    {
                        #region Get Picked Triangles

                        bool insideBoundingSphere;
                        Vector3[] Vertices;

                        // Perform the ray to model intersection test.
                        float? intersection = RayIntersectsModel(ray, mesh, out insideBoundingSphere, out Vertices);

                        // Do we have a per-triangle intersection with this model?
                        if (intersection != null)
                        {
                            // If so, is it closer than any other model we might have
                            // previously intersected?
                            if (intersection < closestIntersection)
                            {
                                // Store information about this model.
                                closestIntersection = intersection.Value;

                                if (AllowMultipleSelection)
                                {
                                    if (mesh.SelectionColor == 1)
                                    {
                                        //Last Time it has been selected so deselect it
                                        mesh.SelectionColor = 0;
                                    }
                                    else
                                    {
                                        mesh.SelectionColor = 1;
                                    }
                                }
                                else
                                {
                                    mesh.SelectionColor = 1;
                                }
                            }
                        }

                        #endregion
                    }

                    if (mesh.SelectionColor == 1)
                    {
                        this.TrianglesCounts = mesh.TrianglesCounts;
                        this.pickedModelName = mesh.ID;
                        ObjectsManager.SelectedMeshes.Add(mesh);
                    }
                }
            }

            #endregion

            #region Check 4 picking bounding box of particles

            foreach (var particleSystem in coreFrameWork.ObjectsManager.ParticlesManager.ParticleSystems)
            {
                if (particleSystem.Enable)
                {
                    bool ParticleSelected = false;
                    sphere = BoundingSphere.CreateFromBoundingBox(particleSystem.BoundingBox);
                    if (IsClicked(ray, sphere, ref closestIntersection))
                    {
                        if (AllowMultipleSelection)
                        {
                            particleSystem.isSelected = !particleSystem.isSelected;
                            if (particleSystem.isSelected)
                            {
                                ObjectsManager.SelectedParticles.Add(particleSystem);
                            }
                        }
                        else
                        {
                            ObjectsManager.SelectedParticles.Add(particleSystem);
                        }
                        ParticleSelected = true;
                    }
                }
            }

            #endregion

            return ray;
        }

        private bool IsClicked(Ray ray, BoundingSphere sphere, ref float selectedDistance)
        {
            float? result = ray.Intersects(sphere);

            if (result.HasValue == true)
            {
                if (result.Value < selectedDistance)
                {
                    selectedDistance = result.Value;
                    return true;
                }
            }
            return false;
        }

        private Ray GetPickRay(MouseState mouseState, Viewport Viewport)
        {
            int mouseX = mouseState.X;
            int mouseY = mouseState.Y;

            var nearsource = new Vector3((float)mouseX, (float)mouseY, 0f);
            var farsource = new Vector3((float)mouseX, (float)mouseY, 1f);

            var world = Matrix.CreateTranslation(0, 0, 0);

            var nearPoint = Viewport.Unproject(nearsource, Persian.Camera.Projection, Persian.Camera.View, world);
            var farPoint = Viewport.Unproject(farsource, Persian.Camera.Projection, Persian.Camera.View, world);

            // Create a ray from the near clip plane to the far clip plane.
            var direction = farPoint - nearPoint;
            direction.Normalize();
            var pickRay = new Ray(nearPoint, direction);

            return pickRay;
        }

        #endregion

        #region Draw

        public string GetStatus()
        {
            if (pickedModelName != null)
            {
                return string.Format("Picked Model : {0} \r\nTriangles Count : {1}", pickedModelName, this.TrianglesCounts);
            }
            return null;
        }

        #endregion
    }
}
