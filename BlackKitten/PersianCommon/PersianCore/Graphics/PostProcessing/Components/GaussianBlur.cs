/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : GaussianBlur.cs
 * File Description : The gaussian blur post process
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 12/15/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using System;

namespace PersianCore.Graphics.PostProcessing
{
    public class GaussianBlur : Disposable
    {
        #region Fields & Properties
        
        float vAmount;
        public float VAmount 
        { 
            get
            {
                return this.vAmount;
            }
            set
            {
                if (this.vAmount != value)
                {
                    this.vAmount = value;
                    this.forectUpdateV = true;
                }
            }
        }

        float hAmount;
        public float HAmount
        {
            get
            {
                return this.hAmount;
            }
            set
            {
                if (this.hAmount != value)
                {
                    this.hAmount = value;
                    this.forectUpdateH = true;
                }
            }
        }

        public int CurrentPass { get; set; }

        float width, height;
        bool forectUpdateV, forectUpdateH;
        Effect gaussianBlurEffect;
        EffectParameter weightsParameter;
        EffectParameter offsetsParameter;

        RenderTarget hGaussianBlurTarget;
        RenderTarget vGaussianBlurTarget;

        #endregion

        #region Constructor

        public GaussianBlur()
        {
            this.vAmount = 1;
            this.hAmount = 1;
            this.forectUpdateV = false;
            this.forectUpdateH = false;
            this.CurrentPass = 0;
        }

        #endregion

        #region Load

        public void Load(ContentManager Content)
        {
            var path = @"Shaders\PostProcessing\";

            if (!Persian.RunningEngine)
            {
                path = @"EditorBrowser\" + path;
            }

            this.gaussianBlurEffect = Content.Load<Effect>(path + @"GaussianBlur");
            this.weightsParameter = gaussianBlurEffect.Parameters["SampleWeights"];
            this.offsetsParameter = gaussianBlurEffect.Parameters["SampleOffsets"];

            var pp = Persian.GDevice.PresentationParameters;
            int width = pp.BackBufferWidth;
            int height = pp.BackBufferHeight;
            SurfaceFormat format = pp.BackBufferFormat;
            // Create two rendertargets for the bloom processing. These are half the
            // size of the backbuffer, in order to minimize fillrate costs. Reducing
            // the resolution in this way doesn't hurt quality, because we are going
            // to be blurring the bloom images in any case.
            width /= 2;
            height /= 2;

            this.hGaussianBlurTarget = new RenderTarget(
                width,
                height,
                false,
                format,
                DepthFormat.None,
                0,
                RenderTargetUsage.DiscardContents);

            this.vGaussianBlurTarget = new RenderTarget(
                width,
                height,
                false,
                format,
                DepthFormat.None,
                0,
                RenderTargetUsage.DiscardContents);
        }

        #endregion

        #region Draw

        /// <summary>
        /// This is where it all happens. Grabs a scene that has already been rendered,
        /// and uses postprocess magic to add a glowing bloom effect over the top of it.
        /// </summary>
        public Texture2D RenderToFX(Texture2D Input)
        {
            return RenderToFX(Input, null);
        }

        /// <summary>
        /// This is where it all happens. Grabs a scene that has already been rendered,
        /// and uses postprocess magic to add a glowing bloom effect over the top of it.
        /// </summary>
        /// <param name="Input"></param>
        /// <param name="samplerState"></param>
        /// <returns></returns>
        public Texture2D RenderToFX(Texture2D Input, SamplerState samplerState)
        {
            //Pass 2 : Apply horizental gaussian blur
            this.hGaussianBlurTarget.Begin();
            {
                if (this.forectUpdateH || this.width != (float)Input.Width)
                {
                    this.width = (float)Input.Width;
                    SetBlurEffectParameters(1.0f / width, 0, this.hAmount);
                }

                this.gaussianBlurEffect.CurrentTechnique.Passes[this.CurrentPass].Apply();
                {
                    //Set sampler
                    Persian.GDevice.Textures[0] = Input;
                    if (samplerState != null)
                    {
                        Persian.GDevice.SamplerStates[0] = samplerState;
                    }
                    Persian.Quad.Draw(-Vector2.One, Vector2.One);
                }
                this.hGaussianBlurTarget.End();
            }
            
            //Pass 3 : Apply vertical gaussian blur
            this.vGaussianBlurTarget.Begin();
            {
                if (this.forectUpdateV || this.height != (float)Input.Height)
                {
                    this.height = (float)Input.Height;
                    SetBlurEffectParameters(0, 1.0f / height, this.vAmount);
                }
                this.gaussianBlurEffect.CurrentTechnique.Passes[this.CurrentPass].Apply();
                {
                    Persian.GDevice.Textures[0] = this.hGaussianBlurTarget.Texture2D;
                    if (samplerState != null)
                    {
                        Persian.GDevice.SamplerStates[0] = samplerState;
                    }
                    Persian.Quad.Draw(-Vector2.One, Vector2.One);
                }
                this.vGaussianBlurTarget.End();
            }
            return this.vGaussianBlurTarget.Texture2D;
        }

        /// <summary>
        /// Computes sample weightings and texture coordinate offsets
        /// for one pass of a separable gaussian blur filter.
        /// </summary>
        private void SetBlurEffectParameters(float dx, float dy, float amount)
        {
            // Look up how many samples our gaussian blur effect supports.
            int sampleCount = this.weightsParameter.Elements.Count;

            // Create temporary arrays for computing our filter settings.
            float[] sampleWeights = new float[sampleCount];
            Vector2[] sampleOffsets = new Vector2[sampleCount];

            // The first sample always has a zero offset.
            sampleWeights[0] = ComputeGaussian(0, amount);
            sampleOffsets[0] = new Vector2(0);

            // Maintain a sum of all the weighting values.
            float totalWeights = sampleWeights[0];

            // Add pairs of additional sample taps, positioned
            // along a line in both directions from the center.
            for (int i = 0; i < sampleCount / 2; i++)
            {
                // Store weights for the positive and negative taps.
                float weight = ComputeGaussian(i + 1, amount);

                sampleWeights[i * 2 + 1] = weight;
                sampleWeights[i * 2 + 2] = weight;

                totalWeights += weight * 2;

                // To get the maximum amount of blurring from a limited number of
                // pixel shader samples, we take advantage of the bilinear filtering
                // hardware inside the texture fetch unit. If we position our texture
                // coordinates exactly halfway between two texels, the filtering unit
                // will average them for us, giving two samples for the price of one.
                // This allows us to step in units of two texels per sample, rather
                // than just one at a time. The 1.5 offset kicks things off by
                // positioning us nicely in between two texels.
                float sampleOffset = i * 2 + 1.5f;

                var delta = new Vector2(dx, dy) * sampleOffset;

                // Store texture coordinate offsets for the positive and negative taps.
                sampleOffsets[i * 2 + 1] = delta;
                sampleOffsets[i * 2 + 2] = -delta;
            }

            // Normalize the list of sample weightings, so they will always sum to one.
            for (int i = 0; i < sampleWeights.Length; i++)
            {
                sampleWeights[i] /= totalWeights;
            }

            // Tell the effect about our new filter settings.
            this.weightsParameter.SetValue(sampleWeights);
            this.offsetsParameter.SetValue(sampleOffsets);
        }

        /// <summary>
        /// Evaluates a single point on the gaussian falloff curve.
        /// Used for setting up the blur filter weightings.
        /// </summary>
        private float ComputeGaussian(float n, float amount)
        {
            return (float)((1.0 / Math.Sqrt(2 * Math.PI * amount)) *
                           Math.Exp(-(n * n) / (2 * amount * amount)));
        }

        #endregion

        #region Dispose

        /// <summary>
        /// Unload your graphics content.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (!disposing || isDisposed) return;

            SystemMemory.SafeDispose(this.gaussianBlurEffect);
            SystemMemory.SafeDispose(this.weightsParameter);
            SystemMemory.SafeDispose(this.offsetsParameter);

            SystemMemory.SafeDispose(this.hGaussianBlurTarget);
            SystemMemory.SafeDispose(this.vGaussianBlurTarget);

            base.Dispose(disposing);
        }

        #endregion
    }
}
