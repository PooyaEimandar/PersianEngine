/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : GodRay.cs
 * File Description : The godRay
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 8/9/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Graphics.Lights;
using PersianCore.Graphics.Lights.PrepassTechnique;
using System;
using System.ComponentModel;

namespace PersianCore.Graphics.PostProcessing
{
    public class GodRay : Node
    {
        #region Fields & Properties

        RenderTarget resultTarget;
        Effect effect;
        EffectParameter colorBufferParam;
        EffectParameter screenResParam;
        EffectParameter saturationParam;
        EffectParameter linearColorBalanceParam;
        EffectParameter linearExposureParam;
        EffectParameter contrastParam;
        EffectParameter pixelSizeParam;
        EffectParameter halfPixelParam;
        EffectParameter halfDepthTextureParam;
        EffectParameter rgbShaftTextureParam;
        EffectParameter lightCenterParam;
        EffectParameter scaleParam;
        EffectParameter intensityParam;
        EffectParameter spreadParam;
        EffectParameter tintParam;
        EffectParameter decayParam;
        EffectParameter blendParam;
        EffectParameter textureAspectRatioParam;
        
        Vector4 linearColorBalance;
        
        float blend;
        [Description("Blend of godRay")]
        [Category("GodRay")]
        public float Blend
        {
            get { return this.blend; }
            set
            {
                if (this.blend != value)
                {
                    this.blend = value;
                    if (this.blendParam != null)
                    {
                        this.blendParam.SetValue(value);
                    }
                }
            }
        }

        float scale;
        [Description("Scale of godRay")]
        [Category("GodRay")]
        public float Scale
        {
            get { return this.scale; }
            set
            {
                if (this.scale != value)
                {
                    this.scale = value;
                    if (this.scaleParam != null)
                    {
                        this.scaleParam.SetValue(value);
                    }
                }
            }
        }

        float intensity;
        [Description("Intensity of godRay")]
        [Category("GodRay")]
        public float Intensity
        {
            get { return this.intensity; }
            set
            {
                if (this.intensity != value)
                {
                    this.intensity = value;
                }
            }
        }

        float spread;
        [Description("Spread of godRay")]
        [Category("GodRay")]
        public float Spread
        {
            get { return this.spread; }
            set
            {
                if (this.spread != value)
                {
                    this.spread = value;
                    if (this.spreadParam != null)
                    {
                        this.spreadParam.SetValue(value);
                    }
                }
            }
        }

        float decay;
        [Browsable(false)]
        public float Decay
        {
            get { return this.decay; }
            set
            {
                if (this.decay != value)
                {
                    this.decay = value;
                    if (this.decayParam != null)
                    {
                        this.decayParam.SetValue(value);
                    }
                }
            }
        }
        
        Vector2 lightCenter;
        [Description("Center of the light")]
        [Category("GodRay")]
        public Vector2 LightCenter
        {
            get { return this.lightCenter; }
            set
            {
                if (this.lightCenter != value)
                {
                    this.lightCenter = value;
                    if (this.lightCenterParam != null)
                    {
                        this.lightCenterParam.SetValue(value);
                    }
                }
            }
        }

        float saturation;
        [Description("Saturation of godRay")]
        [Category("GodRay")]
        public float Saturation
        {
            get { return this.saturation; }
            set
            {
                if (this.saturation != value)
                {
                    this.saturation = value;
                    if (this.saturationParam != null)
                    {
                        this.saturationParam.SetValue(value);
                    }
                }
            }
        }

        float contrast;
        [Description("Contrast of godRay")]
        [Category("GodRay")]
        public float Contrast
        {
            get { return this.contrast; }
            set
            {
                if (this.contrast != value)
                {
                    this.contrast = value;
                    if (this.contrastParam != null)
                    {
                        this.contrastParam.SetValue(value);
                    }
                }
            }
        }

        float exposure;
        [Description("Exposure of godRay")]
        [Category("GodRay")]
        public float Exposure
        {
            get { return this.exposure; }
            set
            {
                if (this.exposure != value)
                {
                    this.exposure = value;
                    if (this.linearExposureParam != null)
                    {
                        this.linearExposureParam.SetValue((float)Math.Pow(2, value));
                    }
                }
            }
        }

        Color colorBalance;
        [Description("Color balance of godRay")]
        [Category("GodRay")]
        public Color ColorBalance
        {
            get { return this.colorBalance; }
            set
            {
                if (this.colorBalance != value)
                {
                    this.colorBalance = value;
                    this.linearColorBalance.X = (float)Math.Pow(value.R / 255.0f, 2.2f);
                    this.linearColorBalance.Y = (float)Math.Pow(value.G / 255.0f, 2.2f);
                    this.linearColorBalance.Z = (float)Math.Pow(value.B / 255.0f, 2.2f);
                    if (this.linearColorBalanceParam != null)
                    {
                        this.linearColorBalanceParam.SetValue(this.linearColorBalance);
                    }
                }
            }
        }

        Color tint;
        [Description("Tint of godRay")]
        [Category("GodRay")]
        public Color Tint
        {
            get { return this.tint; }
            set
            {
                if (this.tint != value)
                {
                    this.tint = value;
                    if (this.tintParam != null)
                    {
                        this.tintParam.SetValue(value.ToVector4());
                    }
                }
            }
        }

        #endregion

        #region Constructor/Destructor

        public GodRay()
        {
            this.linearColorBalance = Vector4.One;
        }

        ~GodRay()
        {
        }

        #endregion

        #region Load

        public void Load(ContentManager Content)
        {
            var multiSampleCount = CoreShared.SupportedGraphics.multiSampleCount;
            var width = Persian.GDevice.PresentationParameters.BackBufferWidth;
            var height = Persian.GDevice.PresentationParameters.BackBufferHeight;
            this.resultTarget = new RenderTarget(
                width,
                height,
                false,
                SurfaceFormat.Color,
                DepthFormat.None,
                multiSampleCount,
                RenderTargetUsage.DiscardContents);

            var path = @"Shaders\PostProcessing\";
            this.effect = Content.Load<Effect>(string.Format(@"{0}{1}GodRay", CoreShared.PrePathContent, path));

            //ExtractParameters
            this.colorBufferParam = this.effect.Parameters["ColorBuffer"];
            this.screenResParam = this.effect.Parameters["ScreenRes"];
            this.saturationParam = this.effect.Parameters["Saturation"];
            this.linearColorBalanceParam = this.effect.Parameters["LinearColorBalance"];
            this.linearExposureParam = this.effect.Parameters["LinearExposure"];
            this.contrastParam = this.effect.Parameters["Contrast"];

            this.linearColorBalanceParam.SetValue(this.linearColorBalance);
            this.saturationParam.SetValue(this.saturation);
            this.contrastParam.SetValue(this.contrast);
            this.linearExposureParam.SetValue((float)Math.Pow(2, this.exposure));

            this.pixelSizeParam = this.effect.Parameters["PixelSize"];
            this.halfPixelParam = this.effect.Parameters["HalfPixel"];
            this.halfDepthTextureParam = this.effect.Parameters["DepthBuffer"];
            this.rgbShaftTextureParam = this.effect.Parameters["ShaftBuffer"];

            this.scaleParam = this.effect.Parameters["Scale"];
            this.intensityParam = this.effect.Parameters["Intensity"];
            this.spreadParam = this.effect.Parameters["Spread"];
            this.tintParam = this.effect.Parameters["ShaftTint"];
            this.decayParam = this.effect.Parameters["Decay"];
            this.lightCenterParam = this.effect.Parameters["LightCenter"];
            this.blendParam = this.effect.Parameters["Blend"];

            this.scaleParam.SetValue(this.scale);
            this.intensityParam.SetValue(this.intensity);
            this.spreadParam.SetValue(this.spread);
            this.tintParam.SetValue(this.tint.ToVector4());
            this.decayParam.SetValue(this.decay);

            this.textureAspectRatioParam = this.effect.Parameters["TextureAspectRatio"];
            Initialize();
        }

        private void Initialize()
        {
            this.Blend = 0.51f;
            this.Scale = 2;
            this.Intensity = 3.95f;
            this.Spread = 0.2f;
            this.Decay = 0.0f;
            this.Tint = Color.White;
            this.LightCenter = Vector2.Zero;
            this.Saturation = 1.02f;
            this.Contrast = 1.17f;
            this.Exposure = -0.45f;
            this.ColorBalance = Color.White;
        }

        #endregion

        #region Draw

        public Texture2D RenderPostFx(Light light, Texture2D Input, LBuffers lBuffers, RenderTarget2D halfDepth)
        {
            var GDevice = Persian.GDevice;

            Render(light);

            this.effect.CurrentTechnique = this.effect.Techniques[0];

            GDevice.BlendState = BlendState.Opaque;
            GDevice.DepthStencilState = DepthStencilState.None;
            GDevice.RasterizerState = RasterizerState.CullNone;

            var width = (float)Input.Width;
            var height = (float)Input.Height;

            Vector2 pixelSize;
            //render to a half-res buffer
            GDevice.SetRenderTarget(lBuffers.quarterBuffer0);
            {
                this.colorBufferParam.SetValue(Input);
                this.halfDepthTextureParam.SetValue(halfDepth);
                this.textureAspectRatioParam.SetValue(height / width);
                // Convert to rgb first, so we have linear filtering
                effect.CurrentTechnique = effect.Techniques[0];

                pixelSize = new Vector2(1.0f / width, 1.0f / height);
                pixelSizeParam.SetValue(pixelSize);
                halfPixelParam.SetValue(pixelSize * 0.5f);

                effect.CurrentTechnique.Passes[0].Apply();
                {
                    Persian.Quad.Draw(-Vector2.One, Vector2.One);
                }
                GDevice.SetRenderTarget(null);
            }

            GDevice.SetRenderTarget(lBuffers.quarterBuffer1);
            {
                pixelSize = new Vector2(1.0f / (float)lBuffers.quarterBuffer0.Width,
                    1.0f / (float)lBuffers.quarterBuffer0.Height);
                pixelSizeParam.SetValue(pixelSize);
                halfPixelParam.SetValue(pixelSize * 0.5f);
                effect.CurrentTechnique = effect.Techniques[1];
                rgbShaftTextureParam.SetValue(lBuffers.quarterBuffer0);

                effect.CurrentTechnique.Passes[0].Apply();
                {
                    Persian.Quad.Draw(-Vector2.One, Vector2.One);
                }
                GDevice.SetRenderTarget(null);
            }

            this.resultTarget.Begin();
            {
                pixelSize = new Vector2(1.0f / width, 1.0f / height);
                pixelSizeParam.SetValue(pixelSize);
                halfPixelParam.SetValue(pixelSize * 0.5f);

                GDevice.RasterizerState = RasterizerState.CullNone;
                GDevice.DepthStencilState = DepthStencilState.None;
                GDevice.BlendState = BlendState.Opaque;

                rgbShaftTextureParam.SetValue(lBuffers.quarterBuffer1);
                effect.CurrentTechnique = effect.Techniques[2];
                effect.CurrentTechnique.Passes[0].Apply();
                {
                    Persian.Quad.Draw(-Vector2.One, Vector2.One);
                }
                this.resultTarget.End();
            }

            return this.resultTarget.Texture2D;
        }

        private void Render(Light MainLight)
        {
            // we need to convert the light position to screen space. This algorithm works only 
            // for directional lights
            var pos = Persian.Camera.World.Translation - MainLight.World.Forward * 10;
            var pos4 = new Vector4(pos, 1);
            pos4 = Vector4.Transform(pos4, Persian.Camera.ViewProjection);

            pos.X = pos4.X / pos4.W;
            // flip Y 
            pos.Y = -pos4.Y / pos4.W;
            pos.Z = pos4.Z / pos4.W;

            // do some hacks to make the intensity goes to zero when the light is outside the screen
            var _intensity = 1 - (float)Math.Sqrt(pos.X * pos.X + pos.Y * pos.Y) * 0.15f;
            _intensity = Math.Min(1, _intensity);
            _intensity = Math.Max(0, _intensity);
            if (pos.Z < 0 || pos.Z > 1)
            {
                this.intensityParam.SetValue(0);
            }
            else
            {
                // make the intensity function more narrow (intensity^3)
                this.intensityParam.SetValue(this.intensity * (_intensity * _intensity * _intensity));
            }
            this.LightCenter = new Vector2(pos.X, pos.Y);
        }

        #endregion

        #region Dispose

        protected override void Dispose(bool disposing)
        {
            if (!disposing || isDisposed) return;
            
            SystemMemory.SafeDispose(this.effect);
            SystemMemory.SafeDispose(this.colorBufferParam);
            SystemMemory.SafeDispose(this.screenResParam);
            SystemMemory.SafeDispose(this.saturationParam);
            SystemMemory.SafeDispose(this.linearColorBalanceParam);
            SystemMemory.SafeDispose(this.linearExposureParam);
            SystemMemory.SafeDispose(this.contrastParam);
            SystemMemory.SafeDispose(this.pixelSizeParam);
            SystemMemory.SafeDispose(this.halfPixelParam);
            SystemMemory.SafeDispose(this.halfDepthTextureParam);
            SystemMemory.SafeDispose(this.rgbShaftTextureParam);
            SystemMemory.SafeDispose(this.lightCenterParam);
            SystemMemory.SafeDispose(this.scaleParam);
            SystemMemory.SafeDispose(this.intensityParam);
            SystemMemory.SafeDispose(this.spreadParam);
            SystemMemory.SafeDispose(this.tintParam);
            SystemMemory.SafeDispose(this.decayParam);
            SystemMemory.SafeDispose(this.blendParam);
            SystemMemory.SafeDispose(this.textureAspectRatioParam);

            base.Dispose(disposing);
        }

        #endregion
    }
}