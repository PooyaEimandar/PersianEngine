/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : ParticleSystem.cs
 * File Description : Particle system modified based on Particle system of Microsoft XNA (http://xbox.create.msdn.com/en-US/education/catalog/sample/particle_3d)
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 5/18/2013
 * Comment          : Add effect parameters and bind the proprties to parameters
 */

using Debugger;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Graphics.PackedVector;
using PersianSettings;
using System;
using System.ComponentModel;

namespace PersianCore.Graphics.Particles
{
    /// <summary>
    /// The main component in charge of displaying particles.
    /// </summary>
    public class ParticleSystem : Node
    {
        #region Fields & Properties

        static Random random = new Random();
       
        bool ForceResizing;
        GraphicsDevice GDevice;
        string settingsName;
        ParticleSet settings;
        Effect particleEffect;
        EffectParameter effectViewParameter;
        EffectParameter effectProjectionParameter;
        EffectParameter effectViewportScaleParameter;
        EffectParameter effectTimeParameter;
        EffectParameter effectDurationParam;
        EffectParameter effectDurationRandomnessParam;
        EffectParameter effectGravityParam;
        EffectParameter effectEndVelocityParam;
        EffectParameter effectMinColorParam;
        EffectParameter effectMaxColorParam;
        EffectParameter effectRotateSpeedParam;
        EffectParameter effectStartSizeParam;
        EffectParameter effectEndSizeParam;
        EffectParameter intensityParam;

        ParticleVertex[] particles;
        DynamicVertexBuffer vertexBuffer;
        DynamicIndexBuffer indexBuffer;
        float currentTime;
        float _totalTime;
        //timer used to spawn new particles
        float accumTime;
        // Count how many times Draw has been called. This is used to know
        // when it is safe to retire old particles back into the free list.
        int drawCounter;
        BoundingBox localBoundingBox;

        public string ID { get; set; }
        
        [DoNotSave]
        [Browsable(false)]
        public BoundingBox BoundingBox
        {
            get
            {
                return this.localBoundingBox;
            }
        }
        BoundingBox globalBoundingBox;
        Matrix globalTransform;

        [DoNotSave]
        [Browsable(false)]
        public Matrix GlobalTransform
        {
            get
            {
                return globalTransform;
            }
            set
            {
                globalTransform = value;
                Bounding.TransformBoundingBox(ref localBoundingBox, ref globalTransform, out globalBoundingBox);
            }
        }

        // The particles array and vertex buffer are treated as a circular queue.
        // Initially, the entire contents of the array are free, because no particles
        // are in use. When a new particle is created, this is allocated from the
        // beginning of the array. If more than one particle is created, these will
        // always be stored in a consecutive block of array elements. Because all
        // particles last for the same amount of time, old particles will always be
        // removed in order from the start of this active particle region, so the
        // active and free regions will never be intermingled. Because the queue is
        // circular, there can be times when the active particle region wraps from the
        // end of the array back to the start. The queue uses modulo arithmetic to
        // handle these cases. For instance with a four entry queue we could have:
        //
        //      0
        //      1 - first active particle
        //      2 
        //      3 - first free particle
        //
        // In this case, particles 1 and 2 are active, while 3 and 4 are free.
        // Using modulo arithmetic we could also have:
        //
        //      0
        //      1 - first free particle
        //      2 
        //      3 - first active particle
        //
        // Here, 3 and 0 are active, while 1 and 2 are free.
        //
        // But wait! The full story is even more complex.
        //
        // When we create a new particle, we add them to our managed particles array.
        // We also need to copy this new data into the GPU vertex buffer, but we don't
        // want to do that straight away, because setting new data into a vertex buffer
        // can be an expensive operation. If we are going to be adding several particles
        // in a single frame, it is faster to initially just store them in our managed
        // array, and then later upload them all to the GPU in one single call. So our
        // queue also needs a region for storing new particles that have been added to
        // the managed array but not yet uploaded to the vertex buffer.
        //
        // Another issue occurs when old particles are retired. The CPU and GPU run
        // asynchronously, so the GPU will often still be busy drawing the previous
        // frame while the CPU is working on the next frame. This can cause a
        // synchronization problem if an old particle is retired, and then immediately
        // overwritten by a new one, because the CPU might try to change the contents
        // of the vertex buffer while the GPU is still busy drawing the old data from
        // it. Normally the graphics driver will take care of this by waiting until
        // the GPU has finished drawing inside the VertexBuffer.SetData call, but we
        // don't want to waste time waiting around every time we try to add a new
        // particle! To avoid this delay, we can specify the SetDataOptions.NoOverwrite
        // flag when we write to the vertex buffer. This basically means "I promise I
        // will never try to overwrite any data that the GPU might still be using, so
        // you can just go ahead and update the buffer straight away". To keep this
        // promise, we must avoid reusing vertices immediately after they are drawn.
        //
        // So in total, our queue contains four different regions:
        //
        // Vertices between firstActiveParticle and firstNewParticle are actively
        // being drawn, and exist in both the managed particles array and the GPU
        // vertex buffer.
        //
        // Vertices between firstNewParticle and firstFreeParticle are newly created,
        // and exist only in the managed particles array. These need to be uploaded
        // to the GPU at the start of the next draw call.
        //
        // Vertices between firstFreeParticle and firstRetiredParticle are free and
        // waiting to be allocated.
        //
        // Vertices between firstRetiredParticle and firstActiveParticle are no longer
        // being drawn, but were drawn recently enough that the GPU could still be
        // using them. These need to be kept around for a few more frames before they
        // can be reallocated.

        int firstActiveParticle;
        int firstNewParticle;
        int firstFreeParticle;
        int firstRetiredParticle;

        float sqrDistanceToCam;
        [DoNotSave]
        [Browsable(false)]
        public float SqrDistanceToCam
        {
            get
            {
                return this.sqrDistanceToCam;
            }
        }

        [DoNotSave]
        [Browsable(false)]
        public bool isSelected
        {
            get;
            set;
        }

        #region Appearance's Category

        [Description("Intensity for the particle")]
        [Category("Appearance")]
        public float Intensity
        {
            get
            {
                return this.settings.Intensity;
            }
            set
            {
                this.settings.Intensity = value;
                if (this.intensityParam != null)
                {
                    this.intensityParam.SetValue(value);
                }
            }
        }

        [Description("Always visible for the particle")]
        [Category("Appearance")]
        public bool AlwaysVisible { get; set; }

        bool enable;
        [Description("Enable or disable particle")]
        [Category("Appearance")]
        public bool Enable
        {
            get
            {
                return this.enable;
            }
            set
            {
                this.enable = value;
            }
        }
        [Description("Texture name of particle")]
        [Category("Appearance")]
        public string TextureName
        {
            get
            {
                return this.settings.TextureName;
            }
            set
            {
                this.settings.TextureName = value;
            }
        }
        [Description("Max particles of particle")]
        [Category("Appearance")]
        public int MaxParticles
        {
            get
            {
                return this.settings.MaxParticles;
            }
            set
            {
                if (this.settings.MaxParticles != value)
                {
                    this.settings.MaxParticles = value;
                    this.ForceResizing = true;
                }
            }
        }
        [Description("Max Color of particle")]
        [Category("Appearance")]
        public Vector4 MaxColor
        {
            get
            {
                return this.settings.MaxColor;
            }
            set
            {
                if (this.settings.MaxColor != value)
                {
                    this.settings.MaxColor = value;
                    if (this.effectMaxColorParam != null)
                    {
                        this.effectMaxColorParam.SetValue(this.settings.MaxColor);
                    }
                }
            }
        }
        [Description("Min Color of particle")]
        [Category("Appearance")]
        public Vector4 MinColor
        {
            get
            {
                return this.settings.MinColor;
            }
            set
            {
                if (this.settings.MinColor != value)
                {
                    this.settings.MinColor = value;
                    if (this.effectMinColorParam != null)
                    {
                        this.effectMinColorParam.SetValue(this.settings.MinColor);
                    }
                }
            }
        }

        #endregion

        #region Duration's Category

        [Description("Duration lifetime of particle")]
        [Category("Duration")]
        public TimeSpan Duration
        {
            get
            {
                return this.settings.Duration;
            }
            set
            {
                if (this.settings.Duration != value)
                {
                    this.settings.Duration = value;
                    if (this.effectDurationParam != null)
                    {
                        this.effectDurationParam.SetValue((float)this.settings.Duration.TotalSeconds);
                    }
                }
            }
        }
        [Description("Duration randomness of particle")]
        [Category("Duration")]
        public float DurationRandomness
        {
            get
            {
                return this.settings.DurationRandomness;
            }
            set
            {
                if (this.settings.DurationRandomness != value)
                {
                    this.settings.DurationRandomness = value;
                    if (this.effectDurationRandomnessParam != null)
                    {
                        this.effectDurationRandomnessParam.SetValue(this.settings.DurationRandomness);
                    }
                }
            }
        }

        #endregion

        #region Emission Category

        bool canEmit;
        [Description("Enable or disable particle's emitting")]
        [Category("Emission")]
        public bool CanEmit
        {
            get
            {
                return this.canEmit;
            }
            set
            {
                this.canEmit = value;
            }
        }
        [Description("Emission rate of particle")]
        [Category("Emission")]
        public float EmissionRate
        {
            get
            {
                return this.settings.EmissionRate;
            }
            set
            {
                this.settings.EmissionRate = value;
            }
        }
        [Description("Emitter Velocity Sensitivity of particle")]
        [Category("Emission")]
        public float EmitterVelocitySensitivity
        {
            get
            {
                return this.settings.EmitterVelocitySensitivity;
            }
            set
            {
                this.settings.EmitterVelocitySensitivity = value;
            }
        }

        #endregion

        #region Physic's Category

        [Description("Position of particle")]
        [Category("Physic")]
        public Vector3 Position
        {
            get
            {
                return this.globalTransform.Translation;
            }
            set
            {
                this.globalTransform.Translation = value;
            }
        }

        [Description("Scale of particle")]
        [Category("Physic")]
        public Vector2 Scale
        {
            get
            {
                return this.settings.Scale;
            }
            set
            {
                this.settings.Scale = value;
            }
        }

        [Description("End Velocity of particle")]
        [Category("Physic")]
        public float EndVelocity
        {
            get
            {
                return this.settings.EndVelocity;
            }
            set
            {
                if (this.settings.EndVelocity != value)
                {
                    this.settings.EndVelocity = value;
                    if (this.effectEndVelocityParam != null)
                    {
                        this.effectEndVelocityParam.SetValue(this.settings.EndVelocity);
                    }
                }
            }
        }

        [Description("Gravity of particle")]
        [Category("Physic")]
        public Vector3 Gravity
        {
            get
            {
                return this.settings.Gravity;
            }
            set
            {
                if (this.settings.Gravity != value)
                {
                    this.settings.Gravity = value;
                    if (this.effectGravityParam != null)
                    {
                        this.effectGravityParam.SetValue(this.settings.Gravity);
                    }
                }
            }
        }

        [Description("Max end size of particle")]
        [Category("Physic")]
        public float MaxEndSize
        {
            get
            {
                return this.settings.MaxEndSize;
            }
            set
            {
                this.settings.MaxEndSize = value;
            }
        }

        [Description("Min end size of particle")]
        [Category("Physic")]
        public float MinEndSize
        {
            get
            {
                return this.settings.MinEndSize;
            }
            set
            {
                if (this.settings.MinEndSize != value)
                {
                    this.settings.MinEndSize = value;
                    if (this.effectEndSizeParam != null)
                    {
                        this.effectEndSizeParam.SetValue(new Vector2(this.settings.MinEndSize, this.settings.MaxEndSize));
                    }
                }
            }
        }

        [Description("Max horizontal velocity of particle")]
        [Category("Physic")]
        public float MaxHorizontalVelocity
        {
            get
            {
                return this.settings.MaxHorizontalVelocity;
            }
            set
            {
                this.settings.MaxHorizontalVelocity = value;
            }
        }
        [Description("Min horizontal velocity of particle")]
        [Category("Physic")]
        public float MinHorizontalVelocity
        {
            get
            {
                return this.settings.MinHorizontalVelocity;
            }
            set
            {
                this.settings.MinHorizontalVelocity = value;
            }
        }
        [Description("Max rotate speed of particle")]
        [Category("Physic")]
        public float MaxRotateSpeed
        {
            get
            {
                return this.settings.MaxRotateSpeed;
            }
            set
            {
                if (this.settings.MaxRotateSpeed != value)
                {
                    this.settings.MaxRotateSpeed = value;
                    if (this.effectRotateSpeedParam != null)
                    {
                        this.effectRotateSpeedParam.SetValue(new Vector2(this.settings.MinRotateSpeed, this.settings.MaxRotateSpeed));
                    }
                }
            }
        }

        [Description("Min rotate speed of particle")]
        [Category("Physic")]
        public float MinRotateSpeed
        {
            get
            {
                return this.settings.MinRotateSpeed;
            }
            set
            {
                if (this.settings.MinRotateSpeed != value)
                {
                    this.settings.MinRotateSpeed = value;
                    if (this.effectRotateSpeedParam != null)
                    {
                        this.effectRotateSpeedParam.SetValue(new Vector2(this.settings.MinRotateSpeed, this.settings.MaxRotateSpeed));
                    }
                }
            }
        }

        [Description("Max start size of particle")]
        [Category("Physic")]
        public float MaxStartSize
        {
            get
            {
                return this.settings.MaxStartSize;
            }
            set
            {
                if (this.settings.MaxStartSize != value)
                {
                    this.settings.MaxStartSize = value;
                    if (this.effectStartSizeParam != null)
                    {
                        this.effectStartSizeParam.SetValue(new Vector2(this.settings.MinStartSize, this.settings.MaxStartSize));
                    }
                }
            }
        }

        [Description("Min start size of particle")]
        [Category("Physic")]
        public float MinStartSize
        {
            get
            {
                return this.settings.MinStartSize;
            }
            set
            {
                if (this.settings.MinStartSize != value)
                {
                    this.settings.MinStartSize = value;
                    if (this.effectStartSizeParam != null)
                    {
                        this.effectStartSizeParam.SetValue(new Vector2(this.settings.MinStartSize, this.settings.MaxStartSize));
                    }
                }
            }
        }

        [Description("Max vertical velocity of particle")]
        [Category("Physic")]
        public float MaxVerticalVelocity
        {
            get
            {
                return this.settings.MaxVerticalVelocity;
            }
            set
            {
                this.settings.MaxVerticalVelocity = value;
            }
        }

        [Description("Min vertical velocity of particle")]
        [Category("Physic")]
        public float MinVerticalVelocity
        {
            get
            {
                return this.settings.MinVerticalVelocity;
            }
            set
            {
                this.settings.MinVerticalVelocity = value;
            }
        }

        #endregion

        #endregion

        #region Constructor/Destructor

        public ParticleSystem()
            : this(string.Empty)
        {
        }

        public ParticleSystem(string settingsName)
        {
            this.ID = "Particle System";
            this.settings = new ParticleSet();
            this.enable = true;
            this.canEmit = true;
            this.globalTransform = Matrix.Identity;
            float FarClip = Persian.Camera.FarClip;
            this.localBoundingBox = new BoundingBox(-Vector3.One * FarClip, Vector3.One * FarClip);
            this.globalBoundingBox = new BoundingBox(-Vector3.One * FarClip, Vector3.One * FarClip);
            this.settingsName = settingsName;
        }

        ~ParticleSystem()
        {
        }

        #endregion

        #region Load

        public void Load(GraphicsDevice GDevice, ref string HResult)
        {
            this.GDevice = GDevice;
            this.particleEffect = Persian.EngineContent.Load<Effect>(@"Shaders\Environments\ParticleEffect");
            ResizeBuffers();
            LoadParticleEffect();
        }

        private void LoadParticleEffect()
        {
            // If we have several particle systems, the content manager will return
            // a single shared effect instance to them all. But we want to preconfigure
            // the effect with parameters that are specific to this particular
            // particle system. By cloning the effect, we prevent one particle system
            // from stomping over the parameter settings of another.

            particleEffect = particleEffect.Clone();

            var parameters = particleEffect.Parameters;

            // Look up shortcuts for parameters that change every frame.
            effectViewParameter = parameters["View"];
            effectProjectionParameter = parameters["Projection"];
            effectViewportScaleParameter = parameters["ViewportScale"];
            effectTimeParameter = parameters["CurrentTime"];

            this.effectDurationParam = parameters["Duration"];
            this.effectDurationRandomnessParam = parameters["DurationRandomness"];
            this.effectGravityParam = parameters["Gravity"];
            this.effectEndVelocityParam = parameters["EndVelocity"];
            this.effectMinColorParam = parameters["MinColor"];
            this.effectMaxColorParam = parameters["MaxColor"];
            this.effectRotateSpeedParam = parameters["RotateSpeed"];
            this.effectStartSizeParam = parameters["StartSize"];
            this.effectEndSizeParam = parameters["EndSize"];
            this.intensityParam = parameters["Intensity"];

            // Set the values of parameters that do not change.
            effectDurationParam.SetValue((float)this.settings.Duration.TotalSeconds);
            effectDurationRandomnessParam.SetValue(this.settings.DurationRandomness);
            effectGravityParam.SetValue(this.settings.Gravity);
            effectEndVelocityParam.SetValue(this.settings.EndVelocity);
            effectMinColorParam.SetValue(this.settings.MinColor);
            effectMaxColorParam.SetValue(this.settings.MaxColor);
            effectRotateSpeedParam.SetValue(new Vector2(this.settings.MinRotateSpeed, this.settings.MaxRotateSpeed));
            effectStartSizeParam.SetValue(new Vector2(this.settings.MinStartSize, this.settings.MaxStartSize));
            effectEndSizeParam.SetValue(new Vector2(this.settings.MinEndSize, this.settings.MaxEndSize));
            this.intensityParam.SetValue(this.settings.Intensity);

            ChangeTexture(null);
        }

        #endregion

        #region Methods

        public void ChangeTexture(Texture2D texure2D)
        {
            if (texure2D == null)
            {
                AssetsManager.Texture2DFromFile(
                    Persian.GDevice,
                    Persian.EngineContentDir + @"\" + this.settings.TextureName,
                    ref texure2D);
            }
            if (texure2D != null)
            {
                particleEffect.Parameters["Texture"].SetValue(texure2D);
            }
        }

        private void ResizeBuffers()
        {
            if (particles != null)
            {
                Array.Resize(ref this.particles, this.settings.MaxParticles * 4);
            }
            else
            {
                this.particles = new ParticleVertex[this.settings.MaxParticles * 4];
            }
            for (int i = 0; i < this.settings.MaxParticles; i++)
            {
                particles[i * 4 + 0].Corner = new Short2(-1, -1);
                particles[i * 4 + 1].Corner = new Short2(1, -1);
                particles[i * 4 + 2].Corner = new Short2(1, 1);
                particles[i * 4 + 3].Corner = new Short2(-1, 1);
            }
            vertexBuffer = new DynamicVertexBuffer(this.GDevice, ParticleVertex.VertexDeclaration, this.settings.MaxParticles * 4, BufferUsage.WriteOnly);
            ushort[] indices = new ushort[this.settings.MaxParticles * 6];
            for (int i = 0; i < this.settings.MaxParticles; i++)
            {
                indices[i * 6 + 0] = (ushort)(i * 4 + 0);
                indices[i * 6 + 1] = (ushort)(i * 4 + 1);
                indices[i * 6 + 2] = (ushort)(i * 4 + 2);

                indices[i * 6 + 3] = (ushort)(i * 4 + 0);
                indices[i * 6 + 4] = (ushort)(i * 4 + 2);
                indices[i * 6 + 5] = (ushort)(i * 4 + 3);
            }
            indexBuffer = new DynamicIndexBuffer(this.GDevice, typeof(ushort), indices.Length, BufferUsage.WriteOnly);
            indexBuffer.SetData(indices);

            //compute an approximated bounding box
            float maxVel = Math.Max(Math.Max(this.settings.MaxHorizontalVelocity, this.settings.MinHorizontalVelocity), Math.Max(this.settings.MaxVerticalVelocity, this.settings.MinVerticalVelocity));
            float minVel = Math.Min(Math.Min(this.settings.MaxHorizontalVelocity, this.settings.MinHorizontalVelocity), Math.Min(this.settings.MaxVerticalVelocity, this.settings.MinVerticalVelocity));
            Vector3 max = Vector3.One * (this.settings.MaxEndSize / 2 + (float)(Math.Abs(this.settings.Duration.TotalSeconds * maxVel)));
            Vector3 min = -Vector3.One * (this.settings.MaxEndSize / 2 + (float)(Math.Abs(this.settings.Duration.TotalSeconds * minVel)));
            localBoundingBox.Min = min;
            localBoundingBox.Max = max;

            Bounding.TransformBoundingBox(ref localBoundingBox, ref globalTransform, out globalBoundingBox);

            Restart();
        }

        public void Restart()
        {
            currentTime = _totalTime = accumTime = 0;
            drawCounter = 0;
            canEmit = true;
            firstActiveParticle = firstNewParticle = firstFreeParticle = firstRetiredParticle = 0;
        }

        public bool HasActiveParticles()
        {
            return firstActiveParticle != firstFreeParticle || (_totalTime < this.settings.Duration.TotalSeconds || this.settings.Duration.TotalSeconds < 0);
        }

        /// <summary>
        /// Adds a new particle to the system.
        /// </summary>
        public void AddParticle()
        {
            Vector3 position = globalTransform.Translation;
            Vector3 velocity = globalTransform.Forward;
            // Figure out where in the circular queue to allocate the new particle.
            int nextFreeParticle = firstFreeParticle + 1;

            if (nextFreeParticle >= this.settings.MaxParticles)
                nextFreeParticle = 0;

            // If there are no free particles, we just have to give up.
            if (nextFreeParticle == firstRetiredParticle)
                return;

            // Adjust the input velocity based on how much
            // this particle system wants to be affected by it.
            velocity *= this.settings.EmitterVelocitySensitivity;

            // Add in some random amount of horizontal velocity.
            float horizontalVelocity = MathHelper.Lerp(this.settings.MinHorizontalVelocity, this.settings.MaxHorizontalVelocity, (float)random.NextDouble());

            double horizontalAngle = random.NextDouble() * MathHelper.TwoPi;

            velocity.X += horizontalVelocity * (float)Math.Cos(horizontalAngle);
            velocity.Z += horizontalVelocity * (float)Math.Sin(horizontalAngle);

            // Add in some random amount of vertical velocity.
            velocity.Y += MathHelper.Lerp(this.settings.MinVerticalVelocity, this.settings.MaxVerticalVelocity, (float)random.NextDouble());

            // Choose four random control values. These will be used by the vertex
            // shader to give each particle a different size, rotation, and color.
            Color randomValues = new Color((byte)random.Next(255),
                                           (byte)random.Next(255),
                                           (byte)random.Next(255),
                                           (byte)random.Next(255));

            // Fill in the particle vertex structure.
            for (int i = 0; i < 4; i++)
            {
                particles[firstFreeParticle * 4 + i].Position = position;
                particles[firstFreeParticle * 4 + i].Velocity = velocity;
                particles[firstFreeParticle * 4 + i].Random = randomValues;
                particles[firstFreeParticle * 4 + i].Time = currentTime;
            }

            firstFreeParticle = nextFreeParticle;
        }

        #endregion

        #region Update

        public void Update(float deltaTime)
        {
            if (!enable) return;

            if (this.ForceResizing)
            {
                this.ForceResizing = false;
                ResizeBuffers();
            }

            this.sqrDistanceToCam = Vector3.DistanceSquared(Persian.Camera.World.Translation, this.globalTransform.Translation);

            currentTime += deltaTime;
            _totalTime += deltaTime;
            if (this.settings.EmissionRate > 0 && canEmit)
            {
                accumTime += deltaTime;
                float emissionTime = 1.0f / this.settings.EmissionRate;
                while (accumTime > emissionTime)
                {
                    AddParticle();
                    accumTime -= emissionTime;
                }
            }

            RetireActiveParticles();
            FreeRetiredParticles();

            // If we let our timer go on increasing for ever, it would eventually
            // run out of floating point precision, at which point the particles
            // would render incorrectly. An easy way to prevent this is to notice
            // that the time value doesn't matter when no particles are being drawn,
            // so we can reset it back to zero any time the active queue is empty.

            if (firstActiveParticle == firstFreeParticle)
            {
                currentTime = 0;
            }

            if (firstRetiredParticle == firstActiveParticle)
            {
                drawCounter = 0;
            }
        }

        /// <summary>
        /// Helper for checking when active particles have reached the end of
        /// their life. It moves old particles from the active area of the queue
        /// to the retired section.
        /// </summary>
        private void RetireActiveParticles()
        {
            float particleDuration = (float)this.settings.Duration.TotalSeconds;

            while (firstActiveParticle != firstNewParticle)
            {
                // Is this particle old enough to retire?
                // We multiply the active particle index by four, because each
                // particle consists of a quad that is made up of four vertices.
                float particleAge = currentTime - particles[firstActiveParticle * 4].Time;

                if (particleAge < particleDuration)
                {
                    break;
                }
                
                // Remember the time at which we retired this particle.
                particles[firstActiveParticle * 4].Time = drawCounter;

                // Move the particle from the active to the retired queue.
                firstActiveParticle++;

                if (firstActiveParticle >= this.settings.MaxParticles)
                {
                    firstActiveParticle = 0;
                }
            }
        }

        /// <summary>
        /// Helper for checking when retired particles have been kept around long
        /// enough that we can be sure the GPU is no longer using them. It moves
        /// old particles from the retired area of the queue to the free section.
        /// </summary>
        private void FreeRetiredParticles()
        {
            while (firstRetiredParticle != firstActiveParticle)
            {
                // Has this particle been unused long enough that
                // the GPU is sure to be finished with it?
                // We multiply the retired particle index by four, because each
                // particle consists of a quad that is made up of four vertices.
                int age = drawCounter - (int)particles[firstRetiredParticle * 4].Time;

                // The GPU is never supposed to get more than 2 frames behind the CPU.
                // We add 1 to that, just to be safe in case of buggy drivers that
                // might bend the rules and let the GPU get further behind.
                if (age < 3)
                {
                    break;
                }

                // Move the particle from the retired to the free queue.
                firstRetiredParticle++;

                if (firstRetiredParticle >= this.settings.MaxParticles)
                {
                    firstRetiredParticle = 0;
                }
            }
        }

        #endregion

        #region Draw

        public void Draw()
        {
            var GDevice = Persian.GDevice;

            if (!enable || (!AlwaysVisible && !Persian.Camera.Frustum.Intersects(this.globalBoundingBox)))
            {
                return;
            }

            #region Set effect params

            effectViewParameter.SetValue(Persian.Camera.View);
            effectProjectionParameter.SetValue(Persian.Camera.Projection);

            #endregion

            // Restore the vertex buffer contents if the graphics device was lost.
            if (vertexBuffer.IsContentLost)
            {
                vertexBuffer.SetData(particles);
            }

            // If there are any particles waiting in the newly added queue,
            // we'd better upload them to the GPU ready for drawing.
            if (firstNewParticle != firstFreeParticle)
            {
                AddNewParticlesToVertexBuffer();
            }

            // If there are any active particles, draw them now!
            if (firstActiveParticle != firstFreeParticle)
            {
                GDevice.BlendState = this.settings.BlendState;

                // Set an effect parameter describing the viewport size. This is
                // needed to convert particle sizes into screen space point sizes.
                effectViewportScaleParameter.SetValue(new Vector2(0.5f / GDevice.Viewport.AspectRatio, -0.5f));
                effectViewportScaleParameter.SetValue(new Vector2(this.settings.Scale.X / GDevice.Viewport.AspectRatio, -this.settings.Scale.Y));

                // Set an effect parameter describing the current time. All the vertex
                // shader particle animation is keyed off this value.
                effectTimeParameter.SetValue(currentTime);

                // Set the particle vertex and index buffer.
                GDevice.SetVertexBuffer(vertexBuffer);
                GDevice.Indices = indexBuffer;

                particleEffect.CurrentTechnique = particleEffect.Techniques[0];

                #region  Activate the particle effect

                foreach (var pass in particleEffect.CurrentTechnique.Passes)
                {
                    pass.Apply();

                    if (firstActiveParticle < firstFreeParticle)
                    {
                        // If the active particles are all in one consecutive range,
                        // we can draw them all in a single call.
                        GDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList, 0,
                            firstActiveParticle * 4, (firstFreeParticle - firstActiveParticle) * 4,
                            firstActiveParticle * 6, (firstFreeParticle - firstActiveParticle) * 2);
                    }
                    else
                    {
                        // If the active particle range wraps past the end of the queue
                        // back to the start, we must split them over two draw calls.
                        GDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList, 0,
                            firstActiveParticle * 4, (this.settings.MaxParticles - firstActiveParticle) * 4,
                            firstActiveParticle * 6, (this.settings.MaxParticles - firstActiveParticle) * 2);

                        if (firstFreeParticle > 0)
                        {
                            GDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList, 0, 0, firstFreeParticle * 4, 0, firstFreeParticle * 2);
                        }
                    }
                }

                #endregion
            }

            drawCounter++;

#if DEBUG

            //Bounding.DrawBoundingBox(
            //    this.localBoundingBox, 
            //    GDevice, 
            //    ShadersManager.VPColor3EffectFX, 
            //    this.globalTransform, 
            //    Color.Red);
            UsageReporter.debugInfo.VisibleParticleSystems++;
#endif
        }


        /// <summary>
        /// Helper for uploading new particles from our managed
        /// array to the GPU vertex buffer.
        /// </summary>
        private void AddNewParticlesToVertexBuffer()
        {
            int stride = ParticleVertex.SizeInBytes;

            if (firstNewParticle < firstFreeParticle)
            {
                // If the new particles are all in one consecutive range,
                // we can upload them all in a single call.
                vertexBuffer.SetData(firstNewParticle * stride * 4, particles,
                                     firstNewParticle * 4,
                                     (firstFreeParticle - firstNewParticle) * 4,
                                     stride, SetDataOptions.NoOverwrite);
            }
            else
            {
                // If the new particle range wraps past the end of the queue
                // back to the start, we must split them over two upload calls.
                vertexBuffer.SetData(firstNewParticle * stride * 4, particles,
                                     firstNewParticle * 4,
                                     (this.settings.MaxParticles - firstNewParticle) * 4,
                                     stride, SetDataOptions.NoOverwrite);

                if (firstFreeParticle > 0)
                {
                    vertexBuffer.SetData(0, particles,
                                         0, firstFreeParticle * 4,
                                         stride, SetDataOptions.NoOverwrite);
                }
            }

            // Move the particles we just uploaded from the new to the active queue.
            firstNewParticle = firstFreeParticle;
        }


        #endregion

        #region Dispose

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this.enable = false;

                try
                {
                    var texture = this.particleEffect.Parameters["Texture"].GetValueTexture2D();
                    SystemMemory.SafeDispose(texture);
                }
                catch(AccessViolationException ex)
                {
                    Logger.WriteError("AccessViolationException just happened in Particle System");
                }
                this.effectProjectionParameter = this.effectTimeParameter = this.effectViewParameter = this.effectViewportScaleParameter = null;
                SystemMemory.SafeDispose(this.indexBuffer);
                SystemMemory.SafeDispose(this.vertexBuffer);
                SystemMemory.SafeDispose(this.particleEffect);

                this.particles = null;
                this.GDevice = null;
            }
            base.Dispose(disposing);
        }

        #endregion
    }
}
