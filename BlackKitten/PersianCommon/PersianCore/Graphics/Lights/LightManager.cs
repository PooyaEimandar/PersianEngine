/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : LightsManager.cs
 * File Description : The manager for all the light
 * Generated by     : Pooya Eimandar 
 * Last modified by : Pooya Eimandar on 11/8/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Graphics.Lights.Deferred;
using PersianCore.Meshes;
using System;
using System.Collections.Generic;

namespace PersianCore.Graphics.Lights
{
    /// <summary>
    /// A manager for all the light
    /// </summary>
    public class LightManager
    {
        #region Fields & Properties

        public static Light MainDirLight { get; set; }
        //Model pointLightGeometry;
        //Model spotLightGeometry;
        BlendState lBufferBlend;
        Vector3[] localFrustumCorners;
        //Effect directionalLightFX, spotLightFX, pointLightFX;

        List<Light> visibleLights;
        public List<Light> VisibleLights
        {
            get
            {
                return this.visibleLights;
            }
        }

        List<Light> lightShadowCasters;
        public List<Light> LightShadowCasters
        {
            get
            {
                return this.lightShadowCasters;
            }
        }

        List<Light> lights;
        /// <summary>
        /// Directional lights
        /// </summary>
        public List<Light> Lights
        {
            get
            {
                return this.lights;
            }
        }

        //RenderTarget2D lightBuffer;
        //public RenderTarget2D LightBuffer
        //{
        //    get
        //    {
        //        return this.lightBuffer;
        //    }
        //}

        #endregion

        #region Constructor/Destructor

        public LightManager()
        {
            this.lights = new List<Light>();
            this.lightShadowCasters = new List<Light>();
            this.visibleLights = new List<Light>();
            this.localFrustumCorners = new Vector3[4];

            this.lBufferBlend = new BlendState()
            {
                ColorSourceBlend = Blend.One,
                ColorDestinationBlend = Blend.One,
                ColorBlendFunction = BlendFunction.Add,
                AlphaSourceBlend = Blend.One,
                AlphaDestinationBlend = Blend.One,
                AlphaBlendFunction = BlendFunction.Add,
            };
        }

        ~LightManager()
        {
        }

        #endregion

        #region Load

        //public void Load(ContentManager Content, int width, int height)
        //{
        //    var path = @"EditorBrowser\Models\Lights";
        //    this.pointLightGeometry = Content.Load<Model>(string.Format(@"{0}\PointLight", path));
        //    this.spotLightGeometry = Content.Load<Model>(string.Format(@"{0}\SpotLight", path));
        //}

        #endregion

        #region Methods

        public void ApplyFrustumCorners(Vector2 topLeftVertex, Vector2 bottomRightVertex, Vector3[] currentFrustumCorners)
        {
            var dx = currentFrustumCorners[1].X - currentFrustumCorners[0].X;
            var dy = currentFrustumCorners[0].Y - currentFrustumCorners[2].Y;

            localFrustumCorners[0] = currentFrustumCorners[2];
            localFrustumCorners[0].X += dx * (topLeftVertex.X * 0.5f + 0.5f);
            localFrustumCorners[0].Y += dy * (bottomRightVertex.Y * 0.5f + 0.5f);

            localFrustumCorners[1] = currentFrustumCorners[2];
            localFrustumCorners[1].X += dx * (bottomRightVertex.X * 0.5f + 0.5f);
            localFrustumCorners[1].Y += dy * (bottomRightVertex.Y * 0.5f + 0.5f);

            localFrustumCorners[2] = currentFrustumCorners[2];
            localFrustumCorners[2].X += dx * (topLeftVertex.X * 0.5f + 0.5f);
            localFrustumCorners[2].Y += dy * (topLeftVertex.Y * 0.5f + 0.5f);

            localFrustumCorners[3] = currentFrustumCorners[2];
            localFrustumCorners[3].X += dx * (bottomRightVertex.X * 0.5f + 0.5f);
            localFrustumCorners[3].Y += dy * (topLeftVertex.Y * 0.5f + 0.5f);
        }

        internal void SelectShadowCasters(Shadow.CascadeShadowMapEntry cascadeShadowMap, Shadow.SpotShadowMapEntry spotShadowMap)
        {
            this.lightShadowCasters.Clear();

            for (int i = 0; i < this.visibleLights.Count; i++)
            {
                if (this.visibleLights[i].EnableShadow)
                {
                    if (this.visibleLights[i].LightType == LightType.Spot)
                    {
                        this.visibleLights[i].spotShadowMap = spotShadowMap;
                        lightShadowCasters.Add(this.visibleLights[i]);
                    }
                    else if (this.visibleLights[i].LightType == LightType.Directional)
                    {
                        this.visibleLights[i].cascadeShadowMap = cascadeShadowMap;
                        lightShadowCasters.Add(this.visibleLights[i]);
                    }
                }
            }
        }

        internal void SortLights()
        {
            FindVisibleLights(Persian.Camera.Frustum);

            for (int index = 0; index < this.visibleLights.Count; ++index)
            {
                this.visibleLights[index].DistanceFromCamera = Math.Max(
                    1,
                    Vector3.Distance(visibleLights[index].World.Translation,
                    Persian.Camera.World.Translation));

                //compute a value to determine light order 
                this.visibleLights[index].Priority = 1000 * (int)(visibleLights[index].Radius / Math.Max(1.0f, visibleLights[index].DistanceFromCamera));
            }

            this.visibleLights.Sort(delegate(Light p1, Light p2)
            {
                return (int)(p2.Priority - p1.Priority);
            });
        }

        public void FindVisibleLights(BoundingFrustum frustum)
        {
            this.visibleLights.Clear();

            foreach (var light in this.Lights)
            {
                if (!light.Enable) continue;

                switch (light.LightType)
                {
                    case LightType.Point:
                        light.UpdateSpotValues();
                        if (light.AlwaysVisible || frustum.Intersects(light.BoundingSphere))
                        {
                            visibleLights.Add(light);
                        }
                        break;
                    case LightType.Directional:
                        visibleLights.Add(light);
                        break;
                    case LightType.Spot:
                        //check first agains the bounding sphere (quick and cheap)
                        if (light.AlwaysVisible || frustum.Intersects(light.BoundingSphere)
                            && frustum.Intersects(light.Frustum))
                        {
                            visibleLights.Add(light);
                        }
                        break;
                }
            }
        }

        /// <summary>
        /// Add the light
        /// </summary>
        /// <param name="Light"></param>
        public void AddLight(Light light)
        {
            this.lights.Add(light);
        }

        /// <summary>
        /// Remove the light
        /// </summary>
        /// <param name="Light"></param>
        public void RemoveLight(Light light)
        {
            this.lights.Remove(light);
        }

        internal void RemoveAll()
        {
            this.lights.Clear();
        }

        #endregion
    }
}
