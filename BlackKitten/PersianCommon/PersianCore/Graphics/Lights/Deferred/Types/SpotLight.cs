/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : SpotLight.cs
 * File Description : The spot light
 * Generated by     : Pooya Eimandar 
 * Last modified by : Pooya Eimandar on 11/8/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Meshes;
using System;
using System.Collections.Generic;

namespace PersianCore.Graphics.Lights.Deferred
{
    /// <summary>
    /// The spot light
    /// </summary>
    public class SpotLight : Light
    {
        #region Fields & Properties

        Matrix world;
        public Matrix World
        {
            get
            {
                return this.world;
            }
        }

        Matrix view;
        public Matrix View
        {
            get
            {
                return this.view;
            }
        }

        Matrix projection;
        public Matrix Projection
        {
            get
            {
                return this.projection;
            }
        }

        Vector3 direction;
        /// <summary>
        /// Direction of the spot light
        /// </summary>
        public Vector3 Direction
        {
            get
            {
                return this.direction;
            }
            set
            {
                this.direction = value;
            }
        }

        float nearPlane;
        /// <summary>
        /// Near plan of the spot light
        /// </summary>
        public float NearPlane
        {
            get
            {
                return this.nearPlane;
            }
            set
            {
                if (this.nearPlane != value)
                {
                    this.nearPlane = value;
                    UpdateProjection();
                }
            }
        }

        float farPlane;
        /// <summary>
        /// Far plan of the spot light
        /// </summary>
        public float FarPlane
        {
            get
            {
                return this.farPlane;
            }
            set
            {
                if (this.farPlane != value)
                {
                    this.farPlane = value;
                    UpdateProjection();
                }
            }
        }

        float cosAngle;
        public float CosOfAngle
        {
            get
            {
                return this.cosAngle;
            }
        }

        float angle;
        /// <summary>
        /// The angle of the spot light
        /// </summary>
        public float Angle
        {
            get
            {
                return this.angle;
            }
            set
            {
                if (this.angle != value)
                {
                    this.angle = value;
                    this.cosAngle = (float)Math.Cos(value);
                    UpdateProjection();
                }
            }
        }

        RenderTarget2D shadowMap;
        /// <summary>
        /// Get the shadow map
        /// </summary>
        public RenderTarget2D ShadowMap
        {
            get
            {
                return this.shadowMap;
            }
        }

        Texture2D attenuationTexture;
        /// <summary>
        /// Get SPOT attenuation texture
        /// </summary>
        public Texture2D AttenuationTexture
        {
            get
            {
                return this.attenuationTexture;
            }
        }

        #endregion

        #region Constructor/Destructor

        public SpotLight(Vector3 position, Vector3 direction, Color color,
            float intensity, bool enableShadow, short shadowMapResoloution, Texture2D attenuationTexture)
        {
            this.lightType = LightType.Spot;
            this.position = position;
            this.direction = direction;
            this.Color = color.ToVector4();
            this.Intensity = intensity;
            this.EnableShadow = enableShadow;
            this.attenuationTexture = attenuationTexture;
            //Set property of the ShadowMapResoloution, we need to check size of the resolution first
            this.ShadowMapResoloution = shadowMapResoloution;

            this.nearPlane = Persian.Camera.NearClip;
            this.farPlane = Persian.Camera.FarClip;
            this.angle = MathHelper.ToRadians(60);

            this.shadowMap = new RenderTarget2D(
                Persian.GDevice,
                this.shadowMapResoloution,
                this.shadowMapResoloution,
                false,
                SurfaceFormat.Single,
                DepthFormat.Depth24Stencil8);

            UpdateProjection();
            UpdateWorld();
        }

        #endregion

        #region Update

        private void UpdateProjection()
        {
            this.projection = Matrix.CreatePerspectiveFieldOfView(this.angle, 1.0f, nearPlane, farPlane);
        }

        public void UpdateWorld()
        {
            var target = (position + direction);
            if (target == Vector3.Zero)
            {
                target = -Vector3.Up;
            }

            var up = Vector3.Cross(direction, Vector3.Up);
            if (up == Vector3.Zero)
            {
                up = Vector3.Right;
            }
            else
            {
                up = Vector3.Up;
            }

            view = Matrix.CreateLookAt(this.position, target, up);
            float radial = (float)Math.Tan((double)this.angle / 2.0) * 2 * this.farPlane;
            var scale = Matrix.CreateScale(radial, radial, farPlane);

            Vector3 S, P;
            Quaternion Q;
            var scaleViewInverse = scale * Matrix.Invert(view);
            scaleViewInverse.Decompose(out S, out Q, out P);

            this.world = scale * Matrix.CreateFromQuaternion(Q) * Matrix.CreateTranslation(this.position);
        }

        #endregion

        #region Draw

        internal void DrawShadowMap(Effect shadowDepthBuffer, List<Mesh> meshes)
        {
            var GDevice = Persian.GDevice;

            GDevice.SetRenderTarget(this.shadowMap);
            {
                GDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);

                shadowDepthBuffer.Parameters["LightPosition"].SetValue(this.position);//LightPosition
                shadowDepthBuffer.Parameters["DepthPrecision"].SetValue(this.farPlane);//DepthPrecision

                //Draw all models
                foreach (var mesh in meshes)
                {
                    //mesh.DrawToShadowMap(shadowDepthBuffer, this.view * this.projection);
                }

                GDevice.SetRenderTarget(null);
            }
        }

        #endregion
    }
}
