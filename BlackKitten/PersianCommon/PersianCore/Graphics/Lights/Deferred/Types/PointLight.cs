/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : PointLight.cs
 * File Description : The point light
 * Generated by     : Pooya Eimandar 
 * Last modified by : Pooya Eimandar on 11/8/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Meshes;
using System.Collections.Generic;

namespace PersianCore.Graphics.Lights.Deferred
{
    /// <summary>
    /// The point light
    /// </summary>
    public class PointLight : Light
    {
        #region Fields & Properties

        float radius;
        /// <summary>
        /// Radius of the point light
        /// </summary>
        public float Radius
        {
            get
            {
                return this.radius;
            }
            set
            {
                this.radius = value;
            }
        }

        RenderTargetCube shadowMap;
        /// <summary>
        /// Get the shadow map
        /// </summary>
        public RenderTargetCube ShadowMap
        {
            get
            {
                return this.shadowMap;
            }
        }

        /// <summary>
        /// Get depth bias
        /// </summary>
        public float DepthBias
        {
            get
            {
                return (1.0f / (20 * this.radius));
            }
        }

        public Matrix World
        {
            get
            {
                return (Matrix.CreateScale(this.radius / 100.0f) * Matrix.CreateTranslation(position));
            }
        }

        #endregion

        #region Constructor/Destructor

        //Constructor
        public PointLight(Vector3 position, float radius, Color color, float intensity,
            bool enableShadow, short shadowMapResoloution)
        {
            this.lightType = LightType.Point;
            this.position = position;
            this.radius = radius;
            this.Color = color.ToVector4();
            this.Intensity = intensity;
            this.EnableShadow = enableShadow;
            //Set property of the ShadowMapResoloution, we need to check size of the resolution first
            this.ShadowMapResoloution = shadowMapResoloution;

            this.shadowMap = new RenderTargetCube(
                Persian.GDevice,
                this.shadowMapResoloution,
                false,
                SurfaceFormat.Single,
                DepthFormat.Depth24Stencil8);
        }

        #endregion

        #region Draw

        internal void DrawShadowMap(Effect shadowDepthBuffer, List<Mesh> meshes)
        {
            var GDevice = Persian.GDevice;

            var views = new Matrix[6]
            {
                Matrix.CreateLookAt(position, position + Vector3.Forward, Vector3.Up),//Forward Plan
                Matrix.CreateLookAt(position, position + Vector3.Backward, Vector3.Up),//Backward Plan
                Matrix.CreateLookAt(position, position + Vector3.Left, Vector3.Up),//Left Plan
                Matrix.CreateLookAt(position, position + Vector3.Right, Vector3.Up),//Right Plan
                Matrix.CreateLookAt(position, position + Vector3.Down, Vector3.Forward),//Down Plan
                Matrix.CreateLookAt(position, position + Vector3.Up, Vector3.Backward),//Up Plan
            };

            var projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.ToRadians(90.0f), 1.0f, 1.0f, this.radius);
            shadowDepthBuffer.Parameters[2].SetValue(this.position);//LightPosition
            shadowDepthBuffer.Parameters[3].SetValue(this.radius);//DepthPrecision


            //Render forward view
            GDevice.SetRenderTarget(this.shadowMap, CubeMapFace.PositiveZ);
            {
                GDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
                DrawModels(meshes, shadowDepthBuffer, views[0] * projection);
                GDevice.SetRenderTarget(null);
            }

            //Render backward view
            GDevice.SetRenderTarget(this.shadowMap, CubeMapFace.NegativeZ);
            {
                GDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
                DrawModels(meshes, shadowDepthBuffer, views[1] * projection);
                GDevice.SetRenderTarget(null);
            }

            //Render left view
            GDevice.SetRenderTarget(this.shadowMap, CubeMapFace.NegativeX);
            {
                GDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
                DrawModels(meshes, shadowDepthBuffer, views[2] * projection);
                GDevice.SetRenderTarget(null);
            }

            //Render right view
            GDevice.SetRenderTarget(this.shadowMap, CubeMapFace.PositiveX);
            {
                GDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
                DrawModels(meshes, shadowDepthBuffer, views[3] * projection);
                GDevice.SetRenderTarget(null);
            }

            //Render down view
            GDevice.SetRenderTarget(this.shadowMap, CubeMapFace.NegativeY);
            {
                GDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
                DrawModels(meshes, shadowDepthBuffer, views[4] * projection);
                GDevice.SetRenderTarget(null);
            }

            //Render up view
            GDevice.SetRenderTarget(this.shadowMap, CubeMapFace.PositiveY);
            {
                GDevice.Clear(Microsoft.Xna.Framework.Color.Transparent);
                DrawModels(meshes, shadowDepthBuffer, views[5] * projection);
                GDevice.SetRenderTarget(null);
            }
        }

        private void DrawModels(List<Mesh> meshes, Effect effect, Matrix lightViewProjection)
        {
            foreach (var obj in meshes)
            {
               // obj.DrawToShadowMap(effect, lightViewProjection);
            }
        }

        #endregion
    }
}
