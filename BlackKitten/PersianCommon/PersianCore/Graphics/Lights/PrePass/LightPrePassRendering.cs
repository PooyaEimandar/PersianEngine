/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : Render.cs
 * File Description : The render class, which implements lighting
 * Generated by     : Modified by Pooya Eimandar based on LLP implementation (http://jcoluna.wordpress.com/)
 * Last modified by : Pooya Eimandar on 8/21/2013
 * Comment          : FXAA added
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Graphics.AntiAliasing;
using PersianCore.Graphics.PostProcessing;
using System;
using System.Collections.Generic;

namespace PersianCore.Graphics.Lights.PrepassTechnique
{
    public class LightPrePassRendering : Node
    {
        #region Fields & Properties

        static Color backColor;
        FXAA fxaa;
        // SSAO ssao;
        DownSampling downSample;
        Effect reConstructZBufferEffect;
        Effect lightEffect;
        Model sphereRenderer;
        Model spotRenderer;
        
        Vector3[] localFrustumCorners;

        BlendState lightAddBlendState;
        LightStencilStates lightStencilStates;
        GBuffer gBuffer;
        LBuffers lBuffer;

        bool usePCF2X2;
        public bool UsePCF2X2
        {
            get
            {
                return this.usePCF2X2;
            }
            set
            {
                if (this.usePCF2X2 != value)
                {
                    this.usePCF2X2 = value;
                    if (this.usePCF2X2Param != null)
                    {
                        this.usePCF2X2Param.SetValue(value);
                    }
                }
            }
        }

        public RenderTarget2D LightBuffer
        {
            get
            {
                return this.lBuffer.lightBuffer;
            }
        }

        public bool EnableFXAA
        {
            get
            {
                return this.fxaa.Enable;
            }
            set
            {
                this.fxaa.Enable = value;
            }
        }
        
        /// <summary>
        /// Screen Space Ambient Occulision
        /// </summary>
        //SSAO ssao;

        //Skybox skyboxMesh;
        public static TextureCube ambientCubemap;

        bool showLightsQuadStatus;
        public bool ShowLightsQuadStatus
        {
            get
            {
                return showLightsQuadStatus;
            }
            set
            {
                showLightsQuadStatus = value;
            }
        }

        public bool EnableShadows { get; set; }

        //List<MovingLight> _movingLights;
        //RotatingSpots _rotatingSpots;
        //Light dirLight;
        Texture2D lightDebugTexture;

        EffectParameter lightPixelSizeParam { get; set; }
        EffectParameter depthBufferParam { get; set; }
        EffectParameter normalMapParam { get; set; }
        EffectParameter tanAspectRatioParam { get; set; }
        EffectParameter lightPositionParam { get; set; }
        EffectParameter cascadeDistancesParam { get; set; }
        EffectParameter lightDirParam { get; set; }
        EffectParameter LightColorParam { get; set; }
        EffectParameter invertLightRadiusSqrParam { get; set; }
        EffectParameter farClipParam { get; set; }
        EffectParameter worldViewProjectionParam { get; set; }
        EffectParameter spotAngleParam { get; set; }
        EffectParameter spotPowerParam { get; set; }
        EffectParameter spotLightViewProjectionParam { get; set; }
        EffectParameter shadowMapPixelSizeParam { get; set; }
        EffectParameter depthBiasParam { get; set; }
        EffectParameter shadowMapSizeParam { get; set; }
        EffectParameter shadowMapParam { get; set; }
        EffectParameter cameraWorldParam { get; set; }
        EffectParameter clipPlanesParam { get; set; }
        EffectParameter lightViewProjectionParam { get; set; }
        EffectParameter reConstructPixelSizeParam { get; set; }
        EffectParameter reConstructDepthBufferParam { get; set; }
        EffectParameter reConstructFarClipParam { get; set; }
        EffectParameter reConstructProjectionParam { get; set; }
        EffectParameter frustumCornersParam { get; set; }
        EffectParameter usePCF2X2Param { get; set; }

        #endregion

        #region Constructor/Destructor

        public LightPrePassRendering()
        {
            InitializeFields();
        }

        ~LightPrePassRendering()
        {

        }

        private void InitializeFields()
        {
            this.EnableShadows = true;
            this.usePCF2X2 = true;
            this.fxaa = new FXAA()
            {
                Enable = true,
            };
            this.localFrustumCorners = new Vector3[4];
            this.downSample = new DownSampling();
            this.lightStencilStates = new LightStencilStates();
            this.lBuffer = new LBuffers();
            this.gBuffer = new GBuffer();
            lightAddBlendState = new BlendState()
            {
                AlphaSourceBlend = Blend.One,
                ColorSourceBlend = Blend.One,
                AlphaDestinationBlend = Blend.One,
                ColorDestinationBlend = Blend.One,
            };
        }

        #endregion

        #region Load

        public void Load(ContentManager Content)
        {
            backColor = Persian.RunningEngine ? Color.Black : new Color(45, 46, 50);

            string _ModelPath = @"Models\Base\";
            string _LightPath = @"Shaders\PrePassRendering\";
            sphereRenderer = Content.Load<Model>(string.Format(@"{0}{1}Sphere", CoreShared.PrePathContent, _ModelPath));
            spotRenderer = Content.Load<Model>(string.Format(@"{0}{1}Cone", CoreShared.PrePathContent, _ModelPath));

            #region Load Light's Effect and Bind Parameters

            lightEffect = Content.Load<Effect>(string.Format(@"{0}{1}Lights", CoreShared.PrePathContent, _LightPath));
            this.lightPixelSizeParam = lightEffect.Parameters["PixelSize"];
            this.depthBufferParam = lightEffect.Parameters["DepthBuffer"];
            this.normalMapParam = lightEffect.Parameters["NormalMap"];
            this.tanAspectRatioParam = lightEffect.Parameters["tanAspectRatio"];
            this.lightPositionParam = lightEffect.Parameters["LightPosition"];
            this.cascadeDistancesParam = lightEffect.Parameters["CascadeDistances"];
            this.lightDirParam = lightEffect.Parameters["LightDir"];
            this.LightColorParam = lightEffect.Parameters["LightColor"];
            this.invertLightRadiusSqrParam = lightEffect.Parameters["InvertLightRadiusSqr"];
            this.farClipParam = lightEffect.Parameters["FarClip"];
            this.worldViewProjectionParam = lightEffect.Parameters["WorldViewProjection"];
            this.spotAngleParam = lightEffect.Parameters["SpotAngle"];
            this.spotPowerParam = lightEffect.Parameters["SpotPower"];
            this.spotLightViewProjectionParam = lightEffect.Parameters["SpotLightViewProjection"];
            this.depthBiasParam = lightEffect.Parameters["DepthBias"];
            this.shadowMapPixelSizeParam = lightEffect.Parameters["ShadowMapPixelSize"];
            this.shadowMapSizeParam = lightEffect.Parameters["ShadowMapSize"];
            this.shadowMapParam = lightEffect.Parameters["ShadowMap"];
            this.cameraWorldParam = lightEffect.Parameters["CameraWorld"];
            this.clipPlanesParam = lightEffect.Parameters["ClipPlanes"];
            this.lightViewProjectionParam = lightEffect.Parameters["LightViewProjection"];
            this.frustumCornersParam = lightEffect.Parameters["FrustumCorners"];
            this.usePCF2X2Param = lightEffect.Parameters["UsePCF2X2"];
            this.usePCF2X2Param.SetValue(this.usePCF2X2);
            #endregion

            this.gBuffer.Load(Content);

            this.reConstructZBufferEffect = Content.Load<Effect>(string.Format(@"{0}{1}ReadCompactDepth", CoreShared.PrePathContent, _LightPath));
            this.reConstructPixelSizeParam = reConstructZBufferEffect.Parameters["PixelSize"];
            this.reConstructDepthBufferParam = reConstructZBufferEffect.Parameters["DepthBuffer"];
            this.reConstructFarClipParam = reConstructZBufferEffect.Parameters["FarClip"];
            this.reConstructProjectionParam = reConstructZBufferEffect.Parameters["Projection"];

            this.downSample.Load(Content, this.lBuffer.depthBuffer);

            this.fxaa.Load(Content);

            this.showLightsQuadStatus = false;
            if (!Persian.RunningEngine)
            {
                this.lightDebugTexture = Content.Load<Texture2D>(@"EditorBrowser\Textures\Utilities\lightTexture");
            }

            ambientCubemap = Content.Load<TextureCube>(
                string.Format(@"{0}Textures\Environments\BlueSkyAmbient",
                CoreShared.PrePathContent));
        }

        #endregion

        #region Methods

        public void RenderMesh(Model model)
        {
            Persian.GDevice.DrawIndexedPrimitives(
                PrimitiveType.TriangleList, 0, 0,
                model.Meshes[0].MeshParts[0].NumVertices,
                model.Meshes[0].MeshParts[0].StartIndex,
                model.Meshes[0].MeshParts[0].PrimitiveCount);
        }

        public void BindMesh(Model model)
        {
            Persian.GDevice.SetVertexBuffer(
                model.Meshes[0].MeshParts[0].VertexBuffer,
                model.Meshes[0].MeshParts[0].VertexOffset);
            Persian.GDevice.Indices = model.Meshes[0].MeshParts[0].IndexBuffer;
        }

        //Todo : Move it to render manager after compute frustum
        public void ApplyFrustumCorners(Vector2 topLeftVertex, Vector2 bottomRightVertex, Vector3[] currentFrustumCorners)
        {
            var dx = currentFrustumCorners[1].X - currentFrustumCorners[0].X;
            var dy = currentFrustumCorners[0].Y - currentFrustumCorners[2].Y;

            localFrustumCorners[0] = currentFrustumCorners[2];
            localFrustumCorners[0].X += dx * (topLeftVertex.X * 0.5f + 0.5f);
            localFrustumCorners[0].Y += dy * (bottomRightVertex.Y * 0.5f + 0.5f);

            localFrustumCorners[1] = currentFrustumCorners[2];
            localFrustumCorners[1].X += dx * (bottomRightVertex.X * 0.5f + 0.5f);
            localFrustumCorners[1].Y += dy * (bottomRightVertex.Y * 0.5f + 0.5f);

            localFrustumCorners[2] = currentFrustumCorners[2];
            localFrustumCorners[2].X += dx * (topLeftVertex.X * 0.5f + 0.5f);
            localFrustumCorners[2].Y += dy * (topLeftVertex.Y * 0.5f + 0.5f);

            localFrustumCorners[3] = currentFrustumCorners[2];
            localFrustumCorners[3].X += dx * (bottomRightVertex.X * 0.5f + 0.5f);
            localFrustumCorners[3].Y += dy * (topLeftVertex.Y * 0.5f + 0.5f);

            this.frustumCornersParam.SetValue(localFrustumCorners);
        }
        
        #endregion

        #region Draw

        public void Draw(SpriteBatch spriteBatch, ObjectsManager objectsManager, 
            PostProcessor postProcessor, List<Action<GraphicsDevice>> renderInvokes, Vector3[] currentFrustumCorners, 
            List<Light> lights, ref Texture2D resultRender)
        {
            this.downSample.isDownSampleThisFrame = false;

            //Request for occlusion culling for next frame
            objectsManager.OcclusionQuery();

            DrawToGBuffer(objectsManager);
            DrawLights(currentFrustumCorners, lights);

            DrawFinal(objectsManager, renderInvokes);

            resultRender = this.lBuffer.resultTexture as Texture2D;
            if (postProcessor.Enable)
            {
                resultRender = postProcessor.Render(this.lBuffer, GetDownsampledDepth());
            }

            this.fxaa.Draw(spriteBatch, resultRender);

        }

        private void DrawFinal(ObjectsManager objectsManager, List<Action<GraphicsDevice>> renderInvokes)
        {
            var GDevice = Persian.GDevice;
            GDevice.SetRenderTarget(this.lBuffer.resultTexture);
            {
                #region ReConstruct Device

                GDevice.Clear(ClearOptions.DepthBuffer | ClearOptions.Stencil, backColor, 1.0f, 0);
                GDevice.DepthStencilState = DepthStencilState.Default;
                GDevice.BlendState = BlendState.Opaque;
                GDevice.RasterizerState = RasterizerState.CullCounterClockwise;

                #endregion

                GDevice.Clear(backColor);
                objectsManager.DrawOpaqueObjects();
                objectsManager.DrawSky();
#if DEBUG
                if (renderInvokes != null)
                {
                    for (int i = 0; i < renderInvokes.Count; ++i)
                    {
                        renderInvokes[i].Invoke(GDevice);
                    }
                }
#endif
                objectsManager.ReConstructShading(this.lBuffer.lightBuffer);

                //if (this.ssao.Enabled)
                //{
                //    this.ssao.FinalMix(this.lBuffer.halfBuffer0, GDevice);
                //}

                //Draw Fog         

                #region Draw Blend Objects

                //Reset states, since the custom shaders could have overriden them
                GDevice.DepthStencilState = DepthStencilState.DepthRead;
                GDevice.BlendState = BlendState.AlphaBlend;//Additive
                GDevice.BlendFactor = Color.White;
                GDevice.RasterizerState = RasterizerState.CullCounterClockwise;


                objectsManager.DrawBlendObjects();

                #endregion

                GDevice.BlendState = BlendState.Opaque;
                GDevice.DepthStencilState = DepthStencilState.None;
                GDevice.SetRenderTarget(null);
            }
        }
        
        private void DrawToGBuffer(ObjectsManager meshManager)
        {
            this.gBuffer.Draw(this.lBuffer.NormalDepthGlowBinding);
            meshManager.DrawToGBuffer();
        }

        private void DrawLights(Vector3[] currentFrustumCorners, List<Light> lights)
        {
            //resolve our GBuffer and render the lights ,clear the light buffer with black
            Persian.GDevice.SetRenderTargets(this.lBuffer.lightAccumBinding);
            //Clear with transparent
            Persian.GDevice.Clear(Color.Transparent);

            Persian.GDevice.DepthStencilState = DepthStencilState.None;
            Persian.GDevice.RasterizerState = RasterizerState.CullCounterClockwise;
            Persian.GDevice.BlendState = lightAddBlendState;


            this.lightPixelSizeParam.SetValue(Persian.HalfScreenSize);
            this.depthBufferParam.SetValue(this.lBuffer.depthBuffer);
            this.normalMapParam.SetValue(this.lBuffer.normalBuffer);

            //just comment this line if you don't want to reconstruct the zbuffer
            ReConstructZBuffer();

            this.tanAspectRatioParam.SetValue(new Vector2(Persian.Camera.TanFieldOfView * Persian.Camera.AspectRatio, -Persian.Camera.TanFieldOfView));

            foreach (var light in lights)
            {
                //convert light position into view space
                var viewSpaceLPos = Vector3.Transform(light.World.Translation, Persian.Camera.View);
                this.lightPositionParam.SetValue(viewSpaceLPos);
                var viewSpaceLDir = Vector3.TransformNormal(Vector3.Normalize(light.World.Backward), Persian.Camera.View);
                this.lightDirParam.SetValue(viewSpaceLDir);
                var lightColor = light.Color * light.Intensity;
                lightColor.W = light.SpecularIntensity;
                this.LightColorParam.SetValue(lightColor);
                float invRadiusSqr = 1.0f / (light.Radius * light.Radius);
                this.invertLightRadiusSqrParam.SetValue(invRadiusSqr);
                this.farClipParam.SetValue(Persian.Camera.FarClip);

                #region Draw uppon light type

                switch (light.LightType)
                {
                    default:
                        Logger.WriteError("An unknown type of light is darwing");
                        break;
                    case LightType.Point:
                    case LightType.Spot:
                        if (light.LightType == LightType.Point)
                        {
                            #region Point

                            //var boundingSphereExpanded = light.BoundingSphere;
                            //boundingSphereExpanded.Radius *= 1.375f; //expand it a little, because our mesh is not a perfect sphere
                            //PlaneIntersectionType planeIntersectionType;
                            //Persian.Camera.Frustum.Near.Intersects(ref boundingSphereExpanded, out planeIntersectionType);
                            //if (planeIntersectionType != PlaneIntersectionType.Back)
                            //{
                            //    Persian.GDevice.RasterizerState = RasterizerState.CullCounterClockwise;
                            //    Persian.GDevice.DepthStencilState = this.lightStencilStates.ccwDepthState;

                            //}
                            //else
                            //{
                            //    Persian.GDevice.RasterizerState = RasterizerState.CullClockwise;
                            //    Persian.GDevice.DepthStencilState = this.lightStencilStates.cwDepthState;
                            //}

                            var lightMatrix = Matrix.CreateScale(light.Radius);
                            lightMatrix.Translation = light.BoundingSphere.Center;

                            this.worldViewProjectionParam.SetValue(lightMatrix * Persian.Camera.ViewProjection);

                            lightEffect.CurrentTechnique = lightEffect.Techniques[1];
                            lightEffect.CurrentTechnique.Passes[0].Apply();

                            BindMesh(sphereRenderer);
                            Persian.GDevice.DepthStencilState = DepthStencilState.None;
                            Persian.GDevice.RasterizerState = RasterizerState.CullNone;
                            RenderMesh(sphereRenderer);
                            Persian.GDevice.DepthStencilState = DepthStencilState.DepthRead;
                            #endregion
                        }
                        else
                        {
                            #region Spot

                            //var near = Persian.Camera.Frustum.Near;
                            //near.D += 3; //give some room because we dont use a perfect-fit mesh for the spot light
                            //var planeIntersectionType = near.Intersects(light.Frustum);
                            //if (planeIntersectionType != PlaneIntersectionType.Back)
                            //{
                            //    Persian.GDevice.RasterizerState = RasterizerState.CullCounterClockwise;
                            //    Persian.GDevice.DepthStencilState = this.lightStencilStates.ccwDepthState;

                            //}
                            //else
                            //{
                            //    Persian.GDevice.RasterizerState = RasterizerState.CullClockwise;
                            //    Persian.GDevice.DepthStencilState = this.lightStencilStates.cwDepthState;
                            //}

                            float tan = (float)Math.Tan(MathHelper.ToRadians(light.SpotAngle));
                            var lightMatrix = Matrix.CreateScale(light.Radius * tan, light.Radius * tan, light.Radius);

                            lightMatrix = lightMatrix * light.World;

                            this.worldViewProjectionParam.SetValue(lightMatrix * Persian.Camera.ViewProjection);
                            float cosSpotAngle = (float)Math.Cos(MathHelper.ToRadians(light.SpotAngle));
                            this.spotAngleParam.SetValue(cosSpotAngle);
                            this.spotPowerParam.SetValue(light.SpotExponent / (1 - cosSpotAngle));
                            if (light.EnableShadow)
                            {
                                lightEffect.CurrentTechnique = lightEffect.Techniques[4];
                                this.spotLightViewProjectionParam.SetValue(light.spotShadowMap.LightViewProjection);
                                this.depthBiasParam.SetValue(light.DepthBias);
                                var shadowMapPixelSize = new Vector2(0.5f / light.spotShadowMap.Target.RenderTarget2D.Width, 0.5f / light.spotShadowMap.Target.RenderTarget2D.Height);
                                this.shadowMapPixelSizeParam.SetValue(shadowMapPixelSize);
                                this.shadowMapSizeParam.SetValue(new Vector2(light.spotShadowMap.Target.RenderTarget2D.Width, light.spotShadowMap.Target.RenderTarget2D.Height));
                                this.shadowMapParam.SetValue(light.spotShadowMap.Target.Texture2D);
                                this.cameraWorldParam.SetValue(Persian.Camera.World);
                            }
                            else
                            {
                                lightEffect.CurrentTechnique = lightEffect.Techniques[3];
                            }

                            lightEffect.CurrentTechnique.Passes[0].Apply();

                            BindMesh(sphereRenderer);
                            Persian.GDevice.DepthStencilState = DepthStencilState.None;
                            Persian.GDevice.RasterizerState = RasterizerState.CullNone;
                            RenderMesh(sphereRenderer);
                            Persian.GDevice.DepthStencilState = DepthStencilState.DepthRead;

                            #endregion
                        }
                        break;
                    case  Graphics.Lights.LightType.Directional:
                        #region Directional Light

                        Persian.GDevice.DepthStencilState = this.lightStencilStates.directionalDepthState;
                        Persian.GDevice.RasterizerState = RasterizerState.CullNone;
                        ApplyFrustumCorners(-Vector2.One, Vector2.One, currentFrustumCorners);
                        if (light.EnableShadow)
                        {
                            lightEffect.CurrentTechnique = lightEffect.Techniques[5];

                            this.depthBiasParam.SetValue(light.DepthBias);
                            var shadowSize = light.cascadeShadowMap.Target.Texture2D.Bounds;

                            var shadowMapPixelSize = new Vector2(
                                0.5f / shadowSize.Width,
                                0.5f / shadowSize.Height);
                            this.shadowMapPixelSizeParam.SetValue(shadowMapPixelSize);
                            this.shadowMapSizeParam.SetValue(new Vector2(
                                shadowSize.Width,
                                shadowSize.Height));
                            this.shadowMapParam.SetValue(light.cascadeShadowMap.Target.Texture2D);
                            this.cameraWorldParam.SetValue(Persian.Camera.World);

                            this.clipPlanesParam.SetValue(light.cascadeShadowMap.LightClipPlanes);
                            this.lightViewProjectionParam.SetValue(light.cascadeShadowMap.LightViewProjectionMatrices);

                            var cascadeDistances = Vector3.Zero;
                            cascadeDistances.X = light.cascadeShadowMap.LightClipPlanes[0].X;
                            cascadeDistances.Y = light.cascadeShadowMap.LightClipPlanes[1].X;
                            cascadeDistances.Z = light.cascadeShadowMap.LightClipPlanes[2].X;
                            this.cascadeDistancesParam.SetValue(cascadeDistances);
                        }
                        else
                        {
                            lightEffect.CurrentTechnique = lightEffect.Techniques[2];
                        }
                        lightEffect.CurrentTechnique.Passes[0].Apply();
                        Persian.Quad.Draw();

                        #endregion
                        break;
                }

                #endregion
            }
            Persian.GDevice.RasterizerState = RasterizerState.CullCounterClockwise;

            //if (ssao.Enabled)
            //{
            //    ssao.ComputeSSAO(GDevice, GetDownSampledDepth(GDevice), normalMap, halfBuffer0, halfBuffer1);
            //}
        }

        public RenderTarget2D GetDownsampledDepth()
        {
            if (!this.downSample.isDownSampleThisFrame)
            {
                DownsampleDepthbuffer();
            }
            return lBuffer.downSampleDepthBuffer;
        }

        private void DownsampleDepthbuffer()
        {
            this.downSample.RenderEffect(lBuffer.downSampleDepthBuffer);
            this.downSample.isDownSampleThisFrame = true;
        }

        private void ReConstructZBuffer()
        {
            //bind effect
            this.reConstructPixelSizeParam.SetValue(Persian.HalfScreenSize);
            this.reConstructDepthBufferParam.SetValue(this.lBuffer.depthBuffer);
            this.reConstructFarClipParam.SetValue(Persian.Camera.FarClip);
            this.reConstructProjectionParam.SetValue(new Vector2(Persian.Camera.Projection.M33, Persian.Camera.Projection.M43));
            reConstructZBufferEffect.CurrentTechnique.Passes[0].Apply();
            {
                //store previous state
                var oldBlendState = Persian.GDevice.BlendState;
                Persian.GDevice.DepthStencilState = this.lightStencilStates.depthStateReConstructZ;
                Persian.Quad.Draw();
                Persian.GDevice.DepthStencilState = this.lightStencilStates.depthStateDrawLights;
                Persian.GDevice.BlendState = oldBlendState;
            }
        }

        internal void ShowDebug(SpriteBatch spriteBatch, Texture2D ShadowMapTexture)
        {
            var smallWidth = Persian.GDevice.Viewport.Width / 7;
            var smallHeigth = Persian.GDevice.Viewport.Height / 6;

            //Show depth
            spriteBatch.Draw(
                this.lBuffer.depthBuffer, 
                new Rectangle(0, 0, smallWidth, smallHeigth), 
                Color.White);

            //Show normal
            spriteBatch.Draw(
                this.lBuffer.normalBuffer, 
                new Rectangle(smallWidth, 0, smallWidth, smallHeigth), 
                Color.White);

            //Show light
            spriteBatch.Draw(
                this.lBuffer.lightBuffer,
                new Rectangle(smallWidth * 2, 0, smallWidth, smallHeigth), 
                Color.White);

            //Show first shadow cascaded
            if (ShadowMapTexture != null )
            {
                //Show first shadow caster
                spriteBatch.Draw(
                    ShadowMapTexture,
                    new Rectangle(smallWidth * 3, 0, smallWidth, smallHeigth), Color.White);
            }

            if (lBuffer.glowBuffer != null)
            {
                //Show first shadow caster
                spriteBatch.Draw(
                    lBuffer.glowBuffer,
                    new Rectangle(smallWidth * 4, 0, smallWidth, smallHeigth), Color.White);
            }
        }

        #endregion

        #region Dispose

        protected override void Dispose(bool disposing)
        {
            SystemMemory.SafeDispose(this.gBuffer);
            SystemMemory.SafeDispose(this.lBuffer);
            SystemMemory.SafeDispose(this.downSample);
            SystemMemory.SafeDispose(this.lightStencilStates);
            SystemMemory.SafeDispose(this.depthBufferParam);
            SystemMemory.SafeDispose(this.normalMapParam);
            SystemMemory.SafeDispose(this.tanAspectRatioParam);
            SystemMemory.SafeDispose(this.lightPositionParam);
            SystemMemory.SafeDispose(this.cascadeDistancesParam);
            SystemMemory.SafeDispose(this.lightDirParam);
            SystemMemory.SafeDispose(this.LightColorParam);
            SystemMemory.SafeDispose(this.invertLightRadiusSqrParam);
            SystemMemory.SafeDispose(this.farClipParam);
            SystemMemory.SafeDispose(this.worldViewProjectionParam);
            SystemMemory.SafeDispose(this.spotAngleParam);
            SystemMemory.SafeDispose(this.LightColorParam);
            SystemMemory.SafeDispose(this.spotPowerParam);
            SystemMemory.SafeDispose(this.spotLightViewProjectionParam);
            SystemMemory.SafeDispose(this.shadowMapPixelSizeParam);
            SystemMemory.SafeDispose(this.depthBiasParam);
            SystemMemory.SafeDispose(this.shadowMapSizeParam);
            SystemMemory.SafeDispose(this.shadowMapParam);
            SystemMemory.SafeDispose(this.cameraWorldParam);
            SystemMemory.SafeDispose(this.clipPlanesParam);
            SystemMemory.SafeDispose(this.lightViewProjectionParam);
            SystemMemory.SafeDispose(this.reConstructPixelSizeParam);
            SystemMemory.SafeDispose(this.reConstructDepthBufferParam);
            SystemMemory.SafeDispose(this.reConstructFarClipParam);
            SystemMemory.SafeDispose(this.reConstructProjectionParam);
            SystemMemory.SafeDispose(this.usePCF2X2Param);

            base.Dispose(disposing);
        }

        #endregion
    }
}