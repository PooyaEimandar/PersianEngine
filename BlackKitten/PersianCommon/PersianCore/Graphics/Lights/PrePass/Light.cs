/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : Light.cs
 * File Description : The light
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 8/9/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using System.ComponentModel;

namespace PersianCore.Graphics.Lights
{
    public enum LightType : byte
    {
        Directional,
        Point,
        Spot
    }

    public class Light
    {
        #region Fields & Properties

        public float DepthBias { get; set; }

        public string Name { get; set; }

        public bool Enable { get; set; }

        Matrix inverseWorld;
        Matrix world;

        [DoNotSave]
        [Browsable(false)]
        public Matrix World
        {
            get
            {
                return this.world;
            }
            set
            {
                this.world = value;
                Matrix.Invert(ref this.world, out this.inverseWorld);
                this.boundingSphere.Center = world.Translation;
                if (lightType == LightType.Spot)
                {
                    UpdateSpotValues();
                }
            }
        }

        BoundingSphere boundingSphere;
        [DoNotSave]
        [Browsable(false)]
        public BoundingSphere BoundingSphere
        {
            get
            {
                return this.boundingSphere;
            }
        }

        BoundingFrustum frustum;
        [DoNotSave]
        [Browsable(false)]
        public BoundingFrustum Frustum
        {
            get
            {
                return this.frustum;
            }
        }

        float radius;
        public float Radius
        {
            get
            {
                return radius;
            }
            set
            {
                this.radius = value;
                this.boundingSphere.Radius = radius;
                if (this.lightType == LightType.Spot)
                {
                    UpdateSpotValues();
                }
            }
        }

        bool alwaysVisible;
        public bool AlwaysVisible
        {
            get
            {
                return this.alwaysVisible;
            }
            set
            {
                if (this.alwaysVisible != value)
                {
                    this.alwaysVisible = value;
                }
            }
        }

        public float Intensity { get; set; }
        public float SpecularIntensity { get; set; }
        public Vector4 Color { get; set; }

        float spotAngle;
        public float SpotAngle
        {
            get
            {
                return this.spotAngle;
            }
            set
            {
                if (this.spotAngle != value)
                {
                    this.spotAngle = value;
                    if (this.spotAngle >= 90.0f)
                    {
                        this.spotAngle = 89.0f;
                    }
                    if (this.lightType == LightType.Spot)
                    {
                        UpdateSpotValues();
                    }
                }
            }
        }

        public float SpotExponent { get; set; }

        Matrix viewProjection;
        [DoNotSave]
        [Browsable(false)]
        public Matrix ViewProjection
        {
            get
            {
                return this.viewProjection;
            }
        }

        [DoNotSave]
        [Browsable(false)]
        public float DistanceFromCamera { get; set; }
        public float Priority { get; set; }

        Vector3 rotation;
        public Vector3 Rotation
        {
            get
            {
                return this.rotation;
            }
            set
            {
                if (this.rotation != value)
                {
                    this.rotation = value;
                    this.world = Matrix.CreateRotationX(value.X) *
                        Matrix.CreateRotationY(value.Y) *
                        Matrix.CreateRotationZ(value.Z) *
                        Matrix.CreateTranslation(this.position);
                }
            }
        }

        Vector3 position;
        public Vector3 Position
        {
            get
            {
                return this.world.Translation;
            }
            set
            {
                if (this.position != value)
                {
                    this.position = value;
                    this.world.Translation = value;
                }
            }
        }

        LightType lightType;
        public LightType LightType
        {
            get
            {
                return this.lightType;
            }
            set
            {
                if (this.lightType != value)
                {
                    this.lightType = value;
                }
            }
        }

        #region Shodow's Properties

        public bool EnableShadow { get; set; }
        public float ShadowDistance { get; set; }
        [DoNotSave]
        [Browsable(false)]
        public Shadow.SpotShadowMapEntry spotShadowMap { get; set; }
        [DoNotSave]
        [Browsable(false)]
        public Shadow.CascadeShadowMapEntry cascadeShadowMap { get; set; }

        #endregion

        #endregion

        #region Constructor/Destructor

        public Light()
            : this(LightType.Directional, Vector3.Zero,
                new Vector3(1.0f, 10.0f, 10.0f), Microsoft.Xna.Framework.Color.LightYellow, 1.0f)
        {
        }

        public Light(LightType lightType, Vector3 position, Vector3 rotation, Color color, float intensity)
        {
            this.lightType = lightType;
            this.EnableShadow = true;
            this.position = position;
            this.rotation = rotation;
            this.Color = color.ToVector4();
            this.Intensity = intensity;

            this.Enable = true;
            this.Name = "Light";
            this.world = this.rotation.ToRotationMatrix() * Matrix.CreateTranslation(this.position);
            this.inverseWorld = Matrix.Invert(this.world);
            this.radius = 1;
            this.Intensity = 1;
            this.SpecularIntensity = 1;
            this.spotAngle = 45;
            this.SpotExponent = 10;
            this.viewProjection = Matrix.Identity;
            this.DepthBias = 0.005f;
            this.ShadowDistance = 70;
            this.boundingSphere = new BoundingSphere(world.Translation, radius);
            this.frustum = new BoundingFrustum(Matrix.Identity);

            if (this.lightType == LightType.Spot)
            {
                UpdateSpotValues();
            }
        }

        #endregion

        #region Update

        public void UpdateSpotValues()
        {
            var projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.ToRadians(spotAngle * 2), 1, 0.01f * radius, radius);
            Matrix.Multiply(ref inverseWorld, ref projection, out viewProjection);
            Frustum.Matrix = viewProjection;
        }

        #endregion
    }
}
