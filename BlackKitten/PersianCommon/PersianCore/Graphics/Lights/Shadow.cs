/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : ShadowRenderer.cs
 * File Description : This class responsible to render the shadow
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 5/15/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Meshes;
using System;
using System.Collections.Generic;

namespace PersianCore.Graphics.Lights
{
    public class Shadow
    {
        #region Constants

        const int NUM_CSM_SPLITS = 3;
        const int NUM_SPOT_SHADOWS = 4;
        const int NUM_CSM_SHADOWS = 1;

        #endregion

        #region Fields & Properties

        /// <summary>
        /// This struct holds all information to render the shadows
        /// </summary>
        public class SpotShadowMapEntry
        {
            #region Fields & Properties

            public RenderTarget Target;
            public Matrix LightViewProjection;

            #endregion

            internal void Dispose()
            {
                Target.Dispose();
            }
        }

        public class CascadeShadowMapEntry
        {
            #region Fields & Properties

            public RenderTarget Target;
            public Matrix[] LightViewProjectionMatrices;
            public Vector2[] LightClipPlanes;

            #endregion

            #region Constructor

            public CascadeShadowMapEntry()
            {
                this.LightViewProjectionMatrices = new Matrix[NUM_CSM_SPLITS];
                this.LightClipPlanes = new Vector2[NUM_CSM_SPLITS];
            }

            #endregion

            internal void Dispose()
            {
                Target.Dispose();
            }
        }

        float[] splitDepthsTmp;
        Vector3[] frustumCornersWS;
        Vector3[] frustumCornersVS;
        Vector3[] splitFrustumCornersVS;
        /// <summary>
        /// Store the frustum as planes, as we are tweaking the far plane
        /// </summary>
        Plane[] directionalClippingPlanes;
        /// <summary>
        /// Temporary frustum, to create the clipping planes above
        /// </summary>
        BoundingFrustum tempFrustum;
        List<SpotShadowMapEntry> spotShadowMaps;
        List<CascadeShadowMapEntry> cascadeShadowMaps;
        List<Meshes.Mesh> visibleMeshes;
        int currentFreeSpotShadowMap;
        int currentFreeCascadeShadowMap;

        int cascade_shadow_resolution;
        public int CASCADE_SHADOW_RESOLUTION
        {
            get
            {
                return this.cascade_shadow_resolution;
            }
            set
            {
                if (this.cascade_shadow_resolution != value)
                {
                    this.cascade_shadow_resolution = value;
                }
            }
        }

        int spot_shadow_resolution;
        public int SPOT_SHADOW_RESOLUTION
        {
            get
            {
                return this.spot_shadow_resolution;
            }
            set
            {
                if (this.spot_shadow_resolution != value)
                {
                    this.spot_shadow_resolution = value;
                }
            }
        }

        #endregion

        #region Constructor/Destructor

        public Shadow()
        {
            this.cascade_shadow_resolution = 1024;
            this.spot_shadow_resolution = 512;
            Initialize();
        }

        ~Shadow()
        {
        }

        #endregion

        #region Initialize

        public void Initialize()
        {
            this.currentFreeSpotShadowMap = 0;
            this.currentFreeCascadeShadowMap = 0;
        }

        #endregion

        #region Load

        public void Load(ContentManager Content)
        {
            this.splitDepthsTmp = new float[NUM_CSM_SPLITS + 1];
            this.frustumCornersWS = new Vector3[8];
            this.frustumCornersVS = new Vector3[8];
            this.splitFrustumCornersVS = new Vector3[8];
            this.directionalClippingPlanes = new Plane[6];
            this.tempFrustum = new BoundingFrustum(Matrix.Identity);
            this.spotShadowMaps = new List<SpotShadowMapEntry>();
            this.cascadeShadowMaps = new List<CascadeShadowMapEntry>();
            this.visibleMeshes = new List<Mesh>(100);

            //Create the render targets
            CreateSpotRenderTarget();
            CreateCascadeRenderTarget();

        }

        private void CreateSpotRenderTarget()
        {
            for (int i = 0; i < NUM_SPOT_SHADOWS; i++)
            {
                var entry = new SpotShadowMapEntry()
                {
                    //we store the linear depth, in a float render target. We need also the HW zbuffer
                    Target = new RenderTarget(
                        SPOT_SHADOW_RESOLUTION,
                        SPOT_SHADOW_RESOLUTION,
                        false,
                        SurfaceFormat.Single,
                        DepthFormat.Depth24Stencil8,
                        0,
                        RenderTargetUsage.DiscardContents),
                    LightViewProjection = Matrix.Identity,
                };
                this.spotShadowMaps.Add(entry);
            }
        }

        private void CreateCascadeRenderTarget()
        {
            for (int i = 0; i < NUM_CSM_SHADOWS; i++)
            {
                var entry = new CascadeShadowMapEntry()
                {
                    Target = new RenderTarget(
                        CASCADE_SHADOW_RESOLUTION * NUM_CSM_SPLITS,
                        CASCADE_SHADOW_RESOLUTION,
                        false,
                        SurfaceFormat.Single,
                        DepthFormat.Depth24Stencil8,
                        0,
                        RenderTargetUsage.DiscardContents)
                };
                this.cascadeShadowMaps.Add(entry);
            }
        }

        #endregion

        #region Methods

        /// <summary>
        /// Returns an unused shadow map, or null if we run out of SMs
        /// </summary>
        /// <returns></returns>
        internal SpotShadowMapEntry GetFreeSpotShadowMap()
        {
            if (this.currentFreeSpotShadowMap < this.spotShadowMaps.Count)
            {
                return this.spotShadowMaps[this.currentFreeSpotShadowMap++];
            }
            return null;
        }

        /// <summary>
        /// Returns an unused cascade shadow map, or null if we run out of SMs
        /// </summary>
        /// <returns></returns>
        internal CascadeShadowMapEntry GetFreeCascadeShadowMap()
        {
            if (this.currentFreeCascadeShadowMap < this.cascadeShadowMaps.Count)
            {
                return this.cascadeShadowMaps[this.currentFreeCascadeShadowMap++];
            }
            return null;
        }

        /// <summary>
        /// Used for cascade shadow maps
        /// </summary>
        /// <param name="frustum"></param>
        /// <param name="additionalPlanes"></param>
        /// <param name="visibleSubMeshes"></param>
        public void GetShadowCasters(BoundingFrustum frustum, Plane[] additionalPlanes,
            List<Mesh> _worldSubMeshes, List<Mesh> visibleSubMeshes)
        {
            BoundingSphere bSphere;
            for (int index = 0; index < _worldSubMeshes.Count; index++)
            {
                var mesh = _worldSubMeshes[index];
                bSphere = mesh.PhysicData.boundingSphere;
                if (mesh.EnableShadow && frustum.Intersects(bSphere))
                {
                    //cull sub meshes outside the sub frustum
                    bool outside = false;
                    for (int p = 0; p < 6; p++)
                    {
                        PlaneIntersectionType intersectionType;

                        var BS = mesh.PhysicData.boundingSphere;
                        additionalPlanes[p].Intersects(ref BS, out intersectionType);
                        if (intersectionType == PlaneIntersectionType.Front)
                        {
                            outside = true;
                            break;
                        }
                        
                        BS = mesh.PhysicData.boundingSphere;
                        additionalPlanes[p].Intersects(ref BS, out intersectionType);
                        if (intersectionType == PlaneIntersectionType.Front)
                        {
                            outside = true;
                            break;
                        }
                    }
                    if (outside) continue;
                    visibleSubMeshes.Add(mesh);
                }
            }
        }

        public void GetShadowCasters(BoundingFrustum frustum, List<Mesh> _worldSubMeshes, List<Mesh> visibleSubMeshes)
        {
            for (int index = 0; index < _worldSubMeshes.Count; index++)
            {
                var subMesh = _worldSubMeshes[index];
                if (subMesh.EnableShadow &&
                    frustum.Intersects(subMesh.PhysicData.boundingSphere))
                {
                    visibleSubMeshes.Add(subMesh);
                }
            }
        }

        /// <summary>
        /// Generate the shadow map for a given spot light
        /// </summary>
        /// <param name="renderer"></param>
        /// <param name="meshes"></param>
        /// <param name="light"></param>
        /// <param name="shadowMap"></param>
        public void GenerateShadowTextureSpotLight(Light light, SpotShadowMapEntry shadowMap, ObjectsManager meshManager)
        {
            //bind the render target
            shadowMap.Target.Begin();
            {
                //clear it to white, ie, far far away
                Persian.GDevice.Clear(Color.White);
                Persian.GDevice.BlendState = BlendState.Opaque;
                Persian.GDevice.DepthStencilState = DepthStencilState.Default;


                Matrix viewProj = light.ViewProjection;
                shadowMap.LightViewProjection = viewProj;
                BoundingFrustum frustum = light.Frustum;

                this.visibleMeshes.Clear();
                //cull meshes outside the light volume
                GetShadowCasters(frustum, meshManager.Meshes, visibleMeshes);

                //Render all
                meshManager.DrawShadowMap(ref viewProj);
                shadowMap.Target.End();
            }
        }

        /// <summary>
        /// Generate the cascade shadow map for a given directional light
        /// </summary>
        /// <param name="renderer"></param>
        /// <param name="meshes"> All meshes in the world</param>
        /// <param name="light"></param>
        /// <param name="cascadeShadowMap"></param>
        /// <param name="camera"></param>
        public void GenerateShadowTextureDirectionalLight(Light light,
            CascadeShadowMapEntry cascadeShadowMap, ObjectsManager meshManager)
        {
            var GDevice = Persian.GDevice;

            //bind the render target
            cascadeShadowMap.Target.Begin();
            {
                GDevice.Clear(Color.White);
                GDevice.BlendState = BlendState.Opaque;
                GDevice.DepthStencilState = DepthStencilState.Default;

                // Get the corners of the frustum
                Persian.Camera.Frustum.GetCorners(frustumCornersWS);
                var eyeTransform = Persian.Camera.View;
                Vector3.Transform(frustumCornersWS, ref eyeTransform, frustumCornersVS);

                float near = Persian.Camera.NearClip, far = MathHelper.Min(Persian.Camera.FarClip, light.ShadowDistance);
                splitDepthsTmp[0] = near;
                splitDepthsTmp[NUM_CSM_SPLITS] = far;

                //compute each distance the way you like...
                for (int i = 1; i < splitDepthsTmp.Length - 1; i++)
                {
                    splitDepthsTmp[i] = near + (far - near) * (float)Math.Pow((i / (float)NUM_CSM_SPLITS), 1.6f);
                }

                var splitViewport = new Viewport();
                var lightDir = -Vector3.Normalize(light.World.Forward);

                //PlaneIntersectionType intersectionType;
                for (int i = 0; i < NUM_CSM_SPLITS; i++)
                {
                    cascadeShadowMap.LightClipPlanes[i].X = -splitDepthsTmp[i];
                    cascadeShadowMap.LightClipPlanes[i].Y = -splitDepthsTmp[i + 1];

                    cascadeShadowMap.LightViewProjectionMatrices[i] = CreateLightViewProjectionMatrix(lightDir, splitDepthsTmp[i], splitDepthsTmp[i + 1], i);
                    Matrix viewProj = cascadeShadowMap.LightViewProjectionMatrices[i];
                    tempFrustum.Matrix = viewProj;
                    //we tweak the near plane, so keep all other planes
                    directionalClippingPlanes[0] = tempFrustum.Left;
                    directionalClippingPlanes[1] = tempFrustum.Right;
                    directionalClippingPlanes[2] = tempFrustum.Bottom;
                    directionalClippingPlanes[3] = tempFrustum.Top;
                    directionalClippingPlanes[4] = tempFrustum.Far;
                    //the near clipping plane is set inside the CreateLightViewProjectionMatrix method, keep it

                    // Set the view port for the current split     
                    splitViewport.MinDepth = 0;
                    splitViewport.MaxDepth = 1;
                    splitViewport.Width = CASCADE_SHADOW_RESOLUTION;
                    splitViewport.Height = CASCADE_SHADOW_RESOLUTION;
                    splitViewport.X = i * CASCADE_SHADOW_RESOLUTION;
                    splitViewport.Y = 0;
                    GDevice.Viewport = splitViewport;

                    tempFrustum.Matrix = viewProj;

                    visibleMeshes.Clear();

                    GetShadowCasters(tempFrustum, directionalClippingPlanes, meshManager.Meshes, visibleMeshes);
                    //Now Render it
                    foreach (var subMesh in visibleMeshes)
                    {
                        subMesh.DrawShadowMap(ref viewProj);
                    }
                }
                cascadeShadowMap.Target.End();
            }
        }

        public static Texture2D bluredShadow;
        /// <summary>
        /// Creates the WorldViewProjection matrix from the perspective of the 
        /// light using the cameras bounding frustum to determine what is visible 
        /// in the scene.
        /// </summary>
        /// <returns>The WorldViewProjection for the light</returns>
        Matrix CreateLightViewProjectionMatrix(Vector3 lightDir, float minZ, float maxZ, int index)
        {
            for (int i = 0; i < 4; i++)
            {
                splitFrustumCornersVS[i] = frustumCornersVS[i + 4] * (minZ / Persian.Camera.FarClip);
            }

            for (int i = 4; i < 8; i++)
            {
                splitFrustumCornersVS[i] = frustumCornersVS[i] * (maxZ / Persian.Camera.FarClip);
            }

            var cameraWorld = Persian.Camera.World;
            Vector3.Transform(splitFrustumCornersVS, ref cameraWorld, frustumCornersWS);

            // Matrix with that will rotate in points the direction of the light
            var cameraUpVector = Vector3.Up;
            if (Math.Abs(Vector3.Dot(cameraUpVector, lightDir)) > 0.9f)
            {
                cameraUpVector = Vector3.Forward;
            }

            var lightRotation = Matrix.CreateLookAt(Vector3.Zero, -lightDir, cameraUpVector);
            // Transform the positions of the corners into the direction of the light
            for (int i = 0; i < frustumCornersWS.Length; i++)
            {
                frustumCornersWS[i] = Vector3.Transform(frustumCornersWS[i], lightRotation);
            }

            #region Find the smallest box around the points

            Vector3 mins = frustumCornersWS[0], maxes = frustumCornersWS[0];
            for (int i = 1; i < frustumCornersWS.Length; i++)
            {
                var p = frustumCornersWS[i];
                if (p.X < mins.X) mins.X = p.X;
                if (p.Y < mins.Y) mins.Y = p.Y;
                if (p.Z < mins.Z) mins.Z = p.Z;
                if (p.X > maxes.X) maxes.X = p.X;
                if (p.Y > maxes.Y) maxes.Y = p.Y;
                if (p.Z > maxes.Z) maxes.Z = p.Z;
            }

            #endregion

            #region Find the smallest box around the points in view space

            Vector3 minsVS = splitFrustumCornersVS[0], maxesVS = splitFrustumCornersVS[0];
            for (int i = 1; i < splitFrustumCornersVS.Length; i++)
            {
                var p = splitFrustumCornersVS[i];
                if (p.X < minsVS.X) minsVS.X = p.X;
                if (p.Y < minsVS.Y) minsVS.Y = p.Y;
                if (p.Z < minsVS.Z) minsVS.Z = p.Z;
                if (p.X > maxesVS.X) maxesVS.X = p.X;
                if (p.Y > maxesVS.Y) maxesVS.Y = p.Y;
                if (p.Z > maxesVS.Z) maxesVS.Z = p.Z;
            }

            #endregion

            var lightBoundingBox = new BoundingBox(mins, maxes);

            #region Fixing jitter of shadow

            // I borrowed this code from some forum that I don't remember anymore =/
            // We snap the camera to 1 pixel increments so that moving the camera does not cause the shadows to jitter.
            // This is a matter of integer dividing by the world space size of a texel
            float diagonalLength = (frustumCornersWS[0] - frustumCornersWS[6]).Length();
            diagonalLength += 2; //Without this, the shadow map isn't big enough in the world.
            float worldsUnitsPerTexel = diagonalLength / (float)CASCADE_SHADOW_RESOLUTION;

            var vBorderOffset = (new Vector3(diagonalLength, diagonalLength, diagonalLength) -
                                     (lightBoundingBox.Max - lightBoundingBox.Min)) * 0.5f;
            lightBoundingBox.Max += vBorderOffset;
            lightBoundingBox.Min -= vBorderOffset;

            lightBoundingBox.Min /= worldsUnitsPerTexel;
            lightBoundingBox.Min.X = (float)Math.Floor(lightBoundingBox.Min.X);
            lightBoundingBox.Min.Y = (float)Math.Floor(lightBoundingBox.Min.Y);
            lightBoundingBox.Min.Z = (float)Math.Floor(lightBoundingBox.Min.Z);
            lightBoundingBox.Min *= worldsUnitsPerTexel;

            lightBoundingBox.Max /= worldsUnitsPerTexel;
            lightBoundingBox.Max.X = (float)Math.Floor(lightBoundingBox.Max.X);
            lightBoundingBox.Max.Y = (float)Math.Floor(lightBoundingBox.Max.Y);
            lightBoundingBox.Max.Z = (float)Math.Floor(lightBoundingBox.Max.Z);
            lightBoundingBox.Max *= worldsUnitsPerTexel;

            #endregion

            var boxSize = lightBoundingBox.Max - lightBoundingBox.Min;
            if (boxSize.X == 0 || boxSize.Y == 0 || boxSize.Z == 0)
            {
                boxSize = Vector3.One;
            }
            var halfBoxSize = boxSize * 0.5f;

            // The position of the light should be in the center of the back panel of the box. 
            var lightPosition = lightBoundingBox.Min + halfBoxSize;
            lightPosition.Z = lightBoundingBox.Min.Z;

            // We need the position back in world coordinates so we transform 
            // the light position by the inverse of the lights rotation
            lightPosition = Vector3.Transform(lightPosition, Matrix.Invert(lightRotation));

            // Create the view matrix for the light
            var lightView = Matrix.CreateLookAt(lightPosition, lightPosition - lightDir, cameraUpVector);

            // Create the projection matrix for the light
            // The projection is orthographic since we are using a directional light
            var lightProjection = Matrix.CreateOrthographic(boxSize.X, boxSize.Y, -boxSize.Z, 0);

            var lightDirVS = Vector3.TransformNormal(-lightDir, Persian.Camera.View);
            //check if the light is in the same direction as the camera
            if (lightDirVS.Z > 0)
            {
                //use the far point as clipping plane
                var p = new Plane(-Vector3.Forward, maxesVS.Z);
                Plane.Transform(ref p, ref cameraWorld, out directionalClippingPlanes[5]);
            }
            else
            {
                //use the closest point as clipping plane
                var p = new Plane(Vector3.Forward, minsVS.Z);
                Plane.Transform(ref p, ref cameraWorld, out directionalClippingPlanes[5]);
            }

            return lightView * lightProjection;
        }

        #endregion
    }
}