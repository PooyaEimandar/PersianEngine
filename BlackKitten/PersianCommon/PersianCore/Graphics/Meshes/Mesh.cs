/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : Mesh.cs
 * File Description : The mesh
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 7/29/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Framework;
using PersianCore.Graphics;
using PersianCore.Meshes.Components;
using PersianCore.Physic;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Reflection;

namespace PersianCore.Meshes
{
    public class Mesh : BaseMesh, IBinding, INotifyPropertyChanged, ICloneable, IComparable
    {
        // public enum Behvioral { Idle, Shooting, Reloading, Aiming, FixToFire, Walk, Run };
        public enum TextureToBeChanged { DiffuseMap, NormalMap, SpecularMap, GlowMap }

        #region Fields & Properties

        public struct TextureToBeChangedInfo
        {
            #region Fields & Properties

            public string MeshName;
            public TextureToBeChanged textureToBeChanged;

            #endregion

            #region Constructor

            public TextureToBeChangedInfo(TextureToBeChanged TextureToBeChanged, string MeshName)
            {
                this.textureToBeChanged = TextureToBeChanged;
                this.MeshName = MeshName;
            }

            #endregion
        }

        BasicEffect occlusionEffect;
        public OcclusionQuery occlusionQuery;

        public TextureToBeChangedInfo textureToBeChangedInfo;
        public bool isInSigh;
        public event PropertyChangedEventHandler PropertyChanged;
        public AnimationMeshData AnimData;
        public PhysicMeshData PhysicData;
        public ObjectMeshData ObjectData;

        [DoNotSave]
        public bool Enable { get; set; }

        [DoNotSave]
        public bool EnableBinding { get; set; }
        /// <summary>
        /// Cast shadow or not
        /// </summary>
        public bool EnableShadow { get; set; }

        string StartAnimationName;
        [Browsable(false)]
        public string CurrentAnimationName
        {
            get
            {
                return this.AnimData != null ? this.AnimData.CurrentAnimation.Name : string.Empty;
            }
            set
            {
                if (this.AnimData != null)
                {
                    if (!string.IsNullOrEmpty(value))
                    {
                        this.AnimData.CurrentAnimationName = value;
                        bool find = this.AnimData.SetAnimationUpponName();
                        if (find)
                        {
                            NotifyPropertyChanged("CurrentAnimationName");
                        }
                    }
                }
                else
                {
                    //is firstTime
                    this.StartAnimationName = value;
                }
            }
        }

        float currentAnimationFrame;
        [DoNotSave]
        [Browsable(false)]
        public float CurrentAnimationFrame
        {
            get
            {
                return this.currentAnimationFrame;
            }
            set
            {
                if (this.currentAnimationFrame != value)
                {
                    this.currentAnimationFrame = value;
                    NotifyPropertyChanged("CurrentAnimationFrame");
                }
            }
        }

        long currentAnimationTotalFrames;
        [DoNotSave]
        [Browsable(false)]
        public long CurrentAnimationTotalFrames
        {
            get
            {
                return this.currentAnimationTotalFrames;
            }
            set
            {
                if (this.currentAnimationTotalFrames != value)
                {
                    this.currentAnimationTotalFrames = value;
                    NotifyPropertyChanged("CurrentAnimationTotalFrames");
                }
            }
        }

        [DoNotSave]
        [Browsable(false)]
        public Matrix World
        {
            get
            {
                return this.PhysicData.World;
            }
            set
            {
                this.PhysicData.World = value;
            }
        }

        [DoNotSave]
        [Browsable(false)]
        public BoneData[] BonesData
        {
            get
            {
                if (this.AnimData != null)
                {
                    return this.AnimData.Bones;
                }
                return null;
            }
        }

        [Browsable(false)]
        public float SelectionColor
        {
            get
            {
                return this.ObjectData.SelectionColor;
            }
            set
            {
                this.ObjectData.SelectionColor = value;
            }
        }

        [Browsable(false)]
        public Guid GUID
        {
            get
            {
                return this.ObjectData.GUID;
            }
            set
            {
                this.ObjectData.GUID = value;
            }
        }

        [DoNotSave]
        [Browsable(false)]
        public Model Model
        {
            get
            {
                return this.ObjectData.model;
            }
        }

        [DoNotSave]
        [Browsable(false)]
        public Dictionary<string, object> ModelTag
        {
            get
            {
                return (Dictionary<string, object>)this.ObjectData.model.Tag;
            }
        }

        [Browsable(false)]
        public bool InverseAnimation
        {
            get
            {
                return this.AnimData != null ? this.AnimData.Player.IsInReverse : false;
            }
            set
            {
                if (IsSkinned)
                {
                    this.AnimData.Player.IsInReverse = value;
                }
            }
        }

        [DoNotSave]
        [Browsable(false)]
        public List<string> Animations
        {
            get
            {
                if (this.IsSkinned)
                {
                    var Animations = new List<string>();
                    foreach (var clip in this.AnimData.skinningData.AnimationClips)
                    {
                        Animations.Add(clip.Name);
                    }
                    foreach (string clipName in this.AnimData.Mixers.Keys)
                    {
                        Animations.Add(clipName);
                    }
                    return Animations;
                }
                return null;
            }
        }

        List<MixerInfo> mixerTracks;
        [Browsable(false)]
        public List<MixerInfo> MixerTracks
        {
            get
            {
                if (this.AnimData != null)
                {
                    return this.AnimData.MixerInfos;
                }
                return mixerTracks;
            }
            set
            {
                this.mixerTracks = value;
                if (this.AnimData != null)
                {
                    this.AnimData.MixerInfos = value;
                }
            }
        }

        [Browsable(false)]
        [DoNotSave]
        public bool InViewFrustum
        {
            get
            {
                return Persian.Camera.Frustum.Intersects(this.PhysicData.boundingBox);
            }
        }

        PropertyInfo bindSourceProperty;
        PropertyInfo bindToProperty;
        /// <summary>
        /// Set it after setting BindTo
        /// </summary>
        public string BindProperty
        {
            get
            {
                if (bindToProperty != null)
                {
                    return this.bindToProperty.Name;
                }
                return null;
            }
            set
            {
                if ((this.bindToProperty == null || this.bindToProperty.Name != value) &&
                    this.BindTo != null)
                {
                    this.bindToProperty = this.BindTo.GetType().GetProperty(value);
                    this.bindSourceProperty = this.GetType().GetProperty(value);
                }
            }
        }

        /// <summary>
        /// Set it after setting BindTo
        /// </summary>
        [Browsable(false)]
        [DoNotSave]
        public string BindToBoneName
        {
            get
            {
                if (BindToBone != null)
                {
                    return this.BindToBone.Name;
                }
                return null;
            }
            set
            {
                if (this.BindTo != null && this.BindTo is Mesh &&
                    (this.BindToBone == null || (this.BindToBone != null && this.BindToBone.Name != value)))
                {
                    var bones = (this.BindTo as Mesh).BonesData;
                    for (int i = 0; i < bones.Length; ++i)
                    {
                        if (bones[i].Name.ToLower() == value.ToLower())
                        {
                            BindToBone = bones[i];
                            break;
                        }
                    }
                }
            }
        }

        [Browsable(false)]
        [DoNotSave]
        public IBinding BindTo { get; set; }
        BoneData BindToBone { get; set; }

        /// <summary>
        /// Set position offset for binded object
        /// </summary>
        public Vector3 BindToBonePositionOffset { get; set; }
        /// <summary>
        /// Set rotation offset for binded object
        /// </summary>
        public Vector3 BindToBoneRotationOffset { get; set; }

        [Browsable(false)]
        public Dictionary<string, List<string>> DiffuseMaps
        {
            get
            {
                return this.ObjectData.DiffuseMaps;
            }
            set
            {
                this.ObjectData.DiffuseMaps = value;
            }
        }

        #endregion

        #region Categories

        #region Object's Category

        [Description("Must live until end")]
        [Category("Object")]
        public bool MustLiveUntilEnd { get; set; }

        [Description("Texture Level of detail")]
        [Category("Object")]
        public float TextureLOD
        {
            get
            {
                return this.ObjectData.TextureLOD;
            }
            set
            {
                this.ObjectData.TextureLOD = value;
            }
        }

        [Description("Get or set Tag")]
        [Category("Object")]
        public object Tag
        {
            get { return this.CTag; }
            set { this.CTag = value; }
        }

        string modelPath;
        [Description("Get or set physical path of model")]
        [Category("Object")]
        public string ModelPath
        {
            get
            {
                return this.modelPath;
            }
            set
            {
                this.modelPath = value;
                NotifyPropertyChanged("ModelPath");
            }
        }

        [DoNotSave]
        [Description("Get count of triangles")]
        [Category("Object")]
        public double TrianglesCounts
        {
            get
            {
                object trianglesCounts = null;
                if ((this.ObjectData.model.Tag as Dictionary<string, object>).TryGetValue("Vertices", out trianglesCounts))
                {
                    return (trianglesCounts as Vector3[]).Length / 3;
                }
                return 0;
            }
        }

        [Description("Get or set identity of model")]
        [Category("Object")]
        public string ID
        {
            get { return this.ObjectData.ID; }
            set { this.ObjectData.ID = value; }
        }

        [Description("Get all bones of model")]
        [Category("Object")]
        [DoNotSave]
        public ModelBoneCollection ModelBones
        {
            get { return this.ObjectData.model.Bones; }
        }

        [Description("Get meshes of model")]
        [Category("Object")]
        [DoNotSave]
        public ModelMeshCollection ModelMeshes
        {
            get { return this.ObjectData.model.Meshes; }
        }

        [Description("Always Visible")]
        [Category("Object")]
        public bool AlwaysVisible { get; set; }

        [Description("Get or set visibility")]
        [Category("Object")]
        public bool Visibility
        {
            get
            {
                return this.PhysicData.Visibility;
            }
            set
            {
                this.PhysicData.Visibility = value;
            }
        }

        #endregion

        #region Effect's Category

        [Description("Enable/Disable Enviroment Mapping")]
        [Category("Effect")]
        public bool UseEnviromentMapping
        {
            get
            {
                return this.ObjectData.EnvironmentMapping;
            }
            set
            {
                this.ObjectData.EnvironmentMapping = value;
            }
        }

        [Description("Reflectivity of Enviroment Mapping")]
        [Category("Effect")]
        public float Reflectivity
        {
            get
            {
                return this.ObjectData.Reflectivity;
            }
            set
            {
                this.ObjectData.Reflectivity = value;
            }
        }

        [Description("Enable/Disable Alpha Transparency")]
        [Category("Effect")]
        public bool AlphaTransparency
        {
            get
            {
                return this.ObjectData.AlphaTransparency;
            }
            set
            {
                this.ObjectData.AlphaTransparency = value;
            }
        }

        [Description("Ambient Color")]
        [Category("Effect")]
        public Vector4 AmbientColor
        {
            get
            {
                return this.ObjectData.AmbientColor;
            }
            set
            {
                this.ObjectData.AmbientColor = value;
            }
        }

        [Description("Use Glow")]
        [Category("Effect")]
        public bool UseGlow
        {
            get
            {
                return this.ObjectData.UseGlow;
            }
            set
            {
                this.ObjectData.UseGlow = value;
            }
        }

        [Description("Glow Intensity")]
        [Category("Effect")]
        public float GlowIntensity
        {
            get
            {
                return this.ObjectData.GlowIntensity;
            }
            set
            {
                this.ObjectData.GlowIntensity = value;
            }
        }

        [Description("Glow Color")]
        [Category("Effect")]
        public Vector3 GlowColor
        {
            get
            {
                return this.ObjectData.GlowColor;
            }
            set
            {
                this.ObjectData.GlowColor = value;
            }
        }

        #endregion

        #region Animation's Category

        [Description("Get whether this object is animated or not")]
        [Category("Animation")]
        [DoNotSave]
        public bool IsSkinned
        {
            get
            {
                return this.AnimData == null || this.AnimData.skinningData == null ? false : true;
            }
        }

        float[] animationSpeedsArray;
        /// <summary>
        /// Array of all Animations Speed... just for saving or loading
        /// </summary>
        [Browsable(false)]
        public float[] AnimationSpeedsArray
        {
            get
            {
                return !this.IsSkinned || this.AnimData.CurrentAnimation == null ? null : this.AnimData.AnimationsSpeeds;
            }
            set
            {
                animationSpeedsArray = value;
            }
        }

        [Description("Get or Set current animation speed")]
        [Category("Animation")]
        [DoNotSave]
        public float AnimationSpeed
        {
            get
            {
                if (!this.IsSkinned || this.AnimData.CurrentAnimation == null)
                {
                    return 0;
                }
                return this.AnimData.UseMixer ? this.AnimData.CurrentAnimationMixer.AnimationSpeed
                    : this.AnimData.CurrentAnimation.AnimationSpeed;
            }
            set
            {
                if (this.IsSkinned && this.AnimData.CurrentAnimation != null)
                {
                    if (this.AnimData.UseMixer)
                    {
                        this.AnimData.CurrentAnimationMixer.AnimationSpeed = value;
                    }
                    else
                    {
                        this.AnimData.CurrentAnimation.AnimationSpeed = value;
                    }
                }
            }
        }

        [Description("Get or Set animation blend")]
        [Category("Animation")]
        [DoNotSave]
        public long BlendValue
        {
            get
            {
                if (!this.IsSkinned || this.AnimData.CurrentAnimation == null)
                {
                    return 0;
                }
                return this.AnimData.UseMixer ? this.AnimData.CurrentAnimationMixer.BlendValue[0]
                    : this.AnimData.BlendValue;
            }
            set
            {
                if (this.IsSkinned && this.AnimData.CurrentAnimation != null)
                {
                    if (this.AnimData.UseMixer)
                    {
                        this.AnimData.CurrentAnimationMixer.BlendValue[0] = value;
                    }
                    else
                    {
                        this.AnimData.BlendValue = value;
                    }
                }
            }
        }

        [Description("Visible or Invisible bones")]
        [Category("Animation")]
        [DoNotSave]
        public bool BonesVisibility
        {
            get
            {
                return !this.IsSkinned ? false : this.AnimData.BonesVisibility;
            }
            set
            {
                if (this.IsSkinned)
                {
                    this.AnimData.BonesVisibility = value;
                }
            }
        }

        [Description("Set to default pose or not")]
        [Category("Animation")]
        public bool DefaultPose
        {
            get
            {
                return !this.IsSkinned ? false : this.AnimData.TPos;
            }
            set
            {
                if (this.IsSkinned)
                {
                    this.AnimData.TPos = value;
                }
            }
        }

        #endregion

        #region Physic's Category

        [Description("Enable or disable physic")]
        [Category("Physics")]
        public bool EnablePhysic
        {
            get
            {
                return this.PhysicData.EnablePhysic;
            }
            set
            {
                this.PhysicData.EnablePhysic = value;
            }
        }

        [Description("Enable or disable showing bounding box")]
        [Category("Physics")]
        public bool ShowBoundings
        {
            get
            {
                return this.PhysicData.ShowBoundings;
            }
            set
            {
                this.PhysicData.ShowBoundings = value;
            }
        }

        [Description("Bounding box maximum value")]
        [Category("Physics")]
        public Vector3 BoundingBoxMax
        {
            get
            {
                return this.PhysicData.boundingBox.Max;
            }
            set
            {
                this.PhysicData.boundingBox.Max = value;
            }
        }

        [Description("Bounding box minimum value")]
        [Category("Physics")]
        public Vector3 BoundingBoxMin
        {
            get
            {
                return this.PhysicData.boundingBox.Min;
            }
            set
            {
                this.PhysicData.boundingBox.Min = value;
            }
        }

        [Description("Enable or disable Gravity for this object")]
        [Category("Physics")]
        public bool AffectedByGravity
        {
            get
            {
                return this.PhysicData.AffectedByGravity;
            }
            set
            {
                this.PhysicData.AffectedByGravity = value;
            }
        }

        [Description("Get or set orientation of object")]
        [Category("Physics")]
        public Vector3 Rotation
        {
            get { return this.PhysicData.Rotation; }
            set { this.PhysicData.Rotation = value; }
        }

        [Description("Get or set scale of object")]
        [Category("Physics")]
        public Vector3 Scale
        {
            get { return this.PhysicData.Scale; }
            set { this.PhysicData.Scale = value; }
        }

        [Description("Get or set position of object")]
        [Category("Physics")]
        public Vector3 Position
        {
            get
            {
                return this.PhysicData.Position;
            }
            set
            {
                this.PhysicData.Position = value;
                if (this.PhysicData.rigidBody != null)
                {
                    this.PhysicData.rigidBody.Position = value.ToJVector();
                }
            }
        }

        [Description("Get or set velocity of object")]
        [Category("Physics")]
        public Vector3 Velocity
        {
            get
            {
                return this.PhysicData.Velocity;
            }
            set
            {
                this.PhysicData.Velocity = value;
            }
        }

        /// <summary>
        /// All Properties are refreshed by changing this property
        /// </summary>
        [Description("Type of Physic")]
        [Category("Physics")]
        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        public PhysicTypes PhysicType
        {
            get
            {
                return this.PhysicData.physicType;
            }
            set
            {
                if (this.IsSkinned && value == PhysicTypes.Static) return;
                if (this.PhysicData.physicType != value)
                {
                    this.PhysicData.physicType = value;
                    //At the startup rigidBody is null so Refreshing automatically will do in Load Method but in RunTime we will change physic type here
                    if (this.PhysicData.rigidBody != null)
                    {
                        #region Refresh Physic Type
                        string HResult = null;
                        this.PhysicData.Dispose();
                        this.PhysicData.BuildPhysicInfo(this.ObjectData.model, ref HResult);
                        if (HResult != null)
                        {
                            Logger.WriteError(HResult);
                        }
                        #endregion
                    }
                }
            }
        }

        #endregion

        #region Bind's Properties

        //Holder for applying binding...for applying binded data
        Guid guidToBeBind;
        [DynamicPropertyFilter("PhysicType", "Weapon")]
        [Description("Get the guid of binded object to weapon")]
        [Category("Weapon's Properties")]
        public Guid BindingGuid
        {
            get
            {
                return this.guidToBeBind;
            }
            set
            {
                this.guidToBeBind = value;
            }
        }

        #endregion

        #endregion

        #region Constructor

        public Mesh()
            : this(String.Empty, Vector3.Zero, Vector3.Zero, Vector3.One)
        {
        }

        public Mesh(string modelPath, Vector3 position, Vector3 rotation, Vector3 scale)
            : base()
        {
            this.Enable = true;
            this.EnableShadow = true;
            this.isInSigh = true;
            this.modelPath = modelPath;
            this.PhysicData = new PhysicMeshData(this)
            {
                Position = position,
                Rotation = rotation,
                Scale = scale,
                Visibility = true,
            };
            this.ObjectData = new ObjectMeshData();
            this.textureToBeChangedInfo = new TextureToBeChangedInfo(TextureToBeChanged.DiffuseMap, null);
        }

        #endregion

        #region Load

        public override string Load(Model model)
        {
            string HResult = null;

            this.ObjectData.LoadingDone = false;
            this.occlusionQuery = new OcclusionQuery(Persian.GDevice);
            this.occlusionEffect = new BasicEffect(Persian.GDevice);

            //Note that AnimData will be load inside ObjectData if necessary
            HResult = this.ObjectData.Load(model,
                this.modelPath,
                this.DiffuseMaps,
                this.StartAnimationName,
                this.animationSpeedsArray,
                this.mixerTracks,
                ref this.AnimData);
            if (HResult != null) return HResult;

            HResult = this.PhysicData.Load(this.ObjectData.model, IsSkinned);
            if (HResult != null) return HResult;

            this.ObjectData.LoadingDone = true;

            return base.Load(model);
        }

        private void LoadBulletsReactionsData()
        {
            //this.BulletReactionTexs = new Texture2D[]
            //{
            //    CoreShared.Content.Load<Texture2D>(@"Textures\Utilities\Muzzles\0\0"),
            //    CoreShared.Content.Load<Texture2D>(@"Textures\Utilities\Muzzles\0\1"),  
            //    CoreShared.Content.Load<Texture2D>(@"Textures\Utilities\Muzzles\0\2")
            //};
            //Vector3 center = new Vector3(0, 0, 0);
            //billboardVertices = new VertexPositionTexture[6]
            //{
            //     new VertexPositionTexture(center, new Vector2(1, 1)),
            //     new VertexPositionTexture(center, new Vector2(0, 0)),
            //     new VertexPositionTexture(center, new Vector2(1, 0)),
            //     new VertexPositionTexture(center, new Vector2(1, 1)),
            //     new VertexPositionTexture(center, new Vector2(0, 1)),
            //     new VertexPositionTexture(center, new Vector2(0, 0)),
            //};

            #region Load Effect and Bind to Effect Parameters

            //this.MuzzleEffect = CoreShared.Content.Load<Effect>(@"Shaders\Utilities\Billboard");
            //this.MuzzleEffect.CurrentTechnique = MuzzleEffect.Techniques["SpheBillboard"];

            //this.WorldParam = MuzzleEffect.Parameters["World"];
            //this.ViewProjectionParam = MuzzleEffect.Parameters["ViewProjection"];
            //this.CameraPosParam = MuzzleEffect.Parameters["CameraPos"];
            //this.TextureParam = MuzzleEffect.Parameters["Texture"];
            //this.TexCoordianteScaleParam = MuzzleEffect.Parameters["TexCoordianteScale"];

            //this.MuzzleEffect.Parameters["CameraUp"].SetValue(Vector3.Up);

            #endregion
        }

        #endregion

        #region Methods

        /// <summary>
        /// Query on Mixe and Simple animations
        /// </summary>
        /// <param name="p"></param>
        /// <returns>bool[2] = {find on mixer, find on simple}</returns>
        public bool[] ContainsAnimationClip(string p)
        {
            return this.AnimData.ContainsAnimationClip(p);
        }

        public void LoadAnimationClips(params string[] p)
        {
            if (this.AnimData == null) return;

            for (int i = 0; i < p.Length; ++i)
            {
                var ac = ParseAnimationClipFromJson(Persian.EngineContentDir + @"\" + p[i] + ".PAC");

                this.AnimData.AddAnimationClip(ac);
            }
        }

        private SkinnedMeshRuntime.AnimationClip ParseAnimationClipFromJson(string path)
        {
            float animationSpeed = 0;
            long duration = 0;
            long frameRate = 0;
            string name = "";
            var keys = new List<SkinnedMeshRuntime.Keyframe>();

            using (var sr = new System.IO.StreamReader(path))
            {
                var j = new Newtonsoft.Json.JsonTextReader(sr);
                while (j.Read())
                {
                    if (j.Value != null)
                    {
                        var val = j.Value.ToString();
                        switch (val)
                        {
                            case "S"://AnimationSpeed
                                if (j.Read()) { animationSpeed = Convert.ToSingle(j.Value); }
                                break;
                            case "D"://Duration
                                if (j.Read()) { duration = (long)Convert.ToInt64(j.Value); }
                                break;
                            case "F"://FrameRate
                                if (j.Read()) { frameRate = (long)Convert.ToInt64(j.Value); }
                                break;
                            case "N"://Name
                                if (j.Read()) { name = j.Value.ToString(); }
                                break;
                            case "K"://Keyframes
                                if (j.Read())
                                {
                                    if (j.TokenType != Newtonsoft.Json.JsonToken.StartArray) Logger.WriteError("Invalid PAC file");

                                    int bone = 0;
                                    var P = new Vector3();
                                    var R = new Quaternion();
                                    long time = 0;
                                    var transform = new Matrix();

                                    keys.Clear();

                                    while (j.Read())
                                    {
                                        if (j.Value != null)
                                        {
                                            var kVal = j.Value.ToString();
                                            switch (kVal)
                                            {
                                                case "B":
                                                    if (j.Read()) { bone = Convert.ToInt32(j.Value); }
                                                    break;
                                                case "P":
                                                    if (j.Read())
                                                    {
                                                        if (j.Read()) { P.X = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { P.Y = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { P.Z = Convert.ToSingle(j.Value); }
                                                    }
                                                    break;
                                                case "R":
                                                    if (j.Read())
                                                    {
                                                        if (j.Read()) { R.X = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { R.Y = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { R.Z = Convert.ToSingle(j.Value); }
                                                    }
                                                    break;
                                                case "T":
                                                    if (j.Read()) { time = (long)Convert.ToInt64(j.Value); }
                                                    break;
                                                case "TR":
                                                    if (j.Read())
                                                    {
                                                        if (j.Read()) { transform.M11 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M12 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M13 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M14 = Convert.ToSingle(j.Value); }

                                                        if (j.Read()) { transform.M21 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M22 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M23 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M24 = Convert.ToSingle(j.Value); }

                                                        if (j.Read()) { transform.M31 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M32 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M33 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M34 = Convert.ToSingle(j.Value); }

                                                        if (j.Read()) { transform.M41 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M42 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M43 = Convert.ToSingle(j.Value); }
                                                        if (j.Read()) { transform.M44 = Convert.ToSingle(j.Value); }
                                                    }

                                                    keys.Add(new SkinnedMeshRuntime.Keyframe(bone, time, transform, R, P));
                                                    break;
                                            }
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }
            return new SkinnedMeshRuntime.AnimationClip(duration, keys.ToArray(), name);
        }

        public void SetMaxBoundingBox()
        {
            this.PhysicData.boundingBox.Max = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
            this.PhysicData.boundingBox.Min = new Vector3(float.MinValue, float.MinValue, float.MinValue);
        }

        public void ResetBoundingBox()
        {
            string HResult = "";
            this.PhysicData.BuildPhysicInfo(this.ObjectData.model, ref HResult);
            if (HResult != null)
            {
                Logger.WriteError(string.Format("Error on creating bounding box from Mesh.cs e.What() : {0}", HResult));
            }
        }

        public bool BindValue()
        {
            bool HResult = false;
            if (this.bindToProperty == null) return HResult;

            try
            {
                //Get value from BindTo
                var value = this.bindToProperty.GetValue(this.BindTo, null);
                //Set value to this object
                bindSourceProperty.SetValue(this, value, null);
                HResult = true;
            }
            catch
            {
                HResult = false;
            }
            return HResult;
        }

        public void RemoveBinding()
        {
            this.EnableBinding = false;
            if (this.BindTo != null)
            {
                (this.BindTo as IBinding).RemoveBinding();
            }
            this.BindTo = null;
            this.BindToBone = null;
            this.BindToBonePositionOffset = Vector3.Zero;
            this.BindToBoneRotationOffset = Vector3.Zero;
            this.BindProperty = null;
        }

        public void ApplySlice(CutPlane cutPlane, Matrix[] WorldMatrices)
        {
            this.ObjectData.ApplySlice(cutPlane, WorldMatrices);
        }

        /// <summary>
        /// Attach Object to mesh
        /// </summary>
        /// <param name="guid"></param>
        /// <param name="mesh"></param>
        /// <returns>if return value is true means remove source mesh</returns>
        internal bool OnAttaching(Mesh mesh)
        {
            //switch (CoreShared.OnPickOperation)
            //{
            //    default:
            //        Logger.WriteError("Could not recognize attaching operation");
            //        return false;
            //    //case PickOperation.AttachWeapon:
            //    //if is not weapon so initialize it as weapon
            //    if (mesh.PhysicType != PhysicTypes.Weapon)
            //    {
            //        //This property will automatically create weapon class
            //        mesh.PhysicType = PhysicTypes.Weapon;
            //    }
            //    mesh.BindingGuid = this.GUID;
            //    mesh.PhysicData.BindTo = this;
            //    return false;
            //case PickOperation.AttachWheelToVehicle:
            //    //if is not weapon so initialize it as weapon
            //    if (this.PhysicType != PhysicTypes.Vehicle)
            //    {
            //        //This property will automatically create Vehicle class
            //        this.PhysicType = PhysicTypes.Vehicle;
            //    }
            //    this.PhysicData.vehicle.WheelModelPath = mesh.modelPath;
            //    this.PhysicData.vehicle.AttachWheels(mesh.ObjectData.model, mesh.GetBoundingSphere().Radius, ref this.PhysicData.rigidBody);
            //    return true;//return true for removing mesh because we just want it's model for assigning to vehicle
            //}
            return true;
        }

        /// <summary>
        /// Play the animation mixer
        /// </summary>
        /// <param name="AnimationMixerName"></param>
        public void PlayAnimationUpponName(string AnimationName = null, bool? isMixer = null)
        {
            if (this.AnimData.TPos) this.AnimData.TPos = false;
            PauseAnimation(false);
            this.AnimData.SetAnimationUpponName(AnimationName, isMixer);
        }

        /// <summary>
        /// Set playing state of animation
        /// </summary>
        /// <param name="Value">Null means always playing, true means play one frame and false means stop playing</param>
        public void PlayAnimation(bool? Value)
        {
            if (!this.IsSkinned) return;

            //if (AnimData.Player.IsLoopable)
            //{

            //}

            if (this.AnimData.PlayFrameByFrame == false && Value == false)
            {
                //Double Pause means play
                this.AnimData.PlayFrameByFrame = null;
            }
            else
            {
                if (this.AnimData.PlayFrameByFrame != Value)
                {
                    this.AnimData.PlayFrameByFrame = Value;
                }
            }
        }

        /// <summary>
        /// Pause Animation
        /// </summary>
        /// <param name="value">True means pause it</param>
        public void PauseAnimation(bool value)
        {
            if (!this.IsSkinned) return;

            if (this.AnimData.UseMixer)
            {
                //Pause animation Mixer

                if (this.AnimData == null && this.AnimData.Mixers == null) return;

                foreach (var key in this.AnimData.Mixers.Keys)
                {
                    this.AnimData.Mixers[key].Player.IsPaused = value;
                }
            }
            else
            {
                //Pause animation player
                if (this.AnimData == null && this.AnimData.skinningData == null) return;

                this.AnimData.Player.IsPaused = value;
            }
        }

        public void ResetAndPauseAnimation()
        {
            if (!this.IsSkinned) return;

            if (this.AnimData.UseMixer)
            {
                //Reset animation Mixer

                if (this.AnimData == null && this.AnimData.Mixers == null) return;

                this.AnimData.CurrentAnimationMixer.ResetAndPause();
                //foreach (var key in this.AnimData.Mixers.Keys)
                //{
                //    this.AnimData.Mixers[key].Reset();
                //}
            }
            else
            {
                //Reset animation player
                if (this.AnimData == null && this.AnimData.skinningData == null) return;

                var clip = this.AnimData.Player.CurrentClip;
                this.AnimData.Player.StartClip(clip);
                this.AnimData.Player.IsPaused = true;
                this.AnimData.PlayFrameByFrame = true;
            }
        }

        public void ResetAnimation()
        {
            if (!this.IsSkinned) return;

            if (this.AnimData.UseMixer)
            {
                //Reset animation Mixer

                if (this.AnimData == null && this.AnimData.Mixers == null) return;

                this.currentAnimationFrame = 0;
                this.AnimData.CurrentAnimationMixer.Reset();
                //foreach (var key in this.AnimData.Mixers.Keys)
                //{
                //    this.AnimData.Mixers[key].Reset();
                //}
            }
            else
            {
                //Reset animation player
                if (this.AnimData == null && this.AnimData.skinningData == null) return;

                this.currentAnimationFrame = 0;
                var clip = this.AnimData.Player.CurrentClip;
                this.AnimData.Player.StartClip(clip);
                this.AnimData.PlayFrameByFrame = true;
            }
        }

        public void RemoveAllSwapping()
        {
            this.AnimData.CurrentAnimation.SwappingBones.Clear();
        }

        public void SetSwapping(int index0, int index1)
        {
            if (!Check4Swaped(this.AnimData.CurrentAnimation.SwappingBones, index0, index1) &&
                !Check4Swaped(this.AnimData.CurrentAnimation.SwappingBones, index1, index0))
            {
                this.AnimData.CurrentAnimation.SwappingBones.Add(index0, index1);
            }
        }

        private bool Check4Swaped(Dictionary<int, int> BaseDic, int A, int B)
        {
            int val = -1;
            if (BaseDic.TryGetValue(A, out val))
            {
                if (val == B)
                {
                    //Already swapped so u want to delete it
                    BaseDic.Remove(A);
                    return true;
                }
            }
            return false;
        }

        public void AddToMixer(MixerInfo mixerInfo)
        {
            this.AnimData.AddToMixer(mixerInfo);
        }

        public void RemoveAllMixers()
        {
            if (this.mixerTracks != null)
            {
                this.mixerTracks.Clear();
            }
            this.AnimData.Mixers.Clear();
        }

        /// <summary>
        /// Change Texture of Specific mesh
        /// </summary>
        /// <param name="texture"></param>
        public void OnChangingTexture(Texture texture)
        {
            if (!string.IsNullOrEmpty(this.textureToBeChangedInfo.MeshName))
            {
                this.ObjectData.modelMeshTagCollection.ChangeTexture(texture, textureToBeChangedInfo);
            }
        }

        #endregion

        #region Update

        public override void Update()
        {
            if (!this.ObjectData.LoadingDone || !this.Enable) return;

            // UpdateAction(gameTime);
            this.PhysicData.Update();
            if (EnableBinding)
            {
                if (BindToBone != null)
                {
                    var BasePosOffset = (this.BindTo as Mesh).Position;
                    var BaseRotOffset = (this.BindTo as Mesh).Rotation;
                    var offsetWorld =
                        Matrix.CreateRotationX(BaseRotOffset.X + this.BindToBoneRotationOffset.X) *
                        Matrix.CreateRotationY(BaseRotOffset.Y + this.BindToBoneRotationOffset.Y) *
                        Matrix.CreateRotationZ(BaseRotOffset.Z + this.BindToBoneRotationOffset.Z) *
                        Matrix.CreateTranslation(BasePosOffset + this.BindToBonePositionOffset); /**
                            Matrix.CreateScale(this.Scale);*/
                    //TODO : Correct the scale of binding
                    this.World = BindToBone.World * offsetWorld;
                    this.Position = this.World.Translation;
                }
                else
                {
                    //If we have binding so do it
                    if (BindTo != null)
                    {
                        if (!BindValue())
                        {
                            EnableBinding = false;
                            Logger.WriteError("Error on binding value from Mesh class");
                        }
                    }
                }
            }

            if (IsSkinned)
            {
                this.AnimData.Update(this.PhysicData.World);

                SkinnedMeshRuntime.AnimationPlayer player = null;
                //Update animation frame time
                if (this.AnimData.UseMixer)
                {
                    player = this.AnimData.CurrentAnimationMixer.Player;
                }
                else
                {
                    player = this.AnimData.Player;
                }
                this.CurrentAnimationFrame = this.AnimData != null ?
                    ((player.CurrentTimeInTheAnimationInTicks / 1000.000f)) : -1;

                this.CurrentAnimationTotalFrames = player.CurrentClip.Duration;
            }
            this.ObjectData.Update(this.PhysicData.World, this.AnimData != null ? this.AnimData.SkinTransforms : null);

            base.Update();
        }

        #endregion

        #region Draw

        internal void OcclusionQuery()
        {
            if (!this.ObjectData.LoadingDone || !this.Enable) return;

            //If this mesh must always visible
            if (AlwaysVisible)
            {
                this.isInSigh = true;
                return;
            }

            this.isInSigh = Bounding.IsInSight(this.PhysicData.boundingSphere, this.PhysicData.World);

            if (this.isInSigh && this.PhysicData.Visibility)
            {
                //BUGGGGGGGGGGG
                try
                // if (!this.occlusionQuery.IsComplete)
                {
                    this.occlusionQuery.Begin();
                    {
                        //Simply draw it
                        foreach (var mesh in this.ObjectData.modelMeshTagCollection)
                        {
                            this.occlusionEffect.World = this.World;
                            this.occlusionEffect.View = Persian.Camera.View;
                            this.occlusionEffect.Projection = Persian.Camera.Projection;
                            this.occlusionEffect.CurrentTechnique.Passes[0].Apply();
                            mesh.Draw();
                        }
                        this.occlusionQuery.End();
                    }
                }
                catch
                {

                }
            }
        }

        public override void DrawToGBuffer()
        {
            if (!this.ObjectData.LoadingDone || !this.Enable) return;

            var GDevice = Persian.GDevice;

            if (RenderManager.CachingGPU || (isInSigh && this.PhysicData.Visibility))
            {
                if (!Persian.RunningEngine && this.AnimData != null)
                {
                    var rasterizerState = GDevice.RasterizerState;
                    if (this.AnimData.BonesVisibility)
                    {
                        GDevice.RasterizerState = CoreShared.Wireframe;
                    }
                    this.ObjectData.DrawToGBuffer(this.PhysicData.World, this.AnimData != null ? this.AnimData.SkinTransforms : null);
                    GDevice.RasterizerState = rasterizerState;
                }
                else
                {
                    this.ObjectData.DrawToGBuffer(this.PhysicData.World, this.AnimData != null ? this.AnimData.SkinTransforms : null);
                }
                base.DrawToGBuffer();
            }
        }

        public override void DrawShadowMap(ref Matrix LightViewProj)
        {
            if (!this.ObjectData.LoadingDone || !this.Enable || !this.EnableShadow) return;

            if (RenderManager.CachingGPU || this.PhysicData.Visibility)
            {
                this.ObjectData.DrawShadowMap(ref LightViewProj, this.PhysicData.World, this.AnimData != null ? this.AnimData.SkinTransforms : null);
                base.DrawShadowMap(ref LightViewProj);
            }
        }

        public override void ReConstructShading(RenderTarget2D LightMap)
        {
            if (!this.ObjectData.LoadingDone || !this.Enable) return;

            var GDevice = Persian.GDevice;

#if DEBUG
            if (RenderManager.CachingGPU || isInSigh)
            {
                if (IsSkinned)
                {
                    this.AnimData.Draw(GDevice, this.PhysicData.World);
                }
                this.PhysicData.DrawBoundings(this.ObjectData.baseEffect, IsSkinned);
            }
#endif
            if (RenderManager.CachingGPU || (isInSigh && this.PhysicData.Visibility))
            {
                if (!Persian.RunningEngine && this.AnimData != null)
                {
                    var rasterizerState = GDevice.RasterizerState;
                    if (this.AnimData.BonesVisibility)
                    {
                        GDevice.RasterizerState = CoreShared.Wireframe;
                    }
                    this.ObjectData.ReConstructShading(
                        LightMap,
                        this.PhysicData.World,
                        this.AnimData != null ? this.AnimData.SkinTransforms : null);
                    GDevice.RasterizerState = rasterizerState;
                }
                else
                {
                    this.ObjectData.ReConstructShading(LightMap, this.PhysicData.World, this.AnimData != null ? this.AnimData.SkinTransforms : null);
                }
                base.ReConstructShading(LightMap);
            }
        }

        public override void DrawBlended()
        {
            //if (this.ShowBulletReactions)
            //{
            //    BlendState blendState = GDevice.BlendState;
            //    GDevice.BlendState = BlendState.AlphaBlend;

            //    this.WorldParam.SetValue(Matrix.Identity);
            //    this.ViewProjectionParam.SetValue(CoreShared.Camera.View * CoreShared.Camera.Projection);
            //    this.CameraPosParam.SetValue(CoreShared.Camera.Position);
            //    this.TextureParam.SetValue(this.BulletReactionTexs[random.Next(0, 3)]);
            //    this.TexCoordianteScaleParam.SetValue(0.2f + (float)random.NextDouble() * 1.2f);

            //    MuzzleEffect.CurrentTechnique.Passes[0].Apply();
            //    {
            //        GDevice.DrawUserPrimitives<VertexPositionTexture>(PrimitiveType.TriangleList, billboardVertices, 0, 2);
            //    }

            //    GDevice.BlendState = blendState;
            //}

            base.DrawBlended();
        }

        public override void DrawToGlowMap()
        {
            if (!this.ObjectData.LoadingDone || !this.Enable) return;

            var GDevice = Persian.GDevice;

            if (RenderManager.CachingGPU || (isInSigh && this.PhysicData.Visibility))
            {
                if (!Persian.RunningEngine && this.AnimData != null)
                {
                    this.ObjectData.DrawToGlowMap(this.PhysicData.World,
                        this.AnimData != null ? this.AnimData.SkinTransforms : null);
                }
                else
                {
                    this.ObjectData.DrawToGlowMap(this.PhysicData.World,
                        this.AnimData != null ? this.AnimData.SkinTransforms : null);
                }
                base.DrawToGBuffer();
            }
        }

        public override void DrawWithCustomeEffect(Effect effect, int techniqueIndex, int passIndex)
        {
            if (!this.ObjectData.LoadingDone || !this.Enable) return;

            this.ObjectData.DrawWithCustomeEffect(effect, techniqueIndex, passIndex);
        }

        #endregion

        #region Events

        private void NotifyPropertyChanged(string propertyName)
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }

        private void OnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {

        }

        #endregion

        #region Clone

        public object Clone()
        {
            var _clone = new Mesh();
            this.CopyTo<Mesh>(ref _clone);
            _clone.ObjectData.ID = "Cloned " + _clone.ObjectData.ID;
            _clone.ObjectData.GUID = Guid.NewGuid();
            _clone.ObjectData.LoadingDone = false;
            _clone.ObjectData.SelectionColor = 2;
            return _clone;
        }

        #endregion

        #region Compare

        /// <summary>
        /// Compare center of bounding sphere with position of camera
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public int CompareTo(object obj)
        {
            if (!(obj is Mesh)) throw new ArgumentException("object is not Mesh, Error in Compare method of mesh.cs");
            var cL = Persian.Camera.Position;

            var mL1 = this.PhysicData.boundingSphere.Center - cL;
            var mL2 = (obj as Mesh).PhysicData.boundingSphere.Center - cL;

            return mL2.Length().CompareTo(mL1.Length());
        }

        #endregion

        #region Dispose

        protected override void Dispose(bool disposing)
        {
            if (!disposing || isDisposed) return;

            this.BindTo = null;
            SystemMemory.SafeDispose(this.AnimData);
            SystemMemory.SafeDispose(this.ObjectData);
            base.Dispose(disposing);
        }

        #endregion
    }
}
                    