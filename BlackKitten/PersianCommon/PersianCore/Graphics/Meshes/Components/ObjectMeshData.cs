/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : ObjectMeshData.cs
 * File Description : This class represents the information of mesh
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 5/15/2013
 * Comment          : 
 */

using Debugger;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Framework;
using PersianCore.Graphics.Lights.PrepassTechnique;
using PersianCore.Graphics.PostProcessing;
using PersianCore.Meshes.Components.Base;
using System;
using System.Collections.Generic;

namespace PersianCore.Meshes.Components
{
    public class ObjectMeshData
    {
        #region Fields & Properties

        Effect baseMaterialEffect;
        public Guid GUID;
        public string ID;
        public Model model;
        public float SelectionColor;
        public bool LoadingDone;
        public Effect baseEffect;
        public ModelMeshTagCollection modelMeshTagCollection;
        public int WorldParamIndex;

        public bool applySlice;
        public Slice slice { get; set; }

        public Dictionary<string, List<string>> DiffuseMaps;

        public bool UseGlow;

        Vector4 ambientColor;
        public Vector4 AmbientColor
        {
            get
            {
                return this.ambientColor;
            }
            set
            {
                if (this.ambientColor != value)
                {
                    this.ambientColor = value;
                    if (modelMeshTagCollection != null)
                    {
                        foreach (var meshTag in this.modelMeshTagCollection)
                        {
                            meshTag.CurrentTechniqueIndex = 0;
                            meshTag.CurrentPassIndex = 1;
                            meshTag.SetEffectValue(this.WorldParamIndex + 6, value);//Set AmbientColor
                        }
                    }
                }
            }
        }

        float textureLOD;
        public float TextureLOD
        {
            get
            {
                return this.textureLOD;
            }
            set
            {
                if (this.textureLOD != value)
                {
                    this.textureLOD = value;
                    //Set LOD at the runtime for all passes except glow pass
                    if (modelMeshTagCollection != null)
                    {
                        foreach (var meshTag in this.modelMeshTagCollection)
                        {
                            meshTag.SetEffectValue(this.WorldParamIndex + 8, value);//Set LOD
                        }
                    }
                }
            }
        }

        float glowIntensity;
        public float GlowIntensity
        {
            get
            {
                return this.glowIntensity;
            }
            set
            {
                if (this.glowIntensity != value)
                {
                    this.glowIntensity = value;
                    if (UseGlow)
                    {
                        if (modelMeshTagCollection != null)
                        {
                            foreach (var meshTag in this.modelMeshTagCollection)
                            {
                                meshTag.SetEffectValue(this.WorldParamIndex + 7, value);//GlowIntensity
                            }
                        }
                    }
                }
            }
        }

        Vector3 glowColor;
        public Vector3 GlowColor
        {
            get
            {
                return this.glowColor;
            }
            set
            {
                if (this.glowColor != value)
                {
                    this.glowColor = value;

                    if (UseGlow)
                    {
                        if (modelMeshTagCollection != null)
                        {
                            foreach (var meshTag in this.modelMeshTagCollection)
                            {
                                meshTag.SetEffectValue(this.WorldParamIndex + 11, value);//GlowColor
                            }
                        }
                    }
                }
            }
        }

        public string CustomEffectPath;

        float reflectivity;
        public float Reflectivity
        {
            get
            {
                return this.reflectivity;
            }
            set
            {
                if (this.reflectivity != value)
                {
                    this.reflectivity = value;
                    if (modelMeshTagCollection != null)
                    {
                        foreach (var meshTag in this.modelMeshTagCollection)
                        {
                            meshTag.SetEffectValue(this.WorldParamIndex + 13, value);//Set Reflectivity
                        }
                    }
                }
            }
        }

        public bool AlphaTransparency;
        public bool EnvironmentMapping;

        public bool UseCustomWorlds;
        public List<Matrix> CustomWorlds;
        public List<bool> CustomSubMeshVisibility;

        #endregion

        #region Constructor

        public ObjectMeshData()
        {
            //if Guid has been set by save file or config file so do not generate again
            if (this.GUID != null)
            {
                this.GUID = Guid.NewGuid();
            }
            this.ID = "NO NAME";
            this.AlphaTransparency = false;
            this.EnvironmentMapping = false;
            this.LoadingDone = false;
            this.glowIntensity = 1.0f;
            this.SelectionColor = 0;
            this.textureLOD = 0;
            this.reflectivity = 0.5f;
            this.ambientColor = new Vector4(1.0f, 1.0f, 1.0f, 0);
            this.glowColor = new Vector3(0.3f, 0.4f, 0.7f);
            this.CustomWorlds = new List<Matrix>();
            this.CustomSubMeshVisibility = new List<bool>();
        }

        #endregion

        #region Load

        internal string Load(Model model, string ModelPath, Dictionary<string, List<string>> diffuseMaps,
            string CurrentAnimationName, float[] animationSpeedsArray, List<MixerInfo> mixerInfos,
            ref AnimationMeshData AnimMeshData)
        {
            #region Loading Model

            if (model == null)
            {
                string path = string.Empty;
                if (Persian.RunningEngine)
                {
                    path = ModelPath.Replace(System.IO.Path.GetExtension(ModelPath), "");
                    this.model = Persian.EngineContent.Load<Model>(path);
                }
                else
                {
                    path = string.Concat(Persian.EngineContentDir, @"\", ModelPath);
                    if (System.IO.File.Exists(path))
                    {
                        path = path.Replace(System.IO.Path.GetExtension(path), "");
                        this.model = Persian.EngineContent.Load<Model>(path);
                    }
                    else
                    {
                        var error = string.Format("Could not load model. Error from {0}", ModelPath);
                        Logger.WriteError(error);
                        return error;
                    }
                }
            }
            else
            {
                this.model = model;
            }

            #endregion

            #region Check 4 Skinning

            object TryOut = null;
            var Tags = this.model.Tag as Dictionary<string, object>;
            if (Tags != null && Tags.TryGetValue("SkinningData", out TryOut))
            {
                if (TryOut != null)
                {
                    AnimMeshData = new AnimationMeshData()
                    {
                        skinningData = TryOut as SkinnedMeshRuntime.SkinningData,
                        MixerInfos = mixerInfos,
                    };
                    var HResult = AnimMeshData.Load(
                        this.GUID,
                        CurrentAnimationName,
                        animationSpeedsArray);
                    if (HResult != null) return HResult;
                }
            }

            //TODO : Exporting animation clips
            if (AnimMeshData != null && AnimMeshData.skinningData.AnimationClips.Length != 0)
            {
                //ExportJson(@"C:\Test\A.AC", AnimMeshData.skinningData.AnimationClips[0]);
            }

            int BonesCount = AnimMeshData != null ? AnimMeshData.skinningData.BindPose.Length : this.model.Bones.Count;

            #endregion

            #region Clone effects

#if DEBUG
            this.baseEffect = ShadersManager.VPColor3EffectFX;
#endif

            ChangeEffectByRenderingTechnique(AnimMeshData != null, this.AlphaTransparency, this.EnvironmentMapping);

            #endregion

            if (UseGlow)
            {
                foreach (var meshTag in this.modelMeshTagCollection)
                {
                    meshTag.CurrentTechniqueIndex = 0;
                    meshTag.CurrentPassIndex = 3;
                    meshTag.SetEffectValue(this.WorldParamIndex + 11, this.glowColor);//GlowColor
                }

                foreach (var meshTag in this.modelMeshTagCollection)
                {
                    meshTag.CurrentTechniqueIndex = 0;
                    meshTag.CurrentPassIndex = 3;
                    meshTag.SetEffectValue(this.WorldParamIndex + 7, this.glowIntensity);//GlowIntensity
                }
            }

            //Set texture LOD at the load time for all passes except for glow pass
            foreach (var meshTag in this.modelMeshTagCollection)
            {
                meshTag.CurrentTechniqueIndex = 0;
                for (int i = 0; i < 3; ++i)
                {
                    meshTag.CurrentPassIndex = i;
                    meshTag.SetEffectValue(this.WorldParamIndex + 8, this.textureLOD);//Set LOD
                }
            }

            //Set ambient color
            foreach (var meshTag in this.modelMeshTagCollection)
            {
                meshTag.CurrentTechniqueIndex = 0;
                meshTag.CurrentPassIndex = 1;
                meshTag.SetEffectValue(this.WorldParamIndex + 6, this.ambientColor);//Set Ambient Color
            }

            if (EnvironmentMapping)
            {
                foreach (var meshTag in this.modelMeshTagCollection)
                {
                    meshTag.SetEffectValue(this.WorldParamIndex + 13, this.reflectivity);//Set Reflectivity
                }
            }

            return null;
        }

        private void ExportJson(string path, SkinnedMeshRuntime.AnimationClip animationClip)
        {
            using (var sw = new System.IO.StreamWriter(path))
            {
                var j = new Newtonsoft.Json.JsonTextWriter(sw);

                j.WriteStartObject();
                {
                    j.WritePropertyName("S");//AnimationSpeed
                    j.WriteValue(animationClip.AnimationSpeed);

                    j.WritePropertyName("D");//Duration
                    j.WriteValue(animationClip.Duration);

                    j.WritePropertyName("F");//FrameRate
                    j.WriteValue(animationClip.FrameRate);

                    j.WritePropertyName("N");//Name
                    j.WriteValue(animationClip.Name);

                    j.WritePropertyName("K");//Keyframes
                    {
                        j.WriteStartArray();

                        foreach (var key in animationClip.Keyframes)
                        {
                            j.WriteStartObject();

                            j.WritePropertyName("B");//Bone
                            j.WriteValue(key.Bone);

                            j.WritePropertyName("P");//Position
                            {
                                j.WriteStartArray();
                                j.WriteValue(key.Position.X);
                                j.WriteValue(key.Position.Y);
                                j.WriteValue(key.Position.Z);
                                j.WriteEndArray();
                            }

                            j.WritePropertyName("R");//Rotation
                            j.WriteStartArray();
                            j.WriteValue(key.Rotation.X);
                            j.WriteValue(key.Rotation.Y);
                            j.WriteValue(key.Rotation.Z);
                            j.WriteEndArray();

                            j.WritePropertyName("T");//Time
                            j.WriteValue(key.Time);

                            j.WritePropertyName("TR");//Transform
                            j.WriteStartArray();

                            j.WriteValue(key.Transform.M11);
                            j.WriteValue(key.Transform.M12);
                            j.WriteValue(key.Transform.M13);
                            j.WriteValue(key.Transform.M14);

                            j.WriteValue(key.Transform.M21);
                            j.WriteValue(key.Transform.M22);
                            j.WriteValue(key.Transform.M23);
                            j.WriteValue(key.Transform.M24);

                            j.WriteValue(key.Transform.M31);
                            j.WriteValue(key.Transform.M32);
                            j.WriteValue(key.Transform.M33);
                            j.WriteValue(key.Transform.M34);

                            j.WriteValue(key.Transform.M41);
                            j.WriteValue(key.Transform.M42);
                            j.WriteValue(key.Transform.M43);
                            j.WriteValue(key.Transform.M44);

                            j.WriteEndArray();

                            j.WriteEndObject();
                        }

                        j.WriteEndArray();
                    }

                    j.WriteEndObject();
                }

                j.Flush();
                j.Close();
            }
        }

        /// <summary>
        /// Load effect and set data to it's parameters
        /// </summary>
        /// <param name="isSkinned"></param>
        private void LoadAndSetParams(bool isSkinned, bool alphaTransparency, bool environmentMapping)
        {
            if (isSkinned)
            {
                if (alphaTransparency)
                {
                    this.baseMaterialEffect = ShadersManager.PSkinnedAlphaMaterialFX;
                    this.WorldParamIndex = 2;
                    this.baseMaterialEffect.Parameters["AlphaReference"].SetValue(1.0f);
                }
                else
                {
                    this.baseMaterialEffect = ShadersManager.PSkinnedMaterialFX;
                    this.WorldParamIndex = 1;
                }
            }
            else
            {
                //Regarding to shader model 3 limitation we can use environment mapping only for static objects
                if (alphaTransparency)
                {
                    this.baseMaterialEffect = ShadersManager.PStaticAlphaMaterialFX;
                    this.WorldParamIndex = 1;
                    this.baseMaterialEffect.Parameters["AlphaReference"].SetValue(1.0f);
                }
                else
                {
                    if (environmentMapping)
                    {
                        this.baseMaterialEffect = ShadersManager.StaticEnvMaterialFX;
                    }
                    else
                    {
                        this.baseMaterialEffect = ShadersManager.PStaticMaterialFX;
                    }
                    this.WorldParamIndex = 0;
                }
            }
            this.baseMaterialEffect.Parameters["FarClip"].SetValue(Persian.Camera.FarClip);//FarClip
            this.baseMaterialEffect.Parameters["AmbientColor"].SetValue(this.ambientColor);//AmbientColor
            this.baseMaterialEffect.Parameters["AmbientCubeMap"].SetValue(LightPrePassRendering.ambientCubemap);//AmbientCubeMap

        }

        #endregion

        #region Update

        internal void Update(Matrix World, Matrix[] SkinTransforms)
        {
            //this.WorldParam.SetValue(World);
            //this.ViewParam.SetValue(CoreShared.Camera.View);
            //this.ProjectionParam.SetValue(CoreShared.Camera.Projection);
            //this.FarClipParam.SetValue(CoreShared.Camera.FarClip);
            //this.AmbientColorParam.SetValue(Lighting.LightsManager.ambientColor);
            //this.AmbientCubeMapParam.SetValue(Lighting.LightsManager.ambientCubemap);

            //if (SkinTransforms != null)
            //{
            //    this.BonesParam.SetValue(SkinTransforms);
            //}
        }

        #endregion

        #region Methods

        internal void ChangeEffectByRenderingTechnique(bool isSkinned, bool alphaTransparency, bool environmentMapping)
        {
            LoadAndSetParams(isSkinned, alphaTransparency, environmentMapping);
            if (this.modelMeshTagCollection == null)
            {
                //Let's initialize it
                this.modelMeshTagCollection = new ModelMeshTagCollection(this.model, this.DiffuseMaps, this.baseMaterialEffect, environmentMapping, ref this.UseGlow);
            }
            else
            {
                //Just change the effect upon render technique
                this.modelMeshTagCollection.OnChangeRenderTechnique(this.baseMaterialEffect, environmentMapping, ref this.UseGlow);
            }
        }

        internal void ApplySlice(CutPlane cutPlane, Matrix[] WorldMatrices)
        {
            if (WorldMatrices.Length != 2) throw new Exception("Invalid world counts, it must be 2");

            if (this.slice != null)
            {
                this.slice = new Slice(this.model, this.WorldParamIndex)
                {
                    _world1 = WorldMatrices[0],
                    _world_1 = WorldMatrices[1],
                };
            }
            this.applySlice = PMathHelper.Slice(this.slice, cutPlane);
        }

        #endregion

        #region Draw

        internal void DrawToGBuffer(Matrix World, Matrix[] SkinTransforms)
        {
#if DEBUG
            var HoldCounts = UsageReporter.debugInfo.DrawCalls;
#endif

            if (this.applySlice)
            {
                this.slice.DrawToGBuffer(SkinTransforms, this.model.Meshes[0].Effects[0]);
            }
            else
            {
                for (int i = 0; i < this.modelMeshTagCollection.Count; ++i )
                {
                    if (UseCustomWorlds)
                    {
                        if (CustomSubMeshVisibility.Count == 0)
                        {
                            Logger.WriteError("You need to set CustomSubMeshVisibility for " + this.ID);
                        }
                        else
                        {
                            if (!CustomSubMeshVisibility[i]) continue;
                        }
                    }

                    var meshTag = this.modelMeshTagCollection[i];

                    meshTag.CurrentTechniqueIndex = 0;
                    meshTag.CurrentPassIndex = 0;
                    if (SkinTransforms != null)
                    {
                        meshTag.SetEffectValue(0, SkinTransforms);
                    }

                    if (SkinTransforms == null && UseCustomWorlds && CustomWorlds.Count != 0)
                    {
                        World = CustomWorlds[i];
                    }
                    meshTag.SetEffectValue(this.WorldParamIndex, World);//World
                    meshTag.SetEffectValue(this.WorldParamIndex + 1, Persian.Camera.View);//View
                    meshTag.SetEffectValue(this.WorldParamIndex + 2, Persian.Camera.Projection);//Projection
                    meshTag.SetEffectValue(this.WorldParamIndex + 4, Persian.Camera.FarClip);//Farclip
                    meshTag.SetEffectValue(this.WorldParamIndex + 12, this.UseGlow);//UseGlow
                    meshTag.DrawWithInnerEffect();
                }
            }

#if DEBUG
            UsageReporter.debugInfo.ShadowCasterMeshes += UsageReporter.debugInfo.DrawCalls - HoldCounts;
#endif
        }

        internal void DrawShadowMap(ref Matrix LightViewProj, Matrix World, Matrix[] SkinTransforms)
        {
#if DEBUG
            uint HoldCounts = UsageReporter.debugInfo.DrawCalls;
#endif

            if (this.applySlice)
            {
                this.slice.DrawShadowMap(SkinTransforms, this.model.Meshes[0].Effects[0], ref LightViewProj);
            }
            else
            {
                for (int i = 0; i < this.modelMeshTagCollection.Count; ++i)
                {
                    if (UseCustomWorlds)
                    {
                        if (CustomSubMeshVisibility.Count == 0)
                        {
                            Logger.WriteError("You need to set CustomSubMeshVisibility for " + this.ID);
                        }
                        else
                        {
                            if (!CustomSubMeshVisibility[i]) continue;
                        }
                    }

                    var meshTag = this.modelMeshTagCollection[i];

                    meshTag.CurrentTechniqueIndex = 0;
                    meshTag.CurrentPassIndex = 2;
                    if (SkinTransforms != null)
                    {
                        meshTag.SetEffectValue(0, SkinTransforms);
                    }

                    if (SkinTransforms == null && UseCustomWorlds && CustomWorlds.Count != 0)
                    {
                        World = CustomWorlds[i];
                    }
                    meshTag.SetEffectValue(this.WorldParamIndex, World);
                    meshTag.SetEffectValue(this.WorldParamIndex + 3, LightViewProj);

                    meshTag.DrawWithInnerEffect();
                }
            }
#if DEBUG
            UsageReporter.debugInfo.ShadowCasterMeshes += UsageReporter.debugInfo.DrawCalls - HoldCounts;
#endif
        }

        internal void ReConstructShading(Texture2D LightMap, Matrix World, Matrix[] SkinTransforms)
        {
            var blendState = Persian.GDevice.BlendState;
            if (this.applySlice)
            {
                this.slice.ReConstructShading(SkinTransforms, this.model.Meshes[0].Effects[0], LightMap);
            }
            else
            {
                for (int i = 0; i < this.modelMeshTagCollection.Count; ++i)
                {
                    if (UseCustomWorlds)
                    {
                        if (CustomSubMeshVisibility.Count == 0)
                        {
                            Logger.WriteError("You need to set CustomSubMeshVisibility for " + this.ID);
                        }
                        else
                        {
                            if (!CustomSubMeshVisibility[i]) continue;
                        }
                    }

                    var meshTag = this.modelMeshTagCollection[i];

                    meshTag.CurrentTechniqueIndex = 0;
                    meshTag.CurrentPassIndex = 1;
                    if (SkinTransforms != null)
                    {
                        meshTag.SetEffectValue(0, SkinTransforms);
                    }

                    if (SkinTransforms == null && UseCustomWorlds && CustomWorlds.Count != 0)
                    {
                        World = CustomWorlds[i];
                    }

                    meshTag.SetEffectValue(this.WorldParamIndex, World);//Set World
                    meshTag.SetEffectValue(this.WorldParamIndex + 1, Persian.Camera.View);//Set view
                    meshTag.SetEffectValue(this.WorldParamIndex + 2, Persian.Camera.Projection);//Set Projection
                    meshTag.SetEffectValue(this.WorldParamIndex + 5,
                        new Vector2(0.5f / LightMap.Width, 0.5f / LightMap.Height));//LightMap Size
                    meshTag.SetEffectValue(this.WorldParamIndex + 17, LightMap);//Set LightMap

                    if (PostProcessor.PostType.HasFlag(Graphics.PostProcessing.PostProcessType.TOON))
                    {
                        meshTag.SetEffectValue(this.WorldParamIndex + 9,
                            Persian.Camera.Position - PersianCore.Graphics.Lights.LightManager.MainDirLight.World.Translation);//Toon light
                        meshTag.SetEffectValue(this.WorldParamIndex + 10, true);//Use toon
                    }
                    else
                    {
                        meshTag.SetEffectValue(this.WorldParamIndex + 10, false);//Don't use toon
                    }

                    meshTag.Draw(true, null, BlendState.Additive);
                }
            }
        }

        internal void DrawToGlowMap(Matrix World, Matrix[] SkinTransforms)
        {
//            if (!UseGlow) return;

//#if DEBUG
//            var HoldCounts = UsageReporter.debugInfo.DrawCalls;
//#endif

//            if (this.applySlice)
//            {
//                //this.slice.DrawToGlowMap(SkinTransforms, this.model.Meshes[0].Effects[0]);
//            }
//            else
//            {
//                foreach (var meshTag in this.modelMeshTagCollection)
//                {
//                    meshTag.CurrentTechniqueIndex = 0;
//                    meshTag.CurrentPassIndex = 3;
//                    if (SkinTransforms != null)
//                    {
//                        meshTag.SetEffectValue(0, SkinTransforms);
//                    }

//                    meshTag.SetEffectValue(this.WorldParamIndex, World);//World
//                    meshTag.SetEffectValue(this.WorldParamIndex + 1, Persian.Camera.View);//View
//                    meshTag.SetEffectValue(this.WorldParamIndex + 2, Persian.Camera.Projection);//Projection

//                    meshTag.DrawWithInnerEffect();
//                }
//            }

#if DEBUG
           // UsageReporter.debugInfo.ShadowCasterMeshes += UsageReporter.debugInfo.DrawCalls - HoldCounts;
#endif
        }

        internal void DrawWithCustomeEffect(Effect effect, int techniqueIndex, int passIndex)
        {
            foreach (var meshTag in this.modelMeshTagCollection)
            {
                meshTag.Draw(effect, techniqueIndex, passIndex);
            }
        }

        #endregion

        #region Dispose

        public void Dispose()
        {
            SystemMemory.SafeDispose(this.baseEffect);
            SystemMemory.SafeDispose(this.modelMeshTagCollection);
            SystemMemory.SafeDispose(this.slice);
        }

        #endregion
    }
}
