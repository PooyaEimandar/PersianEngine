/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : AnimationMeshData.cs
 * File Description : The data of mesh's animation 
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 1/14/2014
 * Comment          : 
 */

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using SkinnedMeshRuntime;

namespace PersianCore.Meshes.Components
{
    public class AnimationMeshData
    {
        #region Fields & Properties

        public bool UseMixer;
        public AnimationPlayer Player;
        public List<MixerInfo> MixerInfos;
        public Dictionary<string, AnimationMixer> Mixers;
        /// <summary>
        /// Pointer to Current Animation Mixer
        /// </summary>
        public AnimationMixer CurrentAnimationMixer { get; set; }
        public AnimationClip CurrentAnimation;
        public string CurrentAnimationName;
        public SkinningData skinningData;
        public bool BonesVisibility;
        public BoneData[] Bones;
        public bool? PlayFrameByFrame;//True means play one time, false means don not play and null means always play
        public bool BonesNeedUpdate;
        public long BlendValue;

        float[] animationsSpeeds;
        public float[] AnimationsSpeeds
        {
            get
            {
                if (this.skinningData != null)
                {
                    this.animationsSpeeds = new float[this.skinningData.AnimationClips.Length];
                    for (int i = 0; i < this.skinningData.AnimationClips.Length; i++)
                    {
                        animationsSpeeds[i] = this.skinningData.AnimationClips[i].AnimationSpeed;
                    }
                    return animationsSpeeds;
                }
                return new float[] { 0 };
            }
            set
            {
                animationsSpeeds = value;
            }
        }

        /// <summary>
        /// Enable or disable T Pos
        /// </summary>
        public bool TPos
        {
            get
            {
                if (UseMixer)
                {
                    return this.CurrentAnimationMixer.IsNotVisible;
                }
                else
                {
                    return this.Player.IsNotVisible;
                }
            }
            set
            {
                if (UseMixer)
                {
                    if (value)
                    {
                        this.CurrentAnimationMixer.EnableTPos();
                    }
                    else
                    {
                        this.CurrentAnimationMixer.DisableTPos();
                    }
                }
                else
                {
                    if (value)
                    {
                        this.Player.EnableTPos(this.skinningData);
                    }
                    else
                    {
                        this.Player.DisableTPos();
                    }
                }
            }
        }
        public Matrix[] SkinTransforms
        {
            get
            {
                return this.UseMixer ? this.CurrentAnimationMixer.SkinTransforms : this.Player.SkinTransforms;
            }
        }

        #endregion

        #region Constructor

        public AnimationMeshData()
        {
            this.BlendValue = 7000;
            this.PlayFrameByFrame = null;
            this.BonesNeedUpdate = false;
            this.MixerInfos = new List<MixerInfo>();
        }

        #endregion

        #region Load

        internal string Load(Guid Parent, string AnimationToLoad, float[] animationSpeedsArray)
        {
            this.animationsSpeeds = animationSpeedsArray;
            this.Player = new AnimationPlayer(this.skinningData, true, true)
            {
                IsLoopable = true,
            };
            this.Mixers = new Dictionary<string, AnimationMixer>();

            if (string.IsNullOrEmpty(AnimationToLoad))
            {
                this.CurrentAnimation = this.skinningData.AnimationClips[0];
            }
            else
            {
                var Q = from q in this.skinningData.AnimationClips where q.Name == AnimationToLoad select q;
                List<AnimationClip> ResultClips = Q.ToList();
                if (ResultClips.Count > 0)
                {
                    this.CurrentAnimation = ResultClips[0];
                }
            }

            #region Set Mixer Data if Available

            if (this.MixerInfos != null)
            {
                for (int i = 0; i < this.MixerInfos.Count; i++)
                {
                    var mixInfo = this.MixerInfos[i];

                    //Create Mixer
                    var mix = new AnimationMixer(this.skinningData)
                    {
                        Name = mixInfo.Name,
                        BonesInherit = mixInfo.BoneInherits != null ?
                        mixInfo.BoneInherits : null,
                        mixType = (AnimationMixer.MixType)mixInfo.MixerType,
                    };
                    //Add Tracks
                    mix.Add(mixInfo.AnimationTracks, mixInfo.AnimationTracksInverese,
                        mixInfo.AnimationSpeeds, mixInfo.BlendValues, mixInfo.DeltaBetweenFrames);
                    this.Mixers.Add(mixInfo.Name, mix);
                }
                this.CurrentAnimationMixer = this.Mixers.First().Value;
                this.UseMixer = true;
            }

            #endregion

            #region Get animations speed

            if (this.animationsSpeeds != null)
            {
                for (int i = 0; i < this.skinningData.AnimationClips.Length; ++i)
                {
                    this.skinningData.AnimationClips[i].AnimationSpeed = this.animationsSpeeds[i];
                }
            }
            else
            {
                this.CurrentAnimation.AnimationSpeed = 0.015f;
            }

            #endregion

            this.Player.StartClip(this.CurrentAnimation, this.BlendValue);

            #region Load the Bones spheres and Sort them by index

            var boneSize = this.skinningData.BoneNames.Count();
            this.Bones = new BoneData[boneSize];
            for (int i = 0; i < boneSize; i++)
            {
                var boneName = this.skinningData.BoneNames[i];
                this.Bones[i] = new BoneData(
                    Parent,
                    new SkinnedSphere()
                    {
                        BoneName = boneName,
                        Center = new Vector3(),
                        Radius = 1.5f,
                    },
                    this.Player.GetBoneNumberByName(boneName));
                this.Bones[i].NotifyBoneInheritChanged += new EventHandler<CmdEventArgs>(OnNotifyBoneInheritChanged);
            }

            Array.Sort(this.Bones, delegate(BoneData b1, BoneData b2)
            {
                return b1.Index.CompareTo(b2.Index);
            });

            #endregion

            return null;
        }

        #endregion

        #region Methods

        public void AddAnimationClip(AnimationClip clip)
        {
            var size = this.skinningData.AnimationClips.Length;
            Array.Resize<AnimationClip>(ref this.skinningData.AnimationClips, size + 1);
            this.skinningData.AnimationClips[size] = clip;
            //test
            this.Player.StartClip(clip);
        }

        internal void AddToMixer(MixerInfo mixerInfo)
        {
            if (this.Mixers.ContainsKey(mixerInfo.Name))
            {
                mixerInfo.Name = Persian.GetUniqueName("Mixed_");
            }

            var mix = new AnimationMixer(this.skinningData)
            {
                Name = mixerInfo.Name,
                mixType = (AnimationMixer.MixType)mixerInfo.MixerType,
                BonesInherit = mixerInfo.BoneInherits,
            };

            mix.Add(mixerInfo.AnimationTracks, mixerInfo.AnimationTracksInverese, 
                mixerInfo.AnimationSpeeds, mixerInfo.BlendValues, mixerInfo.DeltaBetweenFrames);
            this.Mixers.Add(mixerInfo.Name, mix);
            this.CurrentAnimationMixer = mix;
            this.UseMixer = true;

            if (this.MixerInfos == null)
            {
                this.MixerInfos = new List<MixerInfo>();
            }
            this.MixerInfos.Add(mixerInfo);
        }

        /// <summary>
        /// Return is a animation is exists
        /// </summary>
        /// <returns>first for mixers, second value for simple animation</returns>
        public bool[] ContainsAnimationClip(string Name)
        {
            return new bool[] 
            {
                QueryOnMixerAnimations(Name),
                QueryOnSimpleAnimations(Name)
            };
        }

        /// <summary>
        /// Play animation based on name 
        /// </summary>
        /// <param name="AnimationName">If you send the null, by default we search the animations based on CurrentAnimationName</param>
        /// <param name="isMixer">true = serach the animation mixers, false = serach the simple animations, null = search all</param>
        /// <returns></returns>
        internal bool SetAnimationUpponName(string AnimationName = null, bool? isMixer = null)
        {
            bool find = false;
            if (!String.IsNullOrWhiteSpace(AnimationName))
            {
                this.CurrentAnimationName = AnimationName;
            }

            if (isMixer == true)
            {
                find = QueryOnMixerAnimations(null);
            }
            else if (isMixer == false)
            {
                find = QueryOnSimpleAnimations(null);
            }
            else
            {
                find = QueryOnMixerAnimations(null);
                if (!find)
                {
                    find = QueryOnSimpleAnimations(null);
                }
            }
            return find;
        }

        private bool QueryOnMixerAnimations(string name)
        {
            bool find = false;

            #region Make Query and Select it from Mixers
            AnimationMixer mixer = null;
            this.Mixers.TryGetValue(name != null ? name : this.CurrentAnimationName, out mixer);
            if (mixer != null)
            {
                find = true;
                this.CurrentAnimationMixer = mixer;
                this.UseMixer = true;
            }
            #endregion

            return find;
        }

        private bool QueryOnSimpleAnimations(string name)
        {
            bool find = false;

            #region Make Query and Select it from Original Animations

            var findName = name != null ? name : this.CurrentAnimationName;
            var Q0 = from q in this.skinningData.AnimationClips
                     where q.Name == findName
                     select q;

            List<AnimationClip> R0 = Q0.ToList();
            if (R0.Count > 0)
            {
                find = true;
                this.Player.BlendToClip(R0[0], this.BlendValue);
                this.CurrentAnimation = R0[0];
                this.UseMixer = false;
            }

            #endregion

            return find;
        }

        #endregion

        #region Events

        private void OnNotifyBoneInheritChanged(object sender, CmdEventArgs e)
        {
            object[] datas = (object[])e.Data;
            int _index = (int)datas[0];
            int _inherit = (int)datas[1];

            var index = GetIndexMixerInfoByName(this.CurrentAnimationMixer.Name);
            
            if (_inherit == 0)
            {
                //if u wanna set it to base so remove it from dictionary...cause by default it will use first track
                this.CurrentAnimationMixer.BonesInherit.Remove(_index);
                this.MixerInfos[index].BoneInherits.Remove(_index);
            }
            else
            {
                int value = -1;
                if (this.CurrentAnimationMixer.BonesInherit.TryGetValue(_index, out value))
                {
                    //if is existing so change it
                    this.CurrentAnimationMixer.BonesInherit[_index] = _inherit;
                    this.MixerInfos[index].BoneInherits[_index] = _inherit;
                }
                else
                {
                    this.CurrentAnimationMixer.BonesInherit.Add(_index, _inherit);
                    this.MixerInfos[index].BoneInherits.Add(_index, _inherit);
                }
            }
        }

        private int GetIndexMixerInfoByName(string name)
        {
            for (int i = 0; i < this.MixerInfos.Count; ++i)
            {
                if (this.MixerInfos[i].Name == name)
                {
                    return i;
                }
            }
            throw new Exception("Missmatch with MixerInfos and Mixers");
        }

        #endregion

        #region Update

        internal void Update(Matrix World)
        {
            var gameTime = Persian.gameTime;
            
            #region Update the animation player State

            if (this.PlayFrameByFrame != false)
            {
                if (this.PlayFrameByFrame == true)
                {
                    this.PlayFrameByFrame = false;
                }

                #region Update Bones

                var sphere = new BoundingSphere();
                foreach (var bone in this.Bones)
                {
                    sphere.Center = bone.skinnedSphere.Center;
                    sphere.Radius = bone.skinnedSphere.Radius;
                    if (UseMixer)
                    {
                        bone.Update(this.CurrentAnimationMixer);
                    }
                    else
                    {
                        bone.Update(ref this.Player);
                    }
                    bone.Center = sphere.Transform(bone.World * World).Center;
                }

                #endregion

                var time = (float)gameTime.ElapsedGameTime.TotalMilliseconds;
                if (UseMixer)
                {
                    this.CurrentAnimationMixer.Update(time);
                }
                else
                {
                    this.Player.Update(time);
                }
            }

            #endregion
        }

        //private void UpdateBehavioral(Mesh.Behvioral UpperBehavioral, Mesh.Behvioral LowerBehavioral)
        //{
        //    #region Update Upper Behavioral

        //    if (UpperBehavioral == Mesh.Behvioral.Aiming || UpperBehavioral == Mesh.Behvioral.Shooting)
        //    {
        //        if (this.CurrentAnimationMixer.Tracks[0] != "FixToFire")
        //        {
        //            this.CurrentAnimationMixer.ChangeTrackTo(0, "FixToFire", 0.007f, false, 100000);
        //        }
        //    }
        //    else if (UpperBehavioral == Mesh.Behvioral.Idle)
        //    {
        //        if (LowerBehavioral == Mesh.Behvioral.Run)
        //        {
        //            if (this.CurrentAnimationMixer.Tracks[0] != "Run")
        //            {
        //                this.CurrentAnimationMixer.ChangeTrackTo(0, "Run", 0.0085f, true, 100000);
        //            }
        //        }
        //        //else if (LowerBehavioral == Mesh.Behvioral.Walk)
        //        //{
        //        //    if (this.CurrentAnimationMixer.Tracks[0] != "Walk")
        //        //    {
        //        //        this.CurrentAnimationMixer.ChangeTrackTo(0, "Walk", true, 100000);
        //        //    }
        //        //}
        //        //else if (LastUpperBehavioral == Mesh.Behvioral.Shooting)
        //        //{
        //        //    if (this.CurrentAnimationMixer.Tracks[0] != "FireToFix")
        //        //    {
        //        //        this.CurrentAnimationMixer.ChangeTrackTo(0, "FireToFix", 0.005f, false, 1000000);
        //        //    }
        //        //}
        //        //else
        //        //{
        //        //    if (this.CurrentAnimationMixer.Tracks[0] != "Fix")
        //        //    {
        //        //        this.CurrentAnimationMixer.ChangeTrackTo(0, "Fix", 0.008f, false, 1000000);
        //        //    }
        //        //}
        //    }

        //    #endregion

        //    if (LowerBehavioral == Mesh.Behvioral.Walk)
        //    {
        //        if (this.CurrentAnimationMixer.Tracks[1] != "Walk")
        //        {
        //            this.CurrentAnimationMixer.ChangeTrackTo(1, "Walk", 0.007f, true, 100000);
        //        }
        //    }
        //    else if (LowerBehavioral == Mesh.Behvioral.Run)
        //    {
        //        if (this.CurrentAnimationMixer.Tracks[1] != "Run")
        //        {
        //            this.CurrentAnimationMixer.ChangeTrackTo(1, "Run", 0.0085f, true, 100000);
        //        }
        //    }
        //    else if (LowerBehavioral == Mesh.Behvioral.Idle)
        //    {
        //        if (this.CurrentAnimationMixer.Tracks[1] != "Fix")
        //        {
        //            this.CurrentAnimationMixer.ChangeTrackTo(1, "Fix", 0.007f, false, 100000);
        //        }
        //    }

        //    LastUpperBehavioral = UpperBehavioral;
        //}

        private bool AllowSwape(int i, int j, int[,] Swaped)
        {
            if (i == j)
            {
                return false;
            }
            else
            {
                for (int C = 0; C < Swaped.Length / 2; C++)
                {
                    if ((Swaped[C, 0] == i && Swaped[C, 1] == j) || (Swaped[C, 0] == j && Swaped[C, 1] == i))
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        #endregion

        #region Draw

        internal void Draw(GraphicsDevice GDevice, Matrix GlobalWorld)
        {
            foreach (var bone in this.Bones)
            {
                if (this.BonesVisibility)
                {
                    if (bone.Visibility == 1)
                    {
                        bone.rigidBody.drawType = JitterPhysic.Dynamics.DrawType.WireFrame;
                    }
                    else
                    {
                        bone.rigidBody.drawType = JitterPhysic.Dynamics.DrawType.DoNotDraw;
                    }
                }
                else
                {
                    bone.rigidBody.drawType = JitterPhysic.Dynamics.DrawType.DoNotDraw;
                }
            }
        }

        #endregion

        #region Dispose

        public void Dispose()
        {

        }

        #endregion
    }
}
