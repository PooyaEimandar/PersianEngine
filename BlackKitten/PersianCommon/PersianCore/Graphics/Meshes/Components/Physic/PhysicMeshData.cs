/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : ObjectMeshData.cs
 * File Description : This class represents the information of mesh
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 5/15/2013
 * Comment          : 
 */

using JitterPhysic.Collision;
using JitterPhysic.Collision.Shapes;
using JitterPhysic.Dynamics;
using JitterPhysic.LinearMath;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Physic;
using System;
using System.Collections.Generic;

namespace PersianCore.Meshes.Components
{
    public class PhysicMeshData
    {
        #region Fields & Properties

        bool isSkinned;
        public PhysicTypes physicType;
        public bool Visibility;
        public BoundingBox boundingBox;
        public BoundingSphere boundingSphere
        {
            get
            {
                if (this.boundingBox == null) return new BoundingSphere();
                return BoundingSphere.CreateFromBoundingBox(this.boundingBox);
            }
        }
        public BoundingSphere SkinnedSpike;
        public bool ShowBoundings;
        public Matrix World;
        public RigidBody rigidBody;
        public Vector3 Rotation;
        public Vector3 Position;
        public Vector3 Scale;
        public Vector3 Velocity;
        public bool AffectedByGravity;
        public bool BuildPhysic;
        //public Vehicle vehicle;
        //public Weapon weapon;
        //string wheelModelPath;
        //public string WheelModelPath
        //{
        //    get
        //    {
        //        return wheelModelPath = this.vehicle !=null ? this.vehicle.WheelModelPath : null;
        //    }
        //    set
        //    {
        //        this.wheelModelPath = value;
        //    }
        //}

        bool enablePhysic;
        public bool EnablePhysic
        {
            get
            {
                if (this.rigidBody != null)
                {
                    return this.rigidBody.IsActive;
                }
                return this.enablePhysic;
            }
            set
            {
                this.enablePhysic = value;
                if (this.rigidBody != null)
                {
                    this.rigidBody.IsActive = value;
                }
            }
        }

        Mesh Parent { get; set; }

        #endregion

        #region Constructor

        public PhysicMeshData(Mesh Parent)
        {
            this.Parent = Parent;
            this.BuildPhysic = true;
            this.ShowBoundings = false;
            this.AffectedByGravity = true;
        }

        #endregion

        #region Load

        internal string Load(Model model, bool IsSkinned)
        {
            string HResult = null;

            this.isSkinned = IsSkinned;
            if (this.isSkinned && this.physicType == PhysicTypes.Static)
            {
                this.physicType = PhysicTypes.Dynamic;
            }
            if (this.rigidBody == null)
            {
                //If we already set the bounding box, so leave it
                BuildPhysicInfo(model, ref HResult);
                this.rigidBody.AffectedByGravity = AffectedByGravity;
                this.rigidBody.IsActive = this.enablePhysic;
            }

#if DEBUG
            if (this.isSkinned) this.ShowBoundings = true;
#endif

            return HResult;
        }

        /// <summary>
        /// Helper Method to get the vertex and index List from the model.
        /// </summary>
        /// <param name="vertices"></param>
        /// <param name="indices"></param>
        /// <param name="model"></param>
        public string ExtractData(List<Vector3> vertices, List<TriangleVertexIndices> indices, Model model)
        {
            string HResult = null;
            var bones_ = new Matrix[model.Bones.Count];
            model.CopyAbsoluteBoneTransformsTo(bones_);
            foreach (var mm in model.Meshes)
            {
                var xform = bones_[mm.ParentBone.Index];
                foreach (var mmp in mm.MeshParts)
                {
                    int offset = vertices.Count;
                    var a = new Vector3[mmp.NumVertices];
                    mmp.VertexBuffer.GetData<Vector3>(
                        mmp.VertexOffset * mmp.VertexBuffer.VertexDeclaration.VertexStride,
                        a,
                        0,
                        mmp.NumVertices,
                        mmp.VertexBuffer.VertexDeclaration.VertexStride);

                    for (int i = 0; i != a.Length; ++i)
                    {
                        Vector3.Transform(ref a[i], ref xform, out a[i]);
                    }
                    vertices.AddRange(a);

                    if (mmp.IndexBuffer.IndexElementSize != IndexElementSize.SixteenBits)
                    {
                        HResult = string.Format("Model uses 32-bit indices, which are not supported.");
                    }
                    var s = new short[mmp.PrimitiveCount * 3];
                    mmp.IndexBuffer.GetData<short>(mmp.StartIndex * 2, s, 0, mmp.PrimitiveCount * 3);
                    var tvi = new TriangleVertexIndices[mmp.PrimitiveCount];
                    for (int i = 0; i != tvi.Length; ++i)
                    {
                        tvi[i].I0 = s[i * 3 + 0] + offset;
                        tvi[i].I1 = s[i * 3 + 1] + offset;
                        tvi[i].I2 = s[i * 3 + 2] + offset;
                    }
                    indices.AddRange(tvi);
                }
            }
            return HResult;
        }

        #endregion

        #region Methods

        internal void BuildPhysicInfo(Model model, ref string HResult)
        {
            const string error = "The physic type of skinned object can be only Dynamic/DynamicLoadAtRunTime";
            switch (this.physicType)
            {
                case PhysicTypes.NoPhysic:
                    //even when we don not need physic, it is necessary to create rigid body
                    if (this.boundingBox.isZero())
                    {
                        this.boundingBox = Bounding.GetBoundingBox(model);
                    }
                    var shape = new BoxShape((this.boundingBox.Max - this.boundingBox.Min).ToJVector());
                    AddBodyToPhysicWorld(shape);
                    break;
                case PhysicTypes.Static:
                    if (isSkinned) throw new Exception(error);
                    BuildStatic(model, ref HResult);
                    break;
                case PhysicTypes.Dynamic:
                case PhysicTypes.DynamicLoadAtRunTime:
                    BuildDynamic();
                    break;
                //case PhysicTypes.Vehicle:
                //    //We do not need weapon
                //    this.weapon.Dispose();
                //    this.weapon = null;
                //    //Load vehicle
                //    this.vehicle.Load(this.boundingBox, this.wheelModelPath, this.Position, 2.0f, ref this.rigidBody, ref HResult);
                //    break;
                //case PhysicTypes.Weapon:
                //    //we do not need vehicle
                //    this.vehicle.Dispose();
                //    this.vehicle = null;
                //    //Load weapon
                //    this.weapon.Load(ref HResult);
                //    BuildDynamic();
                //    break;
            }
        }

        private void BuildDynamic()
        {
            if (this.isSkinned)
            {
                var shape = new SphereShape(1.0f);
                this.rigidBody = new RigidBody(shape);
                this.rigidBody.Damping = RigidBody.DampingType.Linear;
                this.rigidBody.Mass = 0.1f;
                this.rigidBody.Position = new JVector()
                {
                    X = this.Position.X,
                    Y = this.Position.Y,
                    Z = this.Position.Z
                };

                #region Comment

                //Upper
                //Upper = new RigidBody(new BoxShape(1.1f, 1.1f, 1.1f));
                //Upper.Damping = RigidBody.DampingType.Linear;
                //Upper.Mass = 0.1f;
                //Upper.Position = Conversion.ToJitterVector(pos) + new JVector(0, 5.0f, 0);

                //Upper.IsActive = false;
                //Demo.World.AddBody(Upper);

                // connect Upper and Lower
                //PointPointDistance connect = new PointPointDistance(Upper, Lower, Conversion.ToJitterVector(pos) + new JVector(0, 1.6f, 0), Conversion.ToJitterVector(pos) + new JVector(0, 1.5f, 0));
                //Demo.World.AddConstraint(connect);

                #endregion

                AddBodyToPhysicWorld(shape);
            }
            else
            {
                var shape = new BoxShape((this.boundingBox.Max - this.boundingBox.Min).ToJVector());
                AddBodyToPhysicWorld(shape);
            }
        }

        private void BuildStatic(Model model, ref string HResult)
        {
            var boneTransforms = new Matrix[model.Bones.Count];
            model.CopyAbsoluteBoneTransformsTo(boneTransforms);
            var indices = new List<TriangleVertexIndices>();
            var vertices = new List<Vector3>();
            HResult = ExtractData(vertices, indices, model);
            if (HResult != null) return;

            var jvertices = new List<JVector>(vertices.Count);
            foreach (var vertex in vertices)
            {
                jvertices.Add(vertex.ToJVector());
            }
            var octree = new Octree(jvertices, indices);
            var shape = new TriangleMeshShape(octree);

            if (this.boundingBox.isZero())
            {
                this.boundingBox = shape.BoundingBox.ToXnaBoundingBox();
            }

            AddBodyToPhysicWorld(shape);
        }

        private void AddBodyToPhysicWorld(Shape shape)
        {
            this.rigidBody = new RigidBody(shape);
            this.rigidBody.IsStatic = this.physicType == PhysicTypes.Static ? true : false;
            this.rigidBody.Position = new JVector()
            {
                X = this.Position.X,
                Y = this.Position.Y,
                Z = this.Position.Z
            };

#if DEBUG
            //if (!Persian.RunningEngine)
            //{
            //    this.rigidBody.EnableDebugDraw = true;
            //}
#endif
            //if We want load it in runtime so don't add it to world of physic
            if (this.physicType != PhysicTypes.NoPhysic && this.physicType != PhysicTypes.DynamicLoadAtRunTime)
            {
                PhysicManager.physicWorld.AddBody(this.rigidBody);
            }
        }

        #endregion

        #region Update

        internal void Update()
        {
            this.Position = this.rigidBody.Position.ToXNAVector();

            switch (physicType)
            {
                case PhysicTypes.NoPhysic:
                case PhysicTypes.Static:
                    this.World = Matrix.CreateScale(this.Scale) * 
                        PMathHelper.CreateRotationMatrix(this.Rotation) * 
                        Matrix.CreateTranslation(this.Position);

                    if (physicType == PhysicTypes.Static)
                    {
                        var orientation = PMathHelper.CreateRotationMatrix(this.Rotation);
                        this.rigidBody.Orientation = orientation.ToJMatrix();
                    }
                    break;
                case PhysicTypes.Dynamic:
                case PhysicTypes.DynamicLoadAtRunTime:
                    this.World = Matrix.CreateScale(this.Scale) *
                        this.rigidBody.Orientation.ToXNAMatrix() *
                        Matrix.CreateTranslation(this.Position);
                    break;
            }

            if (!Persian.RunningEngine && this.ShowBoundings)
            {
                this.SkinnedSpike = BoundingSphere.CreateFromBoundingBox(
                    this.rigidBody != null ? this.rigidBody.BoundingBox.ToXnaBoundingBox() : this.boundingBox);
            }
        }

        #endregion

        #region Draw

        internal void DrawBoundings(Effect effect, bool IsSkinned)
        {
#if DEBUG
            //if (this.ShowBoundings)
            //{
            //    Bounding.DrawBoundingBox(this.boundingBox, Persian.GDevice, effect, this.World, Color.White);
            //}
#endif
        }

        #endregion

        #region Dispose

        public void Dispose()
        {
            if (this.rigidBody != null)
            {
                PhysicManager.physicWorld.RemoveBody(this.rigidBody);
            }
        }

        #endregion
    }
}
