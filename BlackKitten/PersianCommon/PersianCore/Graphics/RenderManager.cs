/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : RenderManager.cs
 * File Description : The render manager for both render techniques
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 7/29/2013
 * Comment          : 
 */

using Debugger;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using PersianCore.Graphics.Lights;
using PersianCore.Graphics.Lights.PrepassTechnique;
using PersianCore.Graphics.PostProcessing;
using System;
using System.Collections.Generic;

namespace PersianCore.Graphics
{
    public class RenderManager
    {
        #region Fields & Properties

        RenderTarget resultTarget;
        Shadow shadow;
        Vector3[] currentFrustumCorners, cornersViewSpace, cornersWorldSpace;
        LightManager lightManager;

        /// <summary>
        /// Skip one frame and do not draw it
        /// </summary>
        // public static bool SkipOneFrame { get; set; }

        public List<Light> Lights
        {
            get
            {
                return this.lightManager.Lights;
            }
        }
        public static bool CachingGPU { get; set; }
        public bool EnableShadow { get; set; }
        public bool EnableDebug { get; set; }

        int shadowResolution;
        public int ShadowResolution
        {
            get
            {
                return this.shadowResolution;
            }
            set
            {
                if (this.shadowResolution != value)
                {
                    this.shadowResolution = value;
                    this.shadow.CASCADE_SHADOW_RESOLUTION = value;
                    this.shadow.SPOT_SHADOW_RESOLUTION = value;
                }
            }
        }
        public LightPrePassRendering PrePassRendering { get; set; }
        // public DeferredRendering DeferredRendering { get; set; }

        #endregion

        #region Constructor/Destructor

        public RenderManager()
        {
            this.EnableShadow = true;
            this.shadow = new Shadow();
            this.lightManager = new LightManager();
            this.cornersWorldSpace = new Vector3[8];
            this.cornersViewSpace = new Vector3[8];
            this.currentFrustumCorners = new Vector3[4];

            this.PrePassRendering = new LightPrePassRendering()
            {
                EnableShadows = true,
            };

            //this.DeferredRendering = new DeferredRendering()
            //{
            //    EnableShadows = true,
            //};
        }

        #endregion

        #region Events

        internal void OnPreparingDevice(PreparingDeviceSettingsEventArgs e)
        {
            this.PrePassRendering.OnPreparingDevice(e);
            //this.DeferredRendering.OnPreparingDevice(e);
        }

        #endregion

        #region Methods

        internal void AddLight(Light light)
        {
            this.lightManager.AddLight(light);
        }

        internal void RemoveAll()
        {
            this.lightManager.RemoveAll();
        }

        private void ComputeCameraFrustumCorners()
        {
            Persian.Camera.Frustum.GetCorners(cornersWorldSpace);
            Matrix matView = Persian.Camera.View;
            Vector3.Transform(cornersWorldSpace, ref matView, cornersViewSpace);
            for (int i = 0; i < 4; i++)
            {
                currentFrustumCorners[i] = cornersViewSpace[i + 4];
            }
            var temp = currentFrustumCorners[3];
            currentFrustumCorners[3] = currentFrustumCorners[2];
            currentFrustumCorners[2] = temp;
        }

        public void CreateSaveRealTimeCubeMap(Vector3 position, float zNear, float zFar, int width, int height, string fileName,
            SpriteBatch spriteBatch, ObjectsManager objectsManager, PostProcessor postProcessor)
        {
            string str = string.Empty;

            var oldProj = Persian.Camera.Projection;
            var oldView = Persian.Camera.View;
            var GDevice = Persian.GDevice;

            var fov = MathHelper.PiOver2;

            Persian.Camera.UseCustomeViewProjection = true;

            for (int i = 0; i < 6; i++)
            {
                var rt = new RenderTarget2D(GDevice, width, height);
                switch (i)
                {
                    case 0: //x+
                        str = "x+.jpg";
                        Persian.Camera.CustomUpdate(position, new Vector3(1, 0, 0) + position, new Vector3(0, 1, 0), fov, 1, zNear, zFar);
                        break;
                    case 1: //x-
                        str = "x-.jpg";
                        Persian.Camera.CustomUpdate(position, new Vector3(-1, 0, 0) + position, new Vector3(0, 1, 0), fov, 1, zNear, zFar);
                        break;
                    case 2: //y+
                        str = "y+.jpg";
                        Persian.Camera.CustomUpdate(position, new Vector3(0, 1, 0) + position, new Vector3(0, 0, -1), fov, 1, zNear, zFar);
                        break;
                    case 3: //y-
                        str = "y-.jpg";
                        Persian.Camera.CustomUpdate(position, new Vector3(0, -1, 0) + position, new Vector3(0, 0, 1), fov, 1, zNear, zFar);
                        break;
                    case 4: //z+
                        str = "z+.jpg";
                        Persian.Camera.CustomUpdate(position, new Vector3(0, 0, 1) + position, new Vector3(0, 1, 0), fov, 1, zNear, zFar);
                        break;
                    case 5: //z-
                        str = "z-.jpg";
                        Persian.Camera.CustomUpdate(position, new Vector3(0, 0, -1) + position, new Vector3(0, 1, 0), fov, 1, zNear, zFar);
                        break;
                }

                Texture2D resultBuffer = null;
                Draw(spriteBatch, objectsManager, postProcessor, null, ref resultBuffer);

                GDevice.SetRenderTarget(rt);
                {
                    GDevice.Clear(Color.Black);
                    spriteBatch.Begin();
                    {
                        spriteBatch.Draw(resultBuffer, Vector2.Zero, Color.White);
                        spriteBatch.End();
                    }
                    GDevice.SetRenderTarget(null);
                }
                using (var stream = System.IO.File.OpenWrite(fileName + str))
                {
                    rt.SaveAsJpeg(stream, width, height);
                    stream.Dispose();
                    rt.Dispose();
                }
            }

            Persian.Camera.SetProjection(oldProj);
            Persian.Camera.SetView(oldView);
            Persian.Camera.UseCustomeViewProjection = false;
        }

        #endregion

        #region Load

        internal void Load(ContentManager Content)
        {
            var width = Persian.GDevice.PresentationParameters.BackBufferWidth;
            var height = Persian.GDevice.PresentationParameters.BackBufferHeight;

            this.shadow.Load(Content);
            this.PrePassRendering.Load(Content);

            this.resultTarget = new RenderTarget(
                width,
                height,
                false,
                SurfaceFormat.Color,
                DepthFormat.None,
                0,
                RenderTargetUsage.DiscardContents);
        }

        #endregion

        #region Draw

        internal void Draw(SpriteBatch spriteBatch, ObjectsManager objectsManager,
            PostProcessor postProcessor, List<Action<GraphicsDevice>> RenderInvokes, 
            ref Texture2D resultBuffer)
        {
            Persian.GDevice.Clear(Color.Transparent);

            //Compute the frustum corners for this camera
            ComputeCameraFrustumCorners();

            GenerateShadows(objectsManager);

            this.PrePassRendering.Draw(
             spriteBatch,
             objectsManager,
             postProcessor,
             RenderInvokes,
             currentFrustumCorners,
             this.lightManager.VisibleLights,
             ref resultBuffer);

#if DEBUG
            UsageReporter.debugInfo.VisibleLights = (uint)this.lightManager.VisibleLights.Count;
            UsageReporter.debugInfo.ShadowCasterLights = (uint)this.lightManager.LightShadowCasters.Count;
#endif
        }

        private void GenerateShadows(ObjectsManager meshManager)
        {
            if (!this.EnableShadow) return;

            this.shadow.Initialize();
            //Sort light
            this.lightManager.SortLights();
            this.lightManager.SelectShadowCasters(this.shadow.GetFreeCascadeShadowMap(), this.shadow.GetFreeSpotShadowMap());

            foreach (var lCaster in this.lightManager.LightShadowCasters)
            {
                if (lCaster.LightType == LightType.Spot)
                {
                    this.shadow.GenerateShadowTextureSpotLight(lCaster, lCaster.spotShadowMap, meshManager);
                }
                else if (lCaster.LightType == Graphics.Lights.LightType.Directional)
                {
                    this.shadow.GenerateShadowTextureDirectionalLight(lCaster, lCaster.cascadeShadowMap, meshManager);
                }
            }
        }

        internal void ShowDebug(SpriteBatch spriteBatch)
        {
            if (!this.EnableDebug) return;

            Texture2D cascadeShadowMap = null;

            for (int i = 0; i < this.lightManager.LightShadowCasters.Count; ++i)
            {
                if (this.lightManager.LightShadowCasters[i].cascadeShadowMap != null)
                {
                    cascadeShadowMap = this.lightManager.LightShadowCasters[i].cascadeShadowMap.Target.Texture2D;
                    break;
                }
            }

            spriteBatch.Begin(SpriteSortMode.Texture, BlendState.Opaque, SamplerState.PointClamp, null, null);
            {
                this.PrePassRendering.ShowDebug(spriteBatch, cascadeShadowMap);
                spriteBatch.End();
            }
        }

        #endregion

        #region Dispose

        internal void Dispose()
        {
            this.PrePassRendering.Dispose();
            SystemMemory.SafeDispose(this.resultTarget);
        }

        #endregion
    }
}
