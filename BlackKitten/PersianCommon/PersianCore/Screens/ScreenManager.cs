/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : IntroScreen.cs
 * File Description : The intro screen
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 10/06/2013
 * Comment          : 
 */

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using PersianCore;
using PersianCore.Graphics;
using PersianSettings;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

public static class ScreenManager
{
    #region Fields & Properties

    //Transition

    /// <summary>
    /// Set true if you want to use Transitioning effect after compelting the scene
    /// </summary>
    public static bool StartTransitioning, Transitioning;
    static AutoResetEvent waitHandle;
    static float transitionTimer;
    static Effect transitionEffect;
    static RenderTarget transitionTarget;
    static RenderTarget lastTransitionTarget;

    static List<IScreen> screens;
    static bool showLoading;
    public static bool isShowingLoading
    {
        get
        {
            return showLoading;
        }
    }

    static IScreen loadingScreen;
    static TimeSpan time;
    static Texture2D textureTransition;
    public static bool Enable;
    public static UpdateState updateState;
    public static CoreFrameWork CFrameWorkInstance { get; set; }
    public static SpriteBatch spriteBatch;
    public static string LoadingOnTexturePath, LoadingOffTexturePath;

    static IScreen previousScreen;
    public static IScreen PreviousScreen
    {
        get
        {
            return previousScreen;
        }
    }

    static IScreen activeScreen;
    public static IScreen ActiveScreen
    {
        get 
        {
            return activeScreen;
        }
    }

    #endregion

    #region Constructor

    static ScreenManager()
    {
        if (Persian.RunningEngine)
        {
            LoadingOnTexturePath = @"Textures\Utilities\Loading\Hat_On";
            LoadingOffTexturePath = @"Textures\Utilities\Loading\Hat_Off";
        }
        else
        {
            LoadingOnTexturePath = @"Textures\Utilities\Loading\Persian_On";
            LoadingOffTexturePath = @"Textures\Utilities\Loading\Persian_Off";
        }
        screens = new List<IScreen>();
        previousScreen = null;
        activeScreen = null;
        Enable = true;
        updateState = UpdateState.Core;
        waitHandle = new AutoResetEvent(false);
        showLoading = false;
        Transitioning = false;
        StartTransitioning = true;
        ResetTransitionTime();
    }

    #endregion

    #region Load

    /// <summary>
    /// Load Screens
    /// </summary>
    /// <param name="CFrameWork">Instance of CoreFrameWork</param>
    public static void Load(CoreFrameWork CFrameWork, string EngineAssemblyName, string GameScreensNameSpaces)
    {
        spriteBatch = new SpriteBatch(Persian.GDevice);
        CFrameWorkInstance = CFrameWork;

        textureTransition = Persian.EngineContent.Load<Texture2D>(LoadingOnTexturePath);

        #region Load Transition

        transitionEffect = Persian.EngineContent.Load<Effect>(@"Shaders\PostProcessing\Transition");
        transitionEffect.Parameters["SmoothSize"].SetValue(0.05f);
        transitionTarget = new RenderTarget();
        lastTransitionTarget = new RenderTarget();

        #endregion

        #region Make Loading Screen

        loadingScreen = new PersianCore.Screens.LoadingScreen();
        loadingScreen.Load(CFrameWorkInstance);

        #endregion

        if (Persian.RunningEngine)
        {
            #region Dynamically load all game screens from content

            var screenInfos = Persian.EngineContent.Load<ScreenInfo[]>(@"Settings\Screens");
            foreach (var item in screenInfos)
            {
                try
                {
                    //For inside of this dll
                    //var scr = System.Activator.CreateInstance(Type.GetType("GameScreens." + item.Name));
                    var marshaled_plugin = (System.Runtime.Remoting.ObjectHandle)Activator.CreateInstance(EngineAssemblyName, GameScreensNameSpaces + item.Name);
                    var scr = (IScreen)marshaled_plugin.Unwrap();
                    (scr as IScreen).Info = item;
                    AddScreen(scr as IScreen);
                }
                catch
                {
                    Logger.WriteError(string.Format("Could not load{0} screen", item.Name));
                }
            }

            #endregion

            if (screens.Count != 0)
            {
                GotoScreen(screens[0].Info.Name);
            }
        }
    }

    #endregion

    #region Mathods

    private static void ResetTransitionTime()
    {
        transitionTimer = 1.3f;
    }

    /// <summary>
    /// Responsible to find and return specific screen
    /// </summary>
    /// <param name="Name"></param>
    /// <returns></returns>
    public static IScreen Search(string Name)
    {
        IScreen iScreen = null;
        for (int i = 0; i < screens.Count; ++i)
        {
            if (screens[i].Info.Name == Name)
            {
                iScreen = screens[i];
                break;
            }
        }
        return iScreen;
    }

    public static void AddScreen(IScreen screen)
    {
        foreach (var scr in screens)
        {
            if (scr.Info.Name == screen.Info.Name) return;
        }
        screens.Add(screen);
    }

    public static void GoBack()
    {
        if (previousScreen != null)
        {
            GotoScreen(previousScreen.Info.Name);
            return;
        }
    }

    public static void ShowLoadingScreen()
    {
        showLoading = true;
        updateState = UpdateState.Screen;
    }

    public static void HideLoadingScreen()
    {
        showLoading = false;
        updateState = activeScreen == null ? UpdateState.Core : activeScreen.Info.UpdateState;
    }

    public static void GotoScreen(string name)
    {
        //Start showing loading and focus on loading screen
        ShowLoadingScreen();
        ResetTransitionTime();

        //Load next screen on task
        var task = Task.Factory.StartNew(() =>
        {
#if DEBUG
            try
            {
#endif
                bool find = false;
                InputManager.Active = false;
                //Start in new task
                foreach (var screen in screens)
                {
                    if (screen.Info.Name == name)
                    {
                        //Render one frame of last screen to lastTransitionTarget then shutsdown previous screen   
                        previousScreen = activeScreen;

                        //Dispose the previous screen
                        if (previousScreen != null)
                        {
                            previousScreen.Dispose();
                        }

                        // Initialize New Screen
                        activeScreen = screen;
                        if (activeScreen.IsLoaded)
                        {
                            activeScreen.Initialize();
                        }
                        else
                        {
                            activeScreen.Load(CFrameWorkInstance);
                        }
                        //If this is the first time or the previous screen wanted to use transition effect, 
                        //so force the active screen to use transition effect
                        //else show next screen

                        StartTransitioning = activeScreen.Info.StartWithFading;
                        if (StartTransitioning)
                        {
                            //wait for signaling from previousScreen for seconds , it must draw on frame before disposing
                            waitHandle.WaitOne();
                        }
                        else
                        {
                            activeScreen.State = ScreenState.Running;
                        }

                        find = true;
                        //Wait before navigating to the next screen
                        System.Threading.Thread.Sleep(screen.Info.WaitBefore);

                        break;
                    }
                }

                //Stop showing loading
                HideLoadingScreen();
                updateState = activeScreen.Info.UpdateState;
                InputManager.Active = true;

                if (!find)
                {
                    Logger.WriteError(string.Format("Could not find the {0} screen", name));
                }
                //if (activeScreen.Info.NextScreenName.ToLower() == "null")
                //{
                //    //We are going to game, so there is no need ScreenManager for rendering we need CFramework
                //    Enable = false;
                //}
#if DEBUG
            }
            catch (Exception ex)
            {
                Logger.WriteError(string.Format(
                    "Error just happended on GotoScreen thread with following information : {0}", ex.ToStandardString()));
            }
#endif
        });
    }

    #endregion

    #region Events

    internal static void OnPreparingDevice(PreparingDeviceSettingsEventArgs e)
    {
        foreach (var screen in screens)
        {
            screen.OnPreparingDevice(e);
        }
    }

    #endregion

    #region Update

    public static bool Update()
    {
        if (!Enable) return false;

        var gameTime = Persian.gameTime;

        if (showLoading || activeScreen == null)
        {
            loadingScreen.Update();
        }
        else
        {
            time += gameTime.ElapsedGameTime;

            bool skipCheck = true;

            //When duration is zero, it means the screen will notify us on completing
            if ((activeScreen.Info.Duration == TimeSpan.Zero && activeScreen.State == ScreenState.Completed)
                || (activeScreen.Info.Duration != TimeSpan.Zero && time > activeScreen.Info.Duration))
            {
                skipCheck = false;
                GotoScreen(activeScreen.Info.NextScreenName);
            }
            //Checking wheather activeScreen is null or not is uppon skipCheck, cause activeScreen changed inside GotoScreen
            if (skipCheck || activeScreen != null)
            {
                if (activeScreen.State != ScreenState.Completed)
                {
                    activeScreen.Update();
                }
            }
        }
        return true;
    }

    #endregion

    #region Draw

    public static bool Draw()
    {
        if (!Enable) return false;

        if (showLoading || activeScreen == null)
        {
            if (StartTransitioning)
            {
                lastTransitionTarget.Begin();
                {
                    Persian.GDevice.Clear(Color.Black);
                    var pp = Persian.GDevice.PresentationParameters;
                    var tW = textureTransition.Width;
                    var tH = textureTransition.Height;

                    ScreenManager.spriteBatch.Begin();
                    {
                        ScreenManager.spriteBatch.Draw(textureTransition,
                            new Vector2((pp.BackBufferWidth / 2) - tW / 2,
                                (pp.BackBufferHeight / 2) - tH / 2), Color.White);
                        ScreenManager.spriteBatch.End();
                    }
                    //Always draw with it screen shot
                    lastTransitionTarget.End();
                }
                StartTransitioning = false;
                Transitioning = true;
                waitHandle.Set();
            }
            (loadingScreen as PersianCore.Screens.LoadingScreen).BackgroundTexture = CFrameWorkInstance.ResultBuffer;
            loadingScreen.Draw();
        }
        else
        {
            if (activeScreen.State == ScreenState.Completed)
            {
                //This stage happens only when the last screen completed in update and wants to draw just for 
                //one final frame, so we can force it to draw loading screen instead of one fake final frame
                loadingScreen.Draw();
            }
            else
            {
                if (Transitioning && activeScreen.IsLoaded)
                {
                    //Draw it to render target
                    transitionTarget.Begin();
                    {
                       // CFrameWorkInstance.Post.AddFlags(PersianCore.Graphics.PostProcessing.PostProcessType.GAUSSIAN_BLUR);
                     //   CFrameWorkInstance.Post.AddFlags(PersianCore.Graphics.PostProcessing.PostProcessType.NEGATIVE);

                        //Draw one frame of screen
                        if (activeScreen.Info.UpdateState == UpdateState.Screen)
                        {
                            activeScreen.Draw();
                        }
                        else
                        {
                            //Draw core and if update screen needs both, then draw both of them
                            spriteBatch.Begin(SpriteSortMode.Immediate, null, SamplerState.PointClamp, null, null);
                            {
                                spriteBatch.Draw(CFrameWorkInstance.ResultBuffer, Vector2.Zero, Color.White);
                                spriteBatch.End();
                            }
                            if (activeScreen.Info.UpdateState == UpdateState.Both)
                            {
                                activeScreen.Draw();
                            }
                        }

                      //  CFrameWorkInstance.Post.RemoveFlags(PersianCore.Graphics.PostProcessing.PostProcessType.GAUSSIAN_BLUR, false);
                      //  CFrameWorkInstance.Post.RemoveFlags(PersianCore.Graphics.PostProcessing.PostProcessType.NEGATIVE, false);

                        transitionTarget.End();
                    }

                    //Now make post processing of transition

                    transitionTimer += 0.05f;// (float)Persian.gameTime.ElapsedGameTime.Milliseconds / 500;
                    float fadeBetweenScenes = ((float)Math.Sin(transitionTimer) * 0.5f) + 0.5f;
                    if (fadeBetweenScenes >= 0.0f && fadeBetweenScenes <= 0.0001f)
                    {
                        Transitioning = false;
                        activeScreen.State = ScreenState.Running;
                    }

                    Persian.GDevice.Clear(ClearOptions.Target, Color.Black, 1.0f, 0);
                    Persian.GDevice.BlendState = BlendState.AlphaBlend;

                    transitionEffect.Parameters[0].SetValue(fadeBetweenScenes);//fadeAmount
                    transitionEffect.Parameters[2].SetValue(lastTransitionTarget.Texture2D);//texture1
                    transitionEffect.Parameters[3].SetValue(transitionTarget.Texture2D);//texture2
                    transitionEffect.CurrentTechnique.Passes[0].Apply();
                    {
                        Persian.Quad.Draw(SamplerState.PointClamp);
                    };
                }
                else
                {
                    activeScreen.Draw();
                }
            }
        }
        return true;
    }

    #endregion

    #region Dispose

    public static void Dispose()
    {
        loadingScreen.Dispose();
        spriteBatch.Dispose();
        CFrameWorkInstance = null;
    }

    #endregion
}
