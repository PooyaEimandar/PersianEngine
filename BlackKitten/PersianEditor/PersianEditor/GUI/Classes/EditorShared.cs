/*
 * Copyright (c) BaziPardaz.Co Ltd. All rights reserved.
 * 
 * File Name        : EditorShared.cs
 * File Description : The editor shared
 * Generated by     : Pooya Eimandar
 * Last modified by : Pooya Eimandar on 12/18/2013
 * Comment          : engineAssets added
 */

using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Data;

namespace PersianEditor
{
    class EditorShared
    {
        static Dictionary<string, string> engineAssets = new Dictionary<string, string>()
        {
            {@"EditorBrowser\Fonts", @"\Fonts"},

            {@"EditorBrowser\Models", @"\Models"},

            {@"EditorBrowser\Shaders\PostProcessing", @"\Shaders\PostProcessing"},
            {@"EditorBrowser\Shaders\AntiAliasing", @"\Shaders\AntiAliasing"},
            {@"EditorBrowser\Shaders\Environments", @"\Shaders\Environments"},
            {@"EditorBrowser\Shaders\PrePassRendering", @"\Shaders\PrePassRendering"},

            {@"EditorBrowser\Textures", @"\Textures"}, 

            {@"EditorBrowser\Settings", @"\Settings"},        
            {@"EditorBrowser\Sounds", @"\Sounds"},
            {@"EditorBrowser\Videos", @"\Videos"},
            {@"EditorBrowser\..\Utilities", @"\Utilities"},
        };

        public static Languages Language { get; set; }
        public static Color _BackColor = new Color(45, 46, 50);
        public static bool XnaFetchIO { get; set; }
        public static string CurrentScenePath { get; set; }
        public static string CurrentProjectPath { get; set; }
        public static object ObjectHolder { get; set; }//Use for copying or cutting
        /// <summary>
        /// if true means refreshing nodes and all related bindings are necessery
        /// </summary>
        public static bool RefreshBindingTags { get; set; }

        #region Methods

        internal static void SetTheme(EditorThemes editorThemes)
        {
            switch (editorThemes)
            {
                default:
                case EditorThemes.Black:
                    Telerik.Windows.Controls.StyleManager.ApplicationTheme = new Telerik.Windows.Controls.Expression_DarkTheme();
                    break;
                case EditorThemes.Silver:
                    Telerik.Windows.Controls.StyleManager.ApplicationTheme = new Telerik.Windows.Controls.Office_SilverTheme();
                    break;
                case EditorThemes.Transparent:
                    Telerik.Windows.Controls.StyleManager.ApplicationTheme = new Telerik.Windows.Controls.TransparentTheme();
                    break;
                case EditorThemes.Blue:
                    Telerik.Windows.Controls.StyleManager.ApplicationTheme = new Telerik.Windows.Controls.Office_BlueTheme();
                    break;
            }
        }

        public static string CreateEngineContentDirs(bool RemoveExisting)
        {
            string HResult = IOHelper.CreateDirectory(Persian.EngineContentDir, RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EngineContentDir + @"\Textures", RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EngineContentDir + @"\Shaders", RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EngineContentDir + @"\Models", RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EngineContentDir + @"\Fonts", RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EngineContentDir + @"\CutScenes", RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EngineContentDir + @"\Videos", RemoveExisting);
            if (HResult != null) return HResult;

            #region Now Copy Necessery Assets to Build Directory

            var currentContentPath = Persian.CurrentDir + @"\Content\";
            foreach (var key in engineAssets.Keys)
            {
                HResult = IOHelper.CopyDirectory(
                    currentContentPath + key,
                    Persian.EngineContentDir + engineAssets[key],
                    RemoveExisting);
                if (HResult != null) return HResult;
            }

            #endregion

            return HResult;
        }
        
        public static string CreateEditorContentDirs(bool RemoveExisting)
        {
            string HResult = IOHelper.CreateDirectory(Persian.EditorBrowserDir, RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EditorBrowserDir + @"\Textures", RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EditorBrowserDir + @"\Textures\NormalMaps", RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EditorBrowserDir + @"\Textures\SpecularMaps", RemoveExisting);
            if (HResult != null) return HResult;

            HResult = IOHelper.CreateDirectory(Persian.EditorBrowserDir + @"\Textures\GlowMaps", RemoveExisting);
            if (HResult != null) return HResult;

            return HResult;
        }

        public static bool BindTogether(object Source, System.Windows.PropertyPath SourcePropertyPath,
            object Destination, DependencyProperty dependencyProperty, BindingMode Mode, IValueConverter Converter)
        {
            var Q = from q in Destination.GetType().GetMethods().AsParallel().WithDegreeOfParallelism(Environment.ProcessorCount)
                    where q.Name == "SetBinding"
                    select q;
            var methods = Q.ToList();

            if (methods.Count == 0)
            {
                Logger.WriteLine(String.Format("Could Not Bind {0} and {1}", Source.GetType().Name, Destination.GetType().Name));
                return false;
            }
            var binding = new System.Windows.Data.Binding()
            {
                Source = Source,
                Path = SourcePropertyPath,
                Mode = Mode,
                UpdateSourceTrigger = System.Windows.Data.UpdateSourceTrigger.PropertyChanged
            };
            if (Converter != null)
            {
                binding.Converter = Converter;
            }
            methods[0].Invoke(Destination, new object[] { dependencyProperty, binding });

            return true;
        }

        #endregion
    }
}
